[{"id":0,"href":"/docs/","title":"Chapters","section":"The Io Programming Language","content":" The Io Programming Language # Navigate through the complete book below.\n"},{"id":1,"href":"/docs/00-preface/","title":"Why Io?","section":"Chapters","content":" Preface: Why Io? # In a world dominated by class-based object-oriented languages, why should you spend time learning Io, a prototype-based language with a relatively small community? This is a fair question, and one that deserves an honest answer.\nThe Value of Alternative Paradigms # Most programmers today work in languages that share remarkably similar conceptual foundations. Whether you\u0026rsquo;re writing Java, C#, Python, or Ruby, you\u0026rsquo;re likely thinking in terms of classes, instances, inheritance hierarchies, and static method definitions. These concepts have served us well, but they represent just one way of organizing computational thought.\nIo offers something different: a pure prototype-based object system where these familiar distinctions dissolve. There are no classes, only objects. There is no separation between data and behavior. Everything—including control structures and operators—is accomplished through message passing between objects.\nConsider this simple comparison. In Python, you might write:\nclass Dog: def __init__(self, name): self.name = name def bark(self): return f\u0026quot;{self.name} says woof!\u0026quot; fido = Dog(\u0026quot;Fido\u0026quot;) print(fido.bark()) In Io, the same concept looks like this:\nDog := Object clone Dog bark := method(name .. \u0026quot; says woof!\u0026quot;) fido := Dog clone fido name := \u0026quot;Fido\u0026quot; fido bark println At first glance, this might seem like a minor syntactic difference. But look closer: there\u0026rsquo;s no class definition, no constructor, no special initialization syntax. Dog is just an object that we\u0026rsquo;ve cloned from the base Object. fido is just a clone of Dog. The simplicity is profound.\nWhat You\u0026rsquo;ll Gain # 1. A Deeper Understanding of JavaScript # If you\u0026rsquo;ve ever been puzzled by JavaScript\u0026rsquo;s prototype chain, or wondered why typeof null === \u0026quot;object\u0026quot;, studying Io will illuminate these mysteries. JavaScript\u0026rsquo;s object model is essentially prototype-based (though complicated by the later addition of class syntax), and Io presents these same concepts in a much purer form.\n2. Freedom from Artificial Boundaries # In most languages, there\u0026rsquo;s a rigid distinction between what the language provides and what you can build. You can\u0026rsquo;t change how if statements work. You can\u0026rsquo;t modify how method calls are resolved. You can\u0026rsquo;t alter fundamental objects.\nIn Io, these boundaries don\u0026rsquo;t exist. The if statement is just a message sent to an object. Method resolution is customizable. Even basic types like Number and String can be modified at runtime. This isn\u0026rsquo;t just academically interesting—it enables patterns of expression impossible in more rigid languages.\n3. Appreciation for Message Passing # While many languages claim to support \u0026ldquo;message passing,\u0026rdquo; few take it as seriously as Io. When everything is truly a message—including operators, control flow, and assignment—you begin to see the elegant simplicity possible in language design. This perspective will change how you think about method calls and object interaction in any language.\n4. Metaprogramming Without Magic # Languages like Ruby pride themselves on metaprogramming capabilities, but often these features feel like special cases—magic methods, decorators, metaclasses. In Io, metaprogramming isn\u0026rsquo;t a special feature; it\u0026rsquo;s the natural consequence of a simple, consistent object model. When you can inspect and modify any object at runtime, including the objects that define the language itself, metaprogramming becomes straightforward rather than mystical.\nWho Should Read This Book # This book assumes you\u0026rsquo;re already a programmer. You should be comfortable with:\nBasic programming concepts (variables, functions, loops, conditions) Object-oriented programming in at least one language Using a command line and text editor The idea that different languages encourage different ways of thinking You don\u0026rsquo;t need to be an expert. In fact, if you\u0026rsquo;ve only worked in one or two mainstream languages, you might find Io\u0026rsquo;s different perspective especially valuable. Sometimes, those deeply entrenched in certain paradigms have the most difficulty seeing alternatives.\nWhat Makes Io Special # Steve Dekorte created Io in 2002 with several goals:\nSimplicity - A minimal syntax with maximum expressiveness Flexibility - Everything modifiable at runtime Uniformity - One consistent model for everything Power - Advanced features like coroutines and actors built-in The result is a language that fits in roughly 10,000 lines of C code, yet provides capabilities that mainstream languages achieve only through complex implementations or external libraries.\nA Language for Learning # I won\u0026rsquo;t pretend that Io is likely to become your primary development language. Its community is small, its libraries limited, and its performance, while respectable, isn\u0026rsquo;t competitive with systems languages or JIT-compiled platforms.\nBut Io excels as a language for learning. Its simple, consistent design makes it easy to understand completely. You can hold the entire language in your head. There are no special cases to remember, no historical baggage to work around. When you understand Io\u0026rsquo;s seven basic concepts, you understand the entire language.\nHow to Approach This Book # As you read, I encourage you to:\nRun every example. Io\u0026rsquo;s REPL starts instantly and makes experimentation effortless.\nModify the examples. What happens if you change this? What if you clone from a different object? What if you override this method?\nCompare with languages you know. When you see an Io pattern, think about how you\u0026rsquo;d accomplish the same thing in Python, JavaScript, or Java. What\u0026rsquo;s easier? What\u0026rsquo;s harder? What\u0026rsquo;s impossible?\nEmbrace the discomfort. Some Io concepts will feel alien at first. That\u0026rsquo;s good—it means you\u0026rsquo;re learning something genuinely new.\nA Personal Note # I\u0026rsquo;ve been programming for [X] years and have worked in dozens of languages. Most taught me new syntax or libraries. Io taught me new ways to think. It challenged assumptions I didn\u0026rsquo;t know I had. It showed me that many \u0026ldquo;fundamental\u0026rdquo; concepts in programming are actually just design choices, and different choices lead to different possibilities.\nWhether you spend a weekend or a month with Io, I believe you\u0026rsquo;ll emerge a better programmer. Not because you\u0026rsquo;ll use Io in production (though you might), but because you\u0026rsquo;ll have a broader perspective on what programming languages can be.\nLet\u0026rsquo;s begin.\nNext: Chapter 1 - Introduction: The Philosophy of Io\n"},{"id":2,"href":"/examples/","title":"Code Examples","section":"The Io Programming Language","content":" Code Examples # All code examples from the book are available for download and experimentation. Each example is a standalone .io file that you can run directly with the Io interpreter.\nRunning Examples # To run any example, use the Io interpreter:\nio hello.io Examples by Chapter # Part I: Foundations # Chapter 2: Getting Started hello.io - Your first Io program todo-list.io - A simple todo list application Part II: Core Concepts # Chapter 4: Prototypes, Not Classes prototypes.io - Working with prototypes Part III: Language Features # Chapter 9: Blocks and Closures closures.io - Understanding closures in Io Part IV: Advanced Topics # Chapter 11: Metaprogramming\nmetaprogramming.io - Runtime code manipulation Chapter 12: Concurrency\nconcurrency.io - Actors and coroutines Chapter 13: Domain-Specific Languages\nhtml-dsl.io - Building an HTML DSL Download All Examples # You can browse all examples or clone the repository to get all examples at once:\ngit clone https://github.com/yourusername/io-book-examples.git Contributing # Found an issue with an example? Want to contribute your own? Please submit a pull request or open an issue on GitHub.\n"},{"id":3,"href":"/docs/01-introduction/","title":"Introduction","section":"Chapters","content":" Chapter 1: Introduction - The Philosophy of Io # \u0026ldquo;The limits of my language mean the limits of my world.\u0026rdquo; - Ludwig Wittgenstein\nEvery programming language embodies a philosophy—a set of beliefs about how programs should be structured, how complexity should be managed, and what concepts are fundamental versus incidental. Java believes in protective encapsulation and type safety. Lisp believes in code as data. Haskell believes in mathematical purity.\nIo believes in radical simplicity through uniform message passing.\nThe Birth of Io # Steve Dekorte created Io in 2002, during an interesting period in programming language history. Java had conquered the enterprise. Python and Ruby were gaining traction as \u0026ldquo;scripting\u0026rdquo; languages. JavaScript was still dismissed as a toy for web browsers. The mainstream programming world had largely settled on class-based object-orientation as the \u0026ldquo;right\u0026rdquo; way to organize programs.\nBut Dekorte was inspired by older, more radical ideas:\nSmalltalk (1972): Everything is an object, computation happens through message passing Self (1986): Objects without classes, prototype-based inheritance Lisp (1958): Code as data, minimal syntax, powerful macros Lua (1993): Simplicity, embeddability, tables as the universal data structure NewtonScript (1993): Prototype-based inheritance in a practical system Here\u0026rsquo;s how Dekorte himself described his motivation:\n\u0026ldquo;I wanted a language that was small, simple, and consistent. Something you could understand completely. Most languages accumulate features over time, becoming more complex. I wanted to go the opposite direction—to see how much you could accomplish with how little.\u0026rdquo;\nThe Seven Pillars of Io # Io rests on seven fundamental concepts. Master these, and you\u0026rsquo;ve mastered the language:\n1. Everything is an Object # In Java or C++, primitives like integers and booleans aren\u0026rsquo;t objects—they\u0026rsquo;re special cases with different rules. In Io, everything is an object:\n3 type println // Number \u0026quot;hello\u0026quot; type println // Sequence true type println // true method() type println // Block Even true and false are objects. Even methods are objects. This uniformity eliminates countless special cases.\n2. Objects are Collections of Slots # An object in Io is essentially a collection of named slots. Each slot can hold any value—data, methods, other objects:\nperson := Object clone person name := \u0026quot;Alice\u0026quot; // data slot person age := 30 // data slot person greet := method(\u0026quot;Hello!\u0026quot;) // method slot person friend := Object clone // object slot Compare this to JavaScript, which has a similar model but complicated by functions, prototypes, constructors, and (now) classes. Io keeps it simple: objects have slots, period.\n3. Computation is Message Passing # This is perhaps Io\u0026rsquo;s most radical idea. In most languages, computation involves various mechanisms:\nFunction calls: sqrt(16) Method invocations: list.append(5) Operators: x + y Control structures: if (x \u0026gt; 0) { ... } Assignment: x = 5 In Io, all of these are just messages sent to objects:\nsqrt(16) // send message \u0026quot;sqrt\u0026quot; with argument 16 to current object list append(5) // send message \u0026quot;append\u0026quot; with argument 5 to list x + y // send message \u0026quot;+\u0026quot; with argument y to x if(x \u0026gt; 0, ...) // send message \u0026quot;if\u0026quot; with arguments to current object x = 5 // send message \u0026quot;setSlot\u0026quot; to current object This uniformity has profound implications we\u0026rsquo;ll explore throughout this book.\n4. Objects Inherit from Prototypes # Rather than defining classes as templates for objects, Io uses prototypes—objects that serve as templates for other objects:\nAnimal := Object clone Animal move := method(\u0026quot;Moving...\u0026quot; println) Dog := Animal clone Dog bark := method(\u0026quot;Woof!\u0026quot; println) fido := Dog clone fido move // \u0026quot;Moving...\u0026quot; (inherited from Animal) fido bark // \u0026quot;Woof!\u0026quot; (inherited from Dog) There\u0026rsquo;s no distinction between \u0026ldquo;class\u0026rdquo; and \u0026ldquo;instance\u0026rdquo;—just objects cloning other objects.\n5. Differential Inheritance # When you clone an object in Io, the new object doesn\u0026rsquo;t copy all the slots from its prototype. Instead, it maintains a reference to its prototype and only stores its differences:\nproto := Object clone proto x := 10 proto y := 20 child := proto clone child y = 30 // Only stores the difference child x println // 10 (from proto) child y println // 30 (from child) This is memory efficient and enables powerful runtime modifications.\n6. Everything is Modifiable at Runtime # In Io, nothing is sacred. You can modify any object at any time, including built-in types:\nNumber double := method(self * 2) 5 double println // 10 // Even more radical - redefine addition! Number + := method(n, self * n) 3 + 4 println // 12 (now multiplication!) This flexibility enables patterns impossible in more restrictive languages.\n7. Homoiconicity Through Messages # Like Lisp, Io code is represented as data structures that can be manipulated by the program itself. But where Lisp uses lists, Io uses messages:\ncode := message(1 + 2) code println // 1 +(2) code name println // + code arguments println // list(2) This enables powerful metaprogramming without special syntax.\nComparing Philosophies # To understand Io\u0026rsquo;s philosophy, let\u0026rsquo;s contrast it with mainstream languages:\nJava: Protection Through Types # public class BankAccount { private double balance; // Protected from direct access public void deposit(double amount) { if (amount \u0026gt; 0) { balance += amount; } } } Java believes in protection—private fields, type checking, compile-time verification. The compiler prevents mistakes.\nPython: Practicality and Conventions # class BankAccount: def __init__(self): self._balance = 0 # Convention: _ means \u0026quot;private\u0026quot; def deposit(self, amount): if amount \u0026gt; 0: self._balance += amount Python believes in \u0026ldquo;we\u0026rsquo;re all consenting adults.\u0026rdquo; Protection through convention, not enforcement.\nIo: Radical Flexibility # BankAccount := Object clone BankAccount balance := 0 BankAccount deposit := method(amount, if(amount \u0026gt; 0, balance = balance + amount) ) Io believes in complete openness. Any object can be modified by any code at any time. Power with responsibility.\nThe Cost of Simplicity # Io\u0026rsquo;s radical simplicity comes with trade-offs:\nPerformance: Without static typing or compile-time optimization, Io can\u0026rsquo;t match the speed of C++ or even JIT-compiled languages like Java. Message passing has overhead.\nTool Support: IDEs can\u0026rsquo;t provide the same level of assistance without static types and fixed class definitions. Refactoring tools are limited.\nError Detection: Many errors that would be caught at compile-time in other languages only surface at runtime in Io.\nLearning Curve: Paradoxically, Io\u0026rsquo;s simplicity can make it harder to learn. With fewer built-in concepts, you have to build more from primitives.\nThe Power of Simplicity # But simplicity also brings power:\nUnderstandability: You can understand the entire language. No edge cases, no historical baggage, no features that interact in surprising ways.\nFlexibility: Patterns that require language extensions or complex frameworks in other languages are trivial in Io.\nExpressiveness: With everything built from the same primitives, you can create abstractions that feel native to the language.\nExploration: Io is a playground for ideas that would be difficult to explore in more complex languages.\nA Living Language # Despite its small community, Io continues to evolve and inspire. Its ideas have influenced:\nJavaScript frameworks that embrace prototype-based patterns Ruby libraries that use method_missing for DSLs Newer languages like Factor and Ioke More importantly, Io continues to teach programmers that our familiar concepts—classes, types, compilation—are choices, not requirements.\nWhat\u0026rsquo;s Next # In the following chapters, we\u0026rsquo;ll explore Io systematically:\nFirst, we\u0026rsquo;ll get Io running and write our first programs Then, we\u0026rsquo;ll dive deep into the object model We\u0026rsquo;ll explore message passing and method resolution We\u0026rsquo;ll see how control structures emerge from simple primitives We\u0026rsquo;ll build increasingly sophisticated abstractions Finally, we\u0026rsquo;ll tackle advanced topics like concurrency and metaprogramming Along the way, we\u0026rsquo;ll constantly compare Io with languages you know, helping you see familiar concepts in a new light.\nReady to challenge everything you know about objects? Let\u0026rsquo;s begin.\nNext: Chapter 2 - Getting Started with Io\n"},{"id":4,"href":"/docs/02-getting-started/","title":"Getting Started","section":"Chapters","content":" Chapter 2: Getting Started with Io # The best way to understand Io is to use it. In this chapter, we\u0026rsquo;ll install Io, explore its REPL (Read-Eval-Print Loop), and write our first programs. By the end, you\u0026rsquo;ll have a feel for Io\u0026rsquo;s syntax and flow.\nInstalling Io # macOS # If you\u0026rsquo;re on macOS with Homebrew, installation is simple:\nbrew install io Linux # On most Linux distributions, you\u0026rsquo;ll need to build from source:\ngit clone https://github.com/IoLanguage/io.git cd io mkdir build cd build cmake .. make sudo make install Windows # Windows users should use WSL (Windows Subsystem for Linux) and follow the Linux instructions, or use Docker:\ndocker run -it --rm stevedekorte/io Verifying Installation # Once installed, verify Io is working:\n$ io --version Io Programming Language, v. 20170906 $ io Io\u0026gt; \u0026quot;Hello, World!\u0026quot; println Hello, World! ==\u0026gt; Hello, World! Io\u0026gt; ^C The REPL: Your Io Playground # Io\u0026rsquo;s REPL is where you\u0026rsquo;ll spend most of your learning time. Unlike compiled languages where you write, compile, and run, Io lets you experiment immediately.\nStart the REPL by typing io:\n$ io Io\u0026gt; The prompt Io\u0026gt; indicates Io is ready for input. Let\u0026rsquo;s explore:\nIo\u0026gt; 2 + 2 ==\u0026gt; 4 Io\u0026gt; \u0026quot;Hello\u0026quot; .. \u0026quot; \u0026quot; .. \u0026quot;World\u0026quot; ==\u0026gt; Hello World Io\u0026gt; 10 \u0026gt; 5 ==\u0026gt; true Notice the ==\u0026gt; prefix? That shows the return value of your expression. Everything in Io returns a value.\nREPL Tips # Multi-line input: The REPL detects incomplete expressions: Io\u0026gt; if(true, ... \u0026quot;yes\u0026quot; println, ... \u0026quot;no\u0026quot; println ... ) yes ==\u0026gt; yes Previous result: Use _ to reference the last result: Io\u0026gt; 100 * 2 ==\u0026gt; 200 Io\u0026gt; _ + 50 ==\u0026gt; 250 Getting help: The REPL has built-in documentation: Io\u0026gt; Lobby slotNames ==\u0026gt; list(Protos, _, exit, forward, set_) Io\u0026gt; Number slotNames sort ==\u0026gt; list(%, *, +, -, /, \u0026lt;, \u0026lt;=, ==, \u0026gt;, \u0026gt;=, abs, acos, asin, atan, between, ceil, cos, ...) Your First Io Program # Let\u0026rsquo;s write the traditional \u0026ldquo;Hello, World!\u0026rdquo; program. Create a file called hello.io:\n\u0026quot;Hello, World!\u0026quot; println Run it:\n$ io hello.io Hello, World! That\u0026rsquo;s it. No class definitions, no main function, no boilerplate. Compare with Java:\npublic class Hello { public static void main(String[] args) { System.out.println(\u0026quot;Hello, World!\u0026quot;); } } Or even Python:\nif __name__ == \u0026quot;__main__\u0026quot;: print(\u0026quot;Hello, World!\u0026quot;) Io just runs your code.\nUnderstanding Basic Syntax # Io\u0026rsquo;s syntax is minimal. Let\u0026rsquo;s explore the basics:\nMessages and Receivers # In Io, everything is about sending messages to objects:\n\u0026quot;hello\u0026quot; size // Send 'size' message to \u0026quot;hello\u0026quot; ==\u0026gt; 5 \u0026quot;hello\u0026quot; at(0) // Send 'at' message with argument 0 ==\u0026gt; h \u0026quot;hello\u0026quot; upper // Send 'upper' message ==\u0026gt; HELLO Compare with method calls in Python:\n\u0026quot;hello\u0026quot;.upper() # Python \u0026quot;hello\u0026quot; upper // Io - parentheses optional for no arguments Arguments # Messages can have arguments, passed in parentheses:\n\u0026quot;hello\u0026quot; at(1) // One argument ==\u0026gt; e \u0026quot;hello\u0026quot; slice(1, 3) // Two arguments ==\u0026gt; el List append(1, 2, 3) // Multiple arguments ==\u0026gt; list(1, 2, 3) Operators are Messages # This is crucial: operators in Io are just messages with special precedence:\n2 + 3 // Send message \u0026quot;+\u0026quot; to 2 with argument 3 2 +(3) // Exactly the same thing 2 send(\u0026quot;+\u0026quot;, 3) // Still the same thing! This uniformity means you can redefine operators:\nNumber + := method(n, self - n) // Redefine + to subtract! 5 + 3 ==\u0026gt; 2 (Don\u0026rsquo;t actually do this in real code!)\nVariables and Assignment # In Io, variables are just slots on objects. By default, you\u0026rsquo;re working with the Lobby object:\nx := 10 // Create slot 'x' on Lobby with value 10 x println // Print it ==\u0026gt; 10 x = 20 // Update existing slot x println ==\u0026gt; 20 y = 30 // Error! Slot doesn't exist // Exception: Slot y not found Note the distinction:\n:= creates a new slot = updates an existing slot This prevents accidental variable creation from typos:\ncounter := 0 countr = 1 // Error - probably a typo! Compare with JavaScript\u0026rsquo;s similar issue:\nlet counter = 0; countr = 1; // Creates global variable - probably a bug! Control Flow # Io\u0026rsquo;s control structures are methods, not special syntax:\nIf Statements # if(10 \u0026gt; 5, \u0026quot;Yes\u0026quot; println, \u0026quot;No\u0026quot; println ) // Prints: Yes Compare with Python:\nif 10 \u0026gt; 5: print(\u0026quot;Yes\u0026quot;) else: print(\u0026quot;No\u0026quot;) Since if is a method, you can even look at its implementation:\nIo\u0026gt; if ==\u0026gt; method(...) Loops # // While loop i := 0 while(i \u0026lt; 5, i println i = i + 1 ) // For loop for(i, 0, 4, i println ) // Times loop 5 times(i, i println ) Creating Objects # Let\u0026rsquo;s create our first custom object:\nPerson := Object clone Person name := \u0026quot;Unknown\u0026quot; Person greet := method( (\u0026quot;Hello, I'm \u0026quot; .. name) println ) alice := Person clone alice name = \u0026quot;Alice\u0026quot; alice greet // Prints: Hello, I'm Alice Compare with Python:\nclass Person: def __init__(self): self.name = \u0026quot;Unknown\u0026quot; def greet(self): print(f\u0026quot;Hello, I'm {self.name}\u0026quot;) alice = Person() alice.name = \u0026quot;Alice\u0026quot; alice.greet() The key difference: Io has no class definition. Person is just an object we\u0026rsquo;re using as a prototype.\nMethods # Methods in Io are created with the method function:\nCalculator := Object clone Calculator add := method(a, b, a + b) Calculator multiply := method(a, b, a * b) calc := Calculator clone calc add(5, 3) println // 8 calc multiply(4, 7) println // 28 Methods have access to self (the receiver):\nCounter := Object clone Counter count := 0 Counter increment := method( count = count + 1 self // Return self for chaining ) c := Counter clone c increment increment increment c count println // 3 Lists and Iteration # Lists are fundamental in Io:\nnumbers := list(1, 2, 3, 4, 5) // Iteration numbers foreach(n, n println ) // Map squared := numbers map(n, n * n) squared println // list(1, 4, 9, 16, 25) // Select (filter) evens := numbers select(n, n % 2 == 0) evens println // list(2, 4) // Reduce sum := numbers reduce(+) sum println // 15 Compare with Python:\nnumbers = [1, 2, 3, 4, 5] # Iteration for n in numbers: print(n) # Map squared = [n * n for n in numbers] # Filter evens = [n for n in numbers if n % 2 == 0] # Reduce from functools import reduce sum = reduce(lambda a, b: a + b, numbers) Working with Files # Reading and writing files is straightforward:\n// Write to file file := File with(\u0026quot;test.txt\u0026quot;) file openForWriting file write(\u0026quot;Hello, file!\u0026quot;) file close // Read from file file := File with(\u0026quot;test.txt\u0026quot;) file openForReading contents := file contents contents println file close // Or more concisely File with(\u0026quot;test.txt\u0026quot;) contents println A More Complete Example # Let\u0026rsquo;s build something more substantial—a simple to-do list:\n// todo.io - A simple to-do list manager TodoList := Object clone TodoList items := list() TodoList add := method(task, items append(task) self ) TodoList show := method( if(items size == 0, \u0026quot;No tasks!\u0026quot; println, items foreach(i, task, (\u0026quot; \u0026quot; .. (i + 1) .. \u0026quot;. \u0026quot; .. task) println ) ) self ) TodoList complete := method(index, if(index \u0026gt; 0 and index \u0026lt;= items size, task := items at(index - 1) items removeAt(index - 1) (\u0026quot;Completed: \u0026quot; .. task) println, \u0026quot;Invalid task number\u0026quot; println ) self ) TodoList save := method(filename, File with(filename) openForWriting write(items asJson) close \u0026quot;Saved!\u0026quot; println self ) TodoList load := method(filename, if(File with(filename) exists, items = Yajl parseJson(File with(filename) contents) \u0026quot;Loaded!\u0026quot; println, \u0026quot;File not found\u0026quot; println ) self ) // Usage todo := TodoList clone todo add(\u0026quot;Learn Io\u0026quot;) add(\u0026quot;Build something cool\u0026quot;) add(\u0026quot;Share with friends\u0026quot;) todo show // 1. Learn Io // 2. Build something cool // 3. Share with friends todo complete(1) // Completed: Learn Io todo show // 1. Build something cool // 2. Share with friends Key Takeaways # Having written your first Io programs, you\u0026rsquo;ve probably noticed:\nMinimal syntax: No keywords for defining classes, functions, or variables. Everything uses the same message-passing syntax.\nImmediate feedback: The REPL makes experimentation effortless.\nUniform model: Whether you\u0026rsquo;re doing arithmetic, defining methods, or creating objects, it\u0026rsquo;s all message passing.\nFlexibility: You can modify anything, even built-in types and operators.\nSimplicity: Programs are often shorter than their equivalents in other languages.\nExercises # Try these exercises to solidify your understanding:\nNumber methods: Add a squared method to Number that returns the square of a number. Test it with 5 squared.\nString reversal: Create a method on Sequence (Io\u0026rsquo;s string type) called reverse that returns the reversed string.\nBank account: Create a BankAccount object with balance, deposit, and withdraw methods. Include protection against negative balances.\nFizzBuzz: Implement FizzBuzz in Io (print numbers 1-100, but \u0026ldquo;Fizz\u0026rdquo; for multiples of 3, \u0026ldquo;Buzz\u0026rdquo; for multiples of 5, \u0026ldquo;FizzBuzz\u0026rdquo; for both).\nMethod chaining: Create a StringBuilder object that allows chaining: StringBuilder clone add(\u0026quot;Hello\u0026quot;) add(\u0026quot; \u0026quot;) add(\u0026quot;World\u0026quot;) toString\nWhat\u0026rsquo;s Different? # If you\u0026rsquo;re coming from mainstream languages, here\u0026rsquo;s what might feel strange:\nNo compile step: Your code runs immediately No type declarations: Everything is dynamically typed No class keyword: Objects are created by cloning Operators aren\u0026rsquo;t special: They\u0026rsquo;re just messages Everything returns a value: Even assignments and control structures These differences aren\u0026rsquo;t arbitrary—they all flow from Io\u0026rsquo;s core principle of uniform message passing.\nMoving Forward # You now have enough Io knowledge to explore the deeper concepts. You can:\nCreate and manipulate objects Define methods Use control structures Work with collections Read and write files In the next chapter, we\u0026rsquo;ll dive deep into Io\u0026rsquo;s object model and understand what \u0026ldquo;everything is an object\u0026rdquo; really means.\nNext: Chapter 3 - Everything is an Object\n"},{"id":5,"href":"/docs/03-everything-is-an-object/","title":"Everything is an Object","section":"Chapters","content":" Chapter 3: Everything is an Object # \u0026ldquo;Everything is an object\u0026rdquo; is a claim made by many languages. Ruby says it. Smalltalk says it. Even Java claims it (though primitives like int and boolean break the rule). But what does it really mean? And how thoroughly does Io embrace this principle?\nIn this chapter, we\u0026rsquo;ll explore how Io takes \u0026ldquo;everything is an object\u0026rdquo; to its logical extreme, and what this means for how you write and think about programs.\nWhat Is an Object? # Before we dive into Io\u0026rsquo;s object model, let\u0026rsquo;s establish what we mean by \u0026ldquo;object.\u0026rdquo; In most object-oriented languages, an object is:\nA bundle of state (data/attributes/fields) A set of behaviors (methods/functions) An identity (distinct from other objects) In Java, you might have:\nclass Dog { String name; // state int age; // state void bark() { // behavior System.out.println(\u0026quot;Woof!\u0026quot;); } } Dog fido = new Dog(); // identity (fido is distinct from other Dogs) But Java immediately breaks its own rules:\nint x = 5; // Not an object! x.toString(); // Error: int cannot be dereferenced Integer y = 5; // Now it's an object (boxed) y.toString(); // \u0026quot;5\u0026quot; Let\u0026rsquo;s see how Io handles this.\nNumbers are Objects # In Io, numbers aren\u0026rsquo;t primitives—they\u0026rsquo;re full objects:\n5 type println // Number 5 slotNames println // list(%, *, +, -, /, \u0026lt;, ...) // Numbers have methods 5 abs println // 5 -5 abs println // 5 5 sqrt println // 2.236... 5 sin println // -0.958... // You can add methods to numbers! Number double := method(self * 2) 5 double println // 10 // You can even inspect a number's prototype chain 5 proto println // Number_0x... 5 proto proto println // Object_0x... Compare this to Python, which claims everything is an object:\nx = 5 print(type(x)) # \u0026lt;class 'int'\u0026gt; print(dir(x)) # ['__abs__', '__add__', ...] # But you can't add methods to numbers x.double = lambda: x * 2 # AttributeError! Python\u0026rsquo;s numbers are objects, but they\u0026rsquo;re immutable objects with a fixed set of methods. Io\u0026rsquo;s numbers are fully modifiable objects.\nStrings are Objects (and Mutable!) # text := \u0026quot;hello\u0026quot; text type println // Sequence // Strings have methods text size println // 5 text upper println // HELLO text reverse println // olleh // But here's where it gets interesting - strings are MUTABLE text atPut(0, 72) // ASCII for 'H' text println // Hello // You can add methods to strings Sequence shout := method(self upper .. \u0026quot;!!!\u0026quot;) \u0026quot;hello\u0026quot; shout println // HELLO!!! This mutability might shock programmers from languages where strings are immutable:\n# Python - strings are immutable text = \u0026quot;hello\u0026quot; text[0] = 'H' # TypeError: 'str' object does not support item assignment # Java - strings are immutable String text = \u0026quot;hello\u0026quot;; text.charAt(0) = 'H'; // Error: cannot assign a value Booleans are Objects # Even true and false are objects:\ntrue type println // true false type println // false // They have methods true and(false) println // false true or(false) println // true true not println // false // The actual objects true println // true true proto println // Object_0x... // You can even add methods to booleans! true celebrate := method(\u0026quot;Yay!\u0026quot; println) (5 \u0026gt; 3) celebrate // Yay! This is different from most languages where booleans are either primitives or special immutable objects.\nnil is an Object # Even nothingness is an object in Io:\nnil type println // Object nil slotNames println // list(type, ...) // nil has methods! nil isNil println // true nil not println // true // You can add methods to nil nil greet := method(\u0026quot;Hello from nothing!\u0026quot; println) x := nil x greet // Hello from nothing! Compare with JavaScript\u0026rsquo;s confusing null:\ntypeof null // \u0026quot;object\u0026quot; (but it's not really) null.toString() // TypeError: Cannot read property 'toString' of null Methods are Objects # This is where things get really interesting. Methods themselves are objects:\nadd := method(a, b, a + b) add type println // Block // Methods have methods! add argumentNames println // list(a, b) add code println // a +(b) // You can modify methods add code println // a +(b) add setCode(block(a, b, a * b)) // Change implementation! add(3, 4) println // 12 (now multiplies!) // You can create methods from strings code := \u0026quot;a + b + 100\u0026quot; newMethod := block(a, b) setCode(code) newMethod call(5, 10) println // 115 This is far more powerful than most languages\u0026rsquo; function objects:\n# Python def add(a, b): return a + b print(type(add)) # \u0026lt;class 'function'\u0026gt; print(add.__code__) # \u0026lt;code object...\u0026gt; # But you can't easily modify the function's code at runtime Control Structures are Objects (Messages) # This might be the most mind-bending: if, while, and for aren\u0026rsquo;t syntax—they\u0026rsquo;re methods:\n// 'if' is a method on Object if type println // nil (it's a method) // You can see its implementation Object getSlot(\u0026quot;if\u0026quot;) println // method(...) // You can even redefine it! Object if := method(condition, trueBlock, falseBlock, \u0026quot;Making a decision...\u0026quot; println if(condition, trueBlock call, falseBlock call) ) if(true, \u0026quot;yes\u0026quot; println, \u0026quot;no\u0026quot; println) // Prints: Making a decision... // Prints: yes Let\u0026rsquo;s create our own control structure:\nObject unless := method(condition, block, if(condition not, block call) ) unless(5 \u0026gt; 10, \u0026quot;Math still works!\u0026quot; println ) // Prints: Math still works! Try doing that in Java or C++!\nOperators are Objects (Messages) # Operators aren\u0026rsquo;t special syntax—they\u0026rsquo;re messages:\n// These are equivalent 2 + 3 2 +(3) 2 send(\u0026quot;+\u0026quot;, 3) // You can redefine operators Number + := method(n, \u0026quot;Adding #{self} and #{n}\u0026quot; interpolate println self + n // Would cause infinite recursion! ) // Let's be more careful Number plusWithLogging := Number getSlot(\u0026quot;+\u0026quot;) Number + := method(n, \u0026quot;Adding #{self} and #{n}\u0026quot; interpolate println self plusWithLogging(n) ) 2 + 3 // Prints: Adding 2 and 3 // Returns: 5 You can even create new operators:\nOperatorTable addOperator(\u0026quot;**\u0026quot;, 3) // Right-associative, precedence 3 Number ** := method(n, self pow(n)) 2 ** 3 println // 8 2 ** 3 ** 2 println // 512 (right-associative: 2 ** (3 ** 2)) Lists are Objects # nums := list(1, 2, 3) nums type println // List // Lists have many methods nums size println // 3 nums first println // 1 nums last println // 3 nums reverse println // list(3, 2, 1) // Lists are mutable nums append(4) nums println // list(1, 2, 3, 4) // You can add custom methods to lists List sum := method( self reduce(+) ) list(1, 2, 3, 4, 5) sum println // 15 Even the Lobby is an Object # The global namespace in Io is an object called Lobby:\nLobby type println // Object Lobby slotNames println // list(all your global variables) // When you create a \u0026quot;global\u0026quot; variable, you're adding a slot to Lobby x := 10 Lobby hasSlot(\u0026quot;x\u0026quot;) println // true Lobby x println // 10 // You can manipulate the global namespace as an object Lobby removeSlot(\u0026quot;x\u0026quot;) x println // Exception: Slot x not found This is radically different from languages with special global scope rules.\nMessages Themselves are Objects # When you send a message, that message is an object:\nmsg := message(2 + 3) msg type println // Message msg name println // + msg arguments println // list(Message_0x...) msg arguments first code println // 3 // You can evaluate messages msg doInContext(Lobby) println // 5 // You can build messages programmatically msg := Message clone setName(\u0026quot;+\u0026quot;) setArguments(list(Message clone setName(\u0026quot;3\u0026quot;))) 2 doMessage(msg) println // 5 This is the foundation of Io\u0026rsquo;s metaprogramming capabilities.\nThe Object Hierarchy # Let\u0026rsquo;s explore how all these objects relate:\n// Everything ultimately inherits from Object 5 proto proto == Object println // true \u0026quot;hi\u0026quot; proto proto == Object println // true true proto == Object println // true list() proto proto == Object println // true // You can walk the prototype chain obj := 5 while(obj, obj type println obj = obj proto ) // Prints: // Number // Object Practical Implications # What does it mean that everything is truly an object?\n1. Uniform Interface # You can treat everything uniformly:\nthings := list(5, \u0026quot;hello\u0026quot;, true, nil, method(x, x * 2), list(1, 2)) things foreach(thing, (\u0026quot;Type: \u0026quot; .. thing type) println ) // Type: Number // Type: Sequence // Type: true // Type: Object // Type: Block // Type: List 2. No Special Cases # You don\u0026rsquo;t need to remember different rules for different types:\n// Everything can receive messages 5 println \u0026quot;hello\u0026quot; println true println nil println list(1,2,3) println // Everything can be inspected 5 slotNames \u0026quot;hello\u0026quot; slotNames true slotNames nil slotNames 3. Extensibility # You can extend anything:\n// Add methods to numbers for DSL Number days := method( Duration clone setDays(self) ) Number hours := method( Duration clone setHours(self) ) // Now you can write deadline := Date now + 3 days + 4 hours 4. Debugging Power # Since everything is an object, you can inspect everything:\nObject debugMethod := method(name, m := self getSlot(name) (\u0026quot;Method \u0026quot; .. name .. \u0026quot;:\u0026quot;) println (\u0026quot; Arguments: \u0026quot; .. m argumentNames) println (\u0026quot; Code: \u0026quot; .. m code) println ) List debugMethod(\u0026quot;append\u0026quot;) // Method append: // Arguments: list(...) // Code: ... Comparison with Other Languages # Ruby: \u0026ldquo;Everything is an object\u0026rdquo; (mostly) # 5.class # Integer \u0026quot;hello\u0026quot;.class # String true.class # TrueClass nil.class # NilClass # But... if.class # SyntaxError! 'if' isn't an object Python: \u0026ldquo;Everything is an object\u0026rdquo; (sort of) # type(5) # \u0026lt;class 'int'\u0026gt; type(\u0026quot;hello\u0026quot;) # \u0026lt;class 'str'\u0026gt; type(True) # \u0026lt;class 'bool'\u0026gt; type(None) # \u0026lt;class 'NoneType'\u0026gt; # But... type(if) # SyntaxError! 'if' isn't an object type(+) # SyntaxError! '+' isn't an object JavaScript: \u0026ldquo;Everything is an object\u0026rdquo; (except when it\u0026rsquo;s not) # typeof 5 // \u0026quot;number\u0026quot; (primitive) typeof \u0026quot;hello\u0026quot; // \u0026quot;string\u0026quot; (primitive) typeof true // \u0026quot;boolean\u0026quot; (primitive) typeof {} // \u0026quot;object\u0026quot; // Autoboxing happens sometimes (5).toString() // \u0026quot;5\u0026quot; (temporarily boxed) 5.x = 10 // Silently fails! Io: Everything IS an object (no exceptions) # 5 type // Number (object) \u0026quot;hello\u0026quot; type // Sequence (object) true type // true (object) if type // nil (it's a method, which is an object) + type // nil (it's a method, which is an object) Exercises # Object Inspector: Write a method inspect that can be called on any object and prints:\nIts type Its slot names Its prototype chain Custom Boolean: Create your own boolean system with objects Yes and No that have methods and, or, and not.\nOperator Overloading: Define a Vector object with x and y slots, then overload the + operator to add vectors.\nControl Structure: Create a repeat(n, block) control structure that executes a block n times.\nMessage Logger: Modify the Object prototype to log every message sent to any object (hint: override forward).\nPhilosophical Implications # Io\u0026rsquo;s radical \u0026ldquo;everything is an object\u0026rdquo; approach has profound implications:\nSimplicity through uniformity: One concept (objects) explains everything Power through openness: Nothing is sealed or special Learning through exploration: You can inspect and understand everything Danger through freedom: You can break everything This last point is important. With great power comes great responsibility. Io trusts you completely. You can redefine addition, break the if statement, or delete critical system objects. This isn\u0026rsquo;t a bug—it\u0026rsquo;s a philosophy.\nConclusion # In Io, \u0026ldquo;everything is an object\u0026rdquo; isn\u0026rsquo;t marketing—it\u0026rsquo;s a fundamental truth that shapes every aspect of the language. Numbers, strings, booleans, nil, methods, operators, control structures, and even messages themselves are all objects with slots that can be inspected, modified, and extended.\nThis uniformity eliminates special cases, enables powerful metaprogramming, and provides a conceptually simple (if initially mind-bending) programming model. Once you internalize that everything is just objects sending messages to other objects, Io\u0026rsquo;s entire design clicks into place.\nNext, we\u0026rsquo;ll explore how objects relate to each other through Io\u0026rsquo;s prototype-based inheritance system—a world without classes.\nNext: Chapter 4 - Prototypes, Not Classes\n"},{"id":6,"href":"/docs/04-prototypes-not-classes/","title":"Prototypes, Not Classes","section":"Chapters","content":" Chapter 4: Prototypes, Not Classes # Most object-oriented languages use classes as templates or blueprints for creating objects. You define a class, then instantiate objects from it. There\u0026rsquo;s a fundamental distinction between the template (class) and the things created from it (instances).\nIo takes a different approach: prototype-based inheritance. There are no classes, only objects. New objects are created by cloning existing objects, and objects can serve as prototypes for other objects. This might seem like a small change, but it fundamentally alters how you think about and structure programs.\nThe Class-Based World # Let\u0026rsquo;s start with what you probably know. In a class-based language like Java:\n// Define a class (template) class Animal { String name; void speak() { System.out.println(\u0026quot;Some sound\u0026quot;); } } // Define a subclass class Dog extends Animal { void speak() { System.out.println(\u0026quot;Woof!\u0026quot;); } } // Create instances Dog fido = new Dog(); Dog rover = new Dog(); The key points:\nAnimal and Dog are classes (templates) fido and rover are instances (objects) Classes and instances are fundamentally different things Inheritance happens between classes The Prototype-Based World # In Io, there are no classes:\n// Create an object to serve as a prototype Animal := Object clone Animal speak := method(\u0026quot;Some sound\u0026quot; println) // Create another object using Animal as a prototype Dog := Animal clone Dog speak := method(\u0026quot;Woof!\u0026quot; println) // Create more objects using Dog as a prototype fido := Dog clone rover := Dog clone The key differences:\nAnimal, Dog, fido, and rover are all objects No fundamental distinction between \u0026ldquo;classes\u0026rdquo; and \u0026ldquo;instances\u0026rdquo; Objects are created by cloning other objects Any object can serve as a prototype for other objects Understanding Cloning # When you clone an object in Io, you don\u0026rsquo;t copy all its slots. Instead, you create a new, empty object that maintains a reference to its prototype:\nAnimal := Object clone Animal name := \u0026quot;Generic Animal\u0026quot; Animal speak := method(name println) dog := Animal clone // dog doesn't have its own 'name' slot dog hasLocalSlot(\u0026quot;name\u0026quot;) println // false // But it can access 'name' through its prototype dog name println // \u0026quot;Generic Animal\u0026quot; // Now give dog its own name dog name = \u0026quot;Fido\u0026quot; dog hasLocalSlot(\u0026quot;name\u0026quot;) println // true dog name println // \u0026quot;Fido\u0026quot; // Animal's name is unchanged Animal name println // \u0026quot;Generic Animal\u0026quot; This is called differential inheritance—objects only store their differences from their prototypes.\nThe Prototype Chain # When you send a message to an object, Io looks for a matching slot:\nFirst in the object itself Then in its prototype Then in the prototype\u0026rsquo;s prototype And so on until it reaches Object // Create a chain of prototypes Organism := Object clone Organism live := method(\u0026quot;Living...\u0026quot; println) Animal := Organism clone Animal move := method(\u0026quot;Moving...\u0026quot; println) Dog := Animal clone Dog bark := method(\u0026quot;Woof!\u0026quot; println) fido := Dog clone fido name := \u0026quot;Fido\u0026quot; // fido can access methods from anywhere in the chain fido live // \u0026quot;Living...\u0026quot; (from Organism) fido move // \u0026quot;Moving...\u0026quot; (from Animal) fido bark // \u0026quot;Woof!\u0026quot; (from Dog) // You can inspect the chain fido proto == Dog println // true fido proto proto == Animal println // true fido proto proto proto == Organism println // true Dynamic Prototype Modification # Since prototypes are just objects, you can modify them at runtime, and all objects using that prototype see the changes:\nDog := Object clone fido := Dog clone rover := Dog clone // Add a method to Dog Dog bark := method(\u0026quot;Woof!\u0026quot; println) // Both fido and rover can now bark fido bark // \u0026quot;Woof!\u0026quot; rover bark // \u0026quot;Woof!\u0026quot; // Modify the method Dog bark = method(\u0026quot;WOOF! WOOF!\u0026quot; println) // The change affects all dogs fido bark // \u0026quot;WOOF! WOOF!\u0026quot; rover bark // \u0026quot;WOOF! WOOF!\u0026quot; Try doing that with classes in Java! You\u0026rsquo;d need complex reflection APIs, and even then, you couldn\u0026rsquo;t modify existing instances.\nMultiple Prototypes # Io supports multiple inheritance through its Protos list:\n// Create two prototypes Flyable := Object clone Flyable fly := method(\u0026quot;Flying...\u0026quot; println) Swimmable := Object clone Swimmable swim := method(\u0026quot;Swimming...\u0026quot; println) // Create an object with multiple prototypes Duck := Object clone Duck appendProto(Flyable) Duck appendProto(Swimmable) mallard := Duck clone mallard fly // \u0026quot;Flying...\u0026quot; mallard swim // \u0026quot;Swimming...\u0026quot; // Inspect the prototype list Duck protos println // list(Object_0x..., Flyable_0x..., Swimmable_0x...) The search order for slots is depth-first through the Protos list.\nComparing Approaches: Class vs Prototype # Let\u0026rsquo;s implement the same concept in both paradigms to see the differences.\nClass-Based (Python) # class Shape: def __init__(self): self.x = 0 self.y = 0 def move(self, dx, dy): self.x += dx self.y += dy class Circle(Shape): def __init__(self, radius): super().__init__() self.radius = radius def area(self): return 3.14159 * self.radius ** 2 # Usage circle = Circle(5) circle.move(10, 20) print(circle.area()) # Can't easily create a one-off variation # Would need to define a new class Prototype-Based (Io) # Shape := Object clone Shape x := 0 Shape y := 0 Shape move := method(dx, dy, x = x + dx y = y + dy ) Circle := Shape clone Circle radius := 0 Circle area := method( 3.14159 * radius * radius ) // Usage circle := Circle clone circle radius = 5 circle move(10, 20) circle area println // Easy to create one-off variations specialCircle := Circle clone specialCircle area = method( \u0026quot;Special area: \u0026quot; print resend // Call the original method ) specialCircle area // \u0026quot;Special area: 78.53975\u0026quot; The Power of Prototypes # 1. Objects as Classes # In Io, objects can act as classes when needed:\n// Person acts like a class Person := Object clone Person init := method( self name := \u0026quot;Unknown\u0026quot; self age := 0 self ) Person create := method(n, a, clone init name = n age = a ) // Usage feels class-like alice := Person create(\u0026quot;Alice\u0026quot;, 30) bob := Person create(\u0026quot;Bob\u0026quot;, 25) 2. One-Off Objects # You can create unique objects without defining a \u0026ldquo;class\u0026rdquo;:\n// Create a unique object with no \u0026quot;class\u0026quot; singleton := Object clone singleton data := Map clone singleton store := method(key, value, data atPut(key, value) ) singleton retrieve := method(key, data at(key) ) // Use it directly singleton store(\u0026quot;user\u0026quot;, \u0026quot;Alice\u0026quot;) singleton retrieve(\u0026quot;user\u0026quot;) println // \u0026quot;Alice\u0026quot; 3. Runtime Class Modification # You can fundamentally change what a \u0026ldquo;class\u0026rdquo; does:\nNumber := Object clone Number value := 0 Number + := method(n, result := Number clone result value = self value + n value result ) // Create numbers five := Number clone value = 5 three := Number clone value = 3 // Now change how Number works Number + = method(n, result := Number clone result value = self value * n value // Multiply instead! result ) // Existing numbers use the new behavior eight := five + three eight value println // 15 (multiplication!) Delegation vs Inheritance # Prototype-based languages use delegation rather than inheritance. When an object doesn\u0026rsquo;t have a slot, it delegates to its prototype:\nAccount := Object clone Account balance := 0 Account deposit := method(amount, balance = balance + amount self ) savings := Account clone savings deposit(100) // Let's trace what happens: // 1. savings receives 'deposit' message // 2. savings doesn't have 'deposit' slot // 3. savings delegates to Account // 4. Account's deposit method runs // 5. But 'self' is still savings // 6. So savings's balance is updated savings balance println // 100 Account balance println // 0 (unchanged) This is subtly different from class-based inheritance where methods are copied or looked up in a class hierarchy.\nPractical Patterns # The Constructor Pattern # While Io doesn\u0026rsquo;t have constructors, you can create them:\nPerson := Object clone Person init := method(name, age, self name := name self age := age self ) Person new := method(name, age, self clone init(name, age) ) // Usage alice := Person new(\u0026quot;Alice\u0026quot;, 30) The Mixin Pattern # Use prototypes as mixins for shared behavior:\n// Define mixins Timestamped := Object clone Timestamped createdAt := Date now Timestamped age := method( Date now - createdAt ) Serializable := Object clone Serializable toJson := method( // Implementation ) // Use mixins Document := Object clone Document appendProto(Timestamped) Document appendProto(Serializable) doc := Document clone doc age println doc toJson The Factory Pattern # Objects can create other objects with specific configurations:\nShapeFactory := Object clone ShapeFactory circle := method(radius, c := Object clone c radius := radius c area := method(3.14159 * radius * radius) c ) ShapeFactory rectangle := method(width, height, r := Object clone r width := width r height := height r area := method(width * height) r ) // Usage myCircle := ShapeFactory circle(5) myRect := ShapeFactory rectangle(10, 20) JavaScript: A Familiar Prototype System # If you know JavaScript, you\u0026rsquo;ve already used prototype-based programming:\n// JavaScript (before ES6 classes) function Animal(name) { this.name = name; } Animal.prototype.speak = function() { console.log(\u0026quot;Some sound\u0026quot;); }; function Dog(name) { Animal.call(this, name); } Dog.prototype = Object.create(Animal.prototype); Dog.prototype.bark = function() { console.log(\u0026quot;Woof!\u0026quot;); }; But JavaScript complicated things with constructor functions and later added class syntax as sugar. Io keeps prototypes pure and simple.\nCommon Misconceptions # \u0026ldquo;No Classes Means No Structure\u0026rdquo; # False. You can create well-structured programs with prototypes:\n// Define clear prototype hierarchies Vehicle := Object clone Vehicle speed := 0 Car := Vehicle clone Car wheels := 4 ElectricCar := Car clone ElectricCar batteryLevel := 100 // The structure is clear and maintainable \u0026ldquo;Prototypes Are Just Classes With Different Syntax\u0026rdquo; # False. Prototypes are more flexible:\n// Start with a prototype Dog := Object clone Dog bark := method(\u0026quot;Woof!\u0026quot; println) fido := Dog clone // Later, change fido's prototype! Cat := Object clone Cat meow := method(\u0026quot;Meow!\u0026quot; println) fido protos = list(Cat) fido meow // \u0026quot;Meow!\u0026quot; - fido is now a cat! You can\u0026rsquo;t change an object\u0026rsquo;s class at runtime in most class-based languages.\n\u0026ldquo;Multiple Inheritance Is Always Confusing\u0026rdquo; # Io\u0026rsquo;s prototype lists make multiple inheritance explicit and controllable:\nA := Object clone A foo := method(\u0026quot;A's foo\u0026quot; println) B := Object clone B foo := method(\u0026quot;B's foo\u0026quot; println) C := Object clone C appendProto(A) C appendProto(B) C foo // \u0026quot;A's foo\u0026quot; (A comes first in the list) // Reorder to change priority C protos = list(B, A) C foo // \u0026quot;B's foo\u0026quot; (B now comes first) Exercises # Prototype Chain Explorer: Write a method that prints an object\u0026rsquo;s complete prototype chain with indentation showing the hierarchy.\nClass Emulator: Create a Class object that provides new, extends, and other class-like conveniences while using prototypes underneath.\nMultiple Inheritance Diamond: Create a diamond inheritance pattern (D inherits from B and C, which both inherit from A) and explore how Io resolves method conflicts.\nDynamic Reclassing: Write a become method that changes an object\u0026rsquo;s prototype chain to make it \u0026ldquo;become\u0026rdquo; an instance of a different prototype.\nPrototype Versioning: Implement a system where objects can \u0026ldquo;lock\u0026rdquo; to a specific version of their prototype, unaffected by later prototype modifications.\nReal-World Implications # Prototype-based programming shines in certain scenarios:\nRapid Prototyping: Create and modify objects on the fly without defining classes Dynamic Systems: Systems where object behavior needs to change at runtime DSLs: Domain-specific languages where objects morph based on context Learning: Understanding prototypes deepens your understanding of JavaScript Simplicity: No distinction between classes and objects means fewer concepts Conclusion # Prototype-based programming isn\u0026rsquo;t just \u0026ldquo;classes with different syntax\u0026rdquo;—it\u0026rsquo;s a fundamentally different way of thinking about objects and inheritance. Instead of rigid templates (classes) and instances, you have a fluid world where any object can serve as a template for others, where inheritance is delegation, and where the structure of your program can change at runtime.\nThis flexibility can be overwhelming at first, especially if you\u0026rsquo;re used to the safety of static classes. But it can also be liberating. You\u0026rsquo;re not constrained by decisions made at compile time. You can experiment, evolve, and adapt your objects as your understanding of the problem grows.\nIn the next chapter, we\u0026rsquo;ll dive deeper into how objects communicate through Io\u0026rsquo;s message passing system—the heartbeat of the language.\nNext: Chapter 5 - Messages and Slots\n"},{"id":7,"href":"/docs/05-messages-and-slots/","title":"Messages and Slots","section":"Chapters","content":" Chapter 5: Messages and Slots # At the heart of Io lies a simple but powerful idea: all computation happens through message passing. Objects communicate by sending messages to each other, and objects respond to messages by looking up slots. This chapter explores this fundamental mechanism in depth.\nThe Anatomy of a Message # When you write this in Io:\nperson setName(\u0026quot;Alice\u0026quot;) What actually happens? Let\u0026rsquo;s break it down:\nperson is the receiver - the object receiving the message setName is the message name (or selector) \u0026quot;Alice\u0026quot; is the argument to the message The entire expression is a message send But here\u0026rsquo;s where it gets interesting. Messages are objects too:\n// Create a message object msg := message(person setName(\u0026quot;Alice\u0026quot;)) // Inspect it msg name println // setName msg arguments println // list(Message_0x...) msg arguments first code println // \u0026quot;Alice\u0026quot; // Execute it msg doInContext(Lobby) // Actually calls person setName(\u0026quot;Alice\u0026quot;) Slots: The Object\u0026rsquo;s Memory # Slots are named storage locations in objects. They can hold any value:\nobj := Object clone // Create slots with different values obj number := 42 // Number obj text := \u0026quot;hello\u0026quot; // String obj method := method(x, x * 2) // Method obj child := Object clone // Another object obj flag := true // Boolean // List all slots obj slotNames println // list(number, text, method, child, flag) // Check for slots obj hasSlot(\u0026quot;number\u0026quot;) println // true obj hasSlot(\u0026quot;missing\u0026quot;) println // false // Get slot values obj getSlot(\u0026quot;number\u0026quot;) println // 42 obj getSlot(\u0026quot;method\u0026quot;) println // method(x, ...) The Message Resolution Algorithm # When an object receives a message, Io follows a specific algorithm to find the corresponding slot:\nAnimal := Object clone Animal speak := method(\u0026quot;generic sound\u0026quot; println) Dog := Animal clone Dog speak := method(\u0026quot;woof\u0026quot; println) Dog wagTail := method(\u0026quot;wagging...\u0026quot; println) rover := Dog clone rover name := \u0026quot;Rover\u0026quot; // When rover receives 'speak': rover speak // 1. Look for 'speak' in rover - not found // 2. Look for 'speak' in rover's proto (Dog) - found! // 3. Execute Dog's speak method with rover as self // When rover receives 'name': rover name // 1. Look for 'name' in rover - found! // 2. Return the value // Visual representation: /* Object ↑ Animal (speak: \u0026quot;generic sound\u0026quot;) ↑ Dog (speak: \u0026quot;woof\u0026quot;, wagTail) ↑ rover (name: \u0026quot;Rover\u0026quot;) */ Creating and Modifying Slots # Io distinguishes between creating new slots and updating existing ones:\nobj := Object clone // Create a new slot with := obj x := 10 obj hasSlot(\u0026quot;x\u0026quot;) println // true // Update existing slot with = obj x = 20 obj x println // 20 // Trying to update non-existent slot fails obj y = 30 // Exception: Slot y not found // But you can use setSlot to create or update obj setSlot(\u0026quot;y\u0026quot;, 30) // Creates if doesn't exist obj y println // 30 // Remove slots obj removeSlot(\u0026quot;y\u0026quot;) obj hasSlot(\u0026quot;y\u0026quot;) println // false This distinction helps catch typos:\ncounter := 0 countr = 1 // Error! Probably meant 'counter' Methods Are Just Slots # In Io, methods aren\u0026rsquo;t special—they\u0026rsquo;re just slots that hold executable blocks:\nCalculator := Object clone // Method is just a slot containing a method object Calculator add := method(a, b, a + b) // You can manipulate methods like any other value addMethod := Calculator getSlot(\u0026quot;add\u0026quot;) addMethod type println // Block // You can copy methods between objects ScientificCalc := Object clone ScientificCalc addition := Calculator getSlot(\u0026quot;add\u0026quot;) ScientificCalc addition(5, 3) println // 8 // You can even store methods in variables operation := method(x, x * 2) Calculator double := operation Calculator double(21) println // 42 The \u0026lsquo;self\u0026rsquo; and \u0026lsquo;sender\u0026rsquo; Context # Every method has access to special variables:\nPrinter := Object clone Printer name := \u0026quot;HP\u0026quot; Printer print := method(doc, (\u0026quot;Printer: \u0026quot; .. self name) println // self = receiver (\u0026quot;Sender: \u0026quot; .. sender type) println // sender = who sent the message (\u0026quot;Document: \u0026quot; .. doc) println ) Computer := Object clone Computer sendJob := method( Printer print(\u0026quot;report.pdf\u0026quot;) ) Computer sendJob // Printer: HP // Sender: Computer // Document: report.pdf Message Forwarding # When an object doesn\u0026rsquo;t have a slot for a received message, it calls forward:\nProxy := Object clone Proxy target := nil Proxy forward := method( (\u0026quot;Forwarding \u0026quot; .. call message name .. \u0026quot; to target\u0026quot;) println call evalArgAt(0) // This would forward to target ) p := Proxy clone p doSomething(\u0026quot;arg\u0026quot;) // Forwarding doSomething to target This enables powerful patterns like delegation and method missing:\n// Ruby-style method_missing DynamicObject := Object clone DynamicObject forward := method( methodName := call message name if(methodName beginsWithSeq(\u0026quot;get\u0026quot;), # Handle getters property := methodName afterSeq(\u0026quot;get\u0026quot;) lowercase self getSlot(property), # Handle setters if(methodName beginsWithSeq(\u0026quot;set\u0026quot;), property := methodName afterSeq(\u0026quot;set\u0026quot;) lowercase value := call evalArgAt(0) self setSlot(property, value) ) ) ) obj := DynamicObject clone obj setName(\u0026quot;Alice\u0026quot;) // Creates 'name' slot obj getName println // \u0026quot;Alice\u0026quot; Lazy Evaluation with Messages # Messages don\u0026rsquo;t evaluate immediately—they\u0026rsquo;re data structures you can manipulate:\n// Messages as data expr := message(2 + 3 * 4) expr println // 2 +(3 *(4)) // Evaluate when ready result := expr doInContext(Lobby) result println // 14 // Modify messages before evaluation expr := message(x + y) context := Object clone context x := 10 context y := 20 expr doInContext(context) println // 30 This enables macro-like capabilities:\n// Create a timing macro Object time := method( code := call argAt(0) // Get the message, not its value start := Date now result := code doInContext(call sender) elapsed := Date now - start (\u0026quot;Elapsed: \u0026quot; .. elapsed) println result ) // Use it time( sum := 0 for(i, 1, 1000000, sum = sum + i) sum ) // Elapsed: 0.234 // Returns: 500000500000 Call Introspection # The call object provides detailed information about the current method invocation:\nObject debug := method( \u0026quot;=== Call Debug ===\u0026quot; println (\u0026quot;Sender: \u0026quot; .. call sender type) println (\u0026quot;Target: \u0026quot; .. call target type) println (\u0026quot;Message: \u0026quot; .. call message name) println (\u0026quot;Args: \u0026quot; .. call message arguments) println (\u0026quot;Activated: \u0026quot; .. call activated type) println \u0026quot;================\u0026quot; println ) TestObject := Object clone TestObject test := method( debug ) TestObject test // === Call Debug === // Sender: Lobby // Target: TestObject // Message: debug // Args: list() // Activated: Block // ================ Operator Messages # Operators are messages with special precedence rules:\n// These are equivalent 2 + 3 * 4 2 +(3 *(4)) // You can see the precedence OperatorTable println // You can add custom operators OperatorTable addOperator(\u0026quot;@@\u0026quot;, 5) Number @@ := method(n, self pow(n) + n pow(self) ) 2 @@ 3 println // 17 (2^3 + 3^2 = 8 + 9) // Operators are just messages 5 send(\u0026quot;+\u0026quot;, 3) println // 8 \u0026quot;hello\u0026quot; send(\u0026quot;at\u0026quot;, 1) println // e Assignment Messages # Even assignment is message passing:\n// These are equivalent x := 10 setSlot(\u0026quot;x\u0026quot;, 10) // And these x = 20 updateSlot(\u0026quot;x\u0026quot;, 20) // You can override assignment behavior Object setSlot := method(name, value, (\u0026quot;Setting \u0026quot; .. name .. \u0026quot; to \u0026quot; .. value) println resend // Call original setSlot ) y := 42 // Setting y to 42 Method Activation vs. Value Access # Io distinguishes between activatable and non-activatable values:\nobj := Object clone // Methods are activatable - they run when accessed obj greet := method(\u0026quot;Hello!\u0026quot; println) obj greet // Prints \u0026quot;Hello!\u0026quot; // Other values are just returned obj name := \u0026quot;Alice\u0026quot; obj name // Returns \u0026quot;Alice\u0026quot; // You can get a method without activating it m := obj getSlot(\u0026quot;greet\u0026quot;) m println // method(...) // And activate it later m call // Prints \u0026quot;Hello!\u0026quot; // Check if something is activatable obj getSlot(\u0026quot;greet\u0026quot;) isActivatable println // true obj getSlot(\u0026quot;name\u0026quot;) isActivatable println // false Building a Message-Based DSL # Let\u0026rsquo;s build a simple HTML DSL using messages:\nHTML := Object clone HTML forward := method( tagName := call message name args := call message arguments // Build opening tag result := \u0026quot;\u0026lt;\u0026quot; .. tagName // Handle attributes (first arg if it's a Map) if(args size \u0026gt; 0 and args at(0) name == \u0026quot;curlyBrackets\u0026quot;, attrs := call evalArgAt(0) attrs foreach(key, value, result = result .. \u0026quot; \u0026quot; .. key .. \u0026quot;=\\\u0026quot;\u0026quot; .. value .. \u0026quot;\\\u0026quot;\u0026quot; ) args removeFirst ) result = result .. \u0026quot;\u0026gt;\u0026quot; // Handle content args foreach(arg, content := call sender doMessage(arg) if(content, result = result .. content) ) // Closing tag result = result .. \u0026quot;\u0026lt;/\u0026quot; .. tagName .. \u0026quot;\u0026gt;\u0026quot; result ) // Usage html := HTML clone page := html div({ \u0026quot;class\u0026quot;: \u0026quot;container\u0026quot; }, html h1(\u0026quot;Welcome\u0026quot;), html p(\u0026quot;This is a paragraph\u0026quot;), html ul( html li(\u0026quot;Item 1\u0026quot;), html li(\u0026quot;Item 2\u0026quot;) ) ) page println // \u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt;\u0026lt;h1\u0026gt;Welcome\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;This is a paragraph\u0026lt;/p\u0026gt;\u0026lt;ul\u0026gt;\u0026lt;li\u0026gt;Item 1\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Item 2\u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt;\u0026lt;/div\u0026gt; Performance Considerations # Message passing has overhead compared to direct function calls:\n// Traditional method call obj := Object clone obj directMethod := method(x, x * 2) // Message construction and sending msg := Message clone setName(\u0026quot;directMethod\u0026quot;) setArguments(list(Message clone setName(\u0026quot;5\u0026quot;))) // Benchmark time( 100000 times(obj directMethod(5)) ) time( 100000 times(obj doMessage(msg)) ) // Direct calls are faster, but message objects enable metaprogramming Common Patterns # Property Access Pattern # Person := Object clone Person init := method( self name := nil self age := nil self ) // Generate getters/setters with messages Person addAccessors := method(slotName, // Getter self setSlot(slotName, method(self getSlot(\u0026quot;_\u0026quot; .. slotName)) ) // Setter self setSlot(\u0026quot;set\u0026quot; .. slotName asCapitalized, method(value, self setSlot(\u0026quot;_\u0026quot; .. slotName, value)) ) ) Person addAccessors(\u0026quot;name\u0026quot;) Person addAccessors(\u0026quot;age\u0026quot;) p := Person clone p setName(\u0026quot;Alice\u0026quot;) p name println // \u0026quot;Alice\u0026quot; Chain of Responsibility # Handler := Object clone Handler next := nil Handler handle := method(request, if(self canHandle(request), self process(request), if(next, next handle(request)) ) ) AuthHandler := Handler clone AuthHandler canHandle := method(request, request hasSlot(\u0026quot;needsAuth\u0026quot;) ) AuthHandler process := method(request, \u0026quot;Authenticating...\u0026quot; println ) LogHandler := Handler clone LogHandler canHandle := method(request, true) LogHandler process := method(request, (\u0026quot;Logging: \u0026quot; .. request type) println ) // Build chain auth := AuthHandler clone log := LogHandler clone auth next := log // Process requests request := Object clone request type := \u0026quot;GET\u0026quot; request needsAuth := true auth handle(request) // Authenticating... // Logging: GET Debugging Messages # Understanding message flow is crucial for debugging:\nObject trace := method( self setSlot(\u0026quot;forward\u0026quot;, method( (\u0026quot;Missing: \u0026quot; .. call message name) println (\u0026quot;Arguments: \u0026quot; .. call message arguments) println (\u0026quot;Sender: \u0026quot; .. sender type) println ) ) self ) buggy := Object clone trace buggy doSomethingWrong(1, 2, 3) // Missing: doSomethingWrong // Arguments: list(1, 2, 3) // Sender: Lobby Exercises # Message Logger: Create a wrapper that logs all messages sent to an object, including arguments and return values.\nLazy Properties: Implement properties that are only computed when first accessed, then cached.\nMessage Queue: Build an object that queues messages and executes them later in order.\nMethod Decorators: Create a system for wrapping methods with before/after behavior using messages.\nMessage Router: Build a router that directs messages to different handlers based on patterns.\nAdvanced Message Techniques # Message Rewriting # Rewriter := Object clone Rewriter forward := method( msg := call message // Rewrite add to multiply if(msg name == \u0026quot;add\u0026quot;, msg setName(\u0026quot;multiply\u0026quot;) ) // Continue with modified message resend ) calc := Rewriter clone calc multiply := method(a, b, a * b) calc add(3, 4) println // 12 (rewritten to multiply!) Conditional Message Sending # Object sendIf := method(condition, messageName, if(condition, self doMessage(Message clone setName(messageName)) ) ) Object sendUnless := method(condition, messageName, if(condition not, self doMessage(Message clone setName(messageName)) ) ) obj := Object clone obj greet := method(\u0026quot;Hello!\u0026quot; println) obj sendIf(true, \u0026quot;greet\u0026quot;) // Hello! obj sendUnless(false, \u0026quot;greet\u0026quot;) // Hello! Conclusion # Messages and slots form the foundation of Io\u0026rsquo;s object model. Every computation—from simple arithmetic to complex method calls—is accomplished through message passing. Objects store their state and behavior in slots, and respond to messages by looking up the corresponding slots.\nThis uniform model provides incredible flexibility. You can intercept messages, forward them, rewrite them, or queue them. You can introspect the entire message-passing process. You can build DSLs that feel native to the language. And you can debug by tracing the flow of messages through your system.\nUnderstanding messages and slots deeply is essential to mastering Io. They\u0026rsquo;re not just an implementation detail—they\u0026rsquo;re the conceptual core that makes Io\u0026rsquo;s radical simplicity possible.\nNext: Chapter 6 - Cloning and Inheritance\n"},{"id":8,"href":"/docs/06-cloning-and-inheritance/","title":"Cloning and Inheritance","section":"Chapters","content":" Chapter 6: Cloning and Inheritance # In class-based languages, inheritance is a relationship between classes. In Io\u0026rsquo;s prototype-based world, inheritance emerges from the simpler mechanism of cloning. When you clone an object, the new object maintains a link to its prototype, creating an inheritance chain. This chapter explores how cloning works, how inheritance emerges from it, and how to use these mechanisms effectively.\nThe Mechanics of Cloning # When you clone an object in Io, you don\u0026rsquo;t copy all its data. Instead, you create a new, empty object with a reference to the original:\n// Create a prototype Animal := Object clone Animal species := \u0026quot;Unknown\u0026quot; Animal age := 0 Animal describe := method( (\u0026quot;A \u0026quot; .. age .. \u0026quot; year old \u0026quot; .. species) println ) // Clone it cat := Animal clone // cat is empty but linked to Animal cat slotNames println // list() - no local slots! cat species println // \u0026quot;Unknown\u0026quot; - from Animal cat age println // 0 - from Animal // The link is through 'proto' cat proto == Animal println // true This is fundamentally different from copying:\n// If cloning was copying (it's not!), it would work like: catCopy := Object clone catCopy species := Animal species // Copy each slot catCopy age := Animal age catCopy describe := Animal describe // But cloning actually creates a link: catClone := Animal clone // Empty object linked to Animal Differential Inheritance in Action # Objects only store their differences from their prototypes:\nVehicle := Object clone Vehicle speed := 60 Vehicle color := \u0026quot;white\u0026quot; Vehicle drive := method( (\u0026quot;Driving at \u0026quot; .. speed .. \u0026quot; mph\u0026quot;) println ) car := Vehicle clone car color = \u0026quot;red\u0026quot; // Override color car model := \u0026quot;Sedan\u0026quot; // Add new slot // Inspect what's stored where car slotNames println // list(color, model) - only differences! Vehicle slotNames println // list(speed, color, drive) // But car can access everything car speed println // 60 - from Vehicle car color println // \u0026quot;red\u0026quot; - from car (overrides Vehicle) car model println // \u0026quot;Sedan\u0026quot; - from car car drive // \u0026quot;Driving at 60 mph\u0026quot; Memory efficiency comparison:\n// Creating 1000 cars cars := list() 1000 times(i, car := Vehicle clone car id := i cars append(car) ) // Each car only stores its 'id' slot // All share Vehicle's methods and default values // In a copying system, each would duplicate everything The Prototype Chain # Objects can have chains of prototypes:\nOrganism := Object clone Organism alive := true Organism metabolize := method(\u0026quot;Converting energy...\u0026quot; println) Animal := Organism clone Animal mobile := true Animal move := method(\u0026quot;Moving...\u0026quot; println) Mammal := Animal clone Mammal warmBlooded := true Mammal nurse := method(\u0026quot;Nursing young...\u0026quot; println) Dog := Mammal clone Dog loyal := true Dog bark := method(\u0026quot;Woof!\u0026quot; println) fido := Dog clone fido name := \u0026quot;Fido\u0026quot; // fido can access methods from the entire chain fido metabolize // From Organism fido move // From Animal fido nurse // From Mammal fido bark // From Dog // Trace the chain obj := fido while(obj != Object, obj type println obj = obj proto ) // Dog // Mammal // Animal // Organism // Object Method Resolution Order # When you send a message, Io searches up the prototype chain:\nA := Object clone A foo := method(\u0026quot;A's foo\u0026quot; println) A bar := method(\u0026quot;A's bar\u0026quot; println) B := A clone B foo := method(\u0026quot;B's foo\u0026quot; println) // Override C := B clone C bar := method(\u0026quot;C's bar\u0026quot; println) // Override different method obj := C clone obj foo // \u0026quot;B's foo\u0026quot; - found in B (C doesn't have it) obj bar // \u0026quot;C's bar\u0026quot; - found in C obj baz // Exception - not found anywhere You can visualize the search:\nObject findSlot := method(slotName, obj := self while(obj, if(obj hasLocalSlot(slotName), (\u0026quot;Found '\u0026quot; .. slotName .. \u0026quot;' in \u0026quot; .. obj type) println return obj getSlot(slotName) ) obj = obj proto ) \u0026quot;Not found\u0026quot; println ) obj findSlot(\u0026quot;foo\u0026quot;) // Found 'foo' in B obj findSlot(\u0026quot;bar\u0026quot;) // Found 'bar' in C Multiple Inheritance # Io supports multiple inheritance through the protos list:\n// Define capabilities Flyable := Object clone Flyable altitude := 0 Flyable fly := method(height, altitude = height (\u0026quot;Flying at \u0026quot; .. altitude .. \u0026quot; feet\u0026quot;) println ) Swimmable := Object clone Swimmable depth := 0 Swimmable swim := method(d, depth = d (\u0026quot;Swimming at \u0026quot; .. depth .. \u0026quot; feet deep\u0026quot;) println ) // Single inheritance Bird := Flyable clone Bird chirp := method(\u0026quot;Chirp!\u0026quot; println) // Multiple inheritance Duck := Object clone Duck appendProto(Flyable) Duck appendProto(Swimmable) Duck quack := method(\u0026quot;Quack!\u0026quot; println) mallard := Duck clone mallard fly(100) // Flying at 100 feet mallard swim(5) // Swimming at 5 feet deep mallard quack // Quack! // Check the prototype list Duck protos println // list(Object_0x..., Flyable_0x..., Swimmable_0x...) Diamond Problem Resolution # The diamond problem occurs when multiple inheritance paths lead to the same ancestor:\n// Diamond structure Grandparent := Object clone Grandparent value := \u0026quot;from grandparent\u0026quot; Grandparent method1 := method(\u0026quot;Grandparent method1\u0026quot; println) Parent1 := Grandparent clone Parent1 method1 := method(\u0026quot;Parent1 method1\u0026quot; println) Parent1 method2 := method(\u0026quot;Parent1 method2\u0026quot; println) Parent2 := Grandparent clone Parent2 method1 := method(\u0026quot;Parent2 method1\u0026quot; println) Parent2 method3 := method(\u0026quot;Parent2 method3\u0026quot; println) Child := Object clone Child appendProto(Parent1) Child appendProto(Parent2) // Resolution order matters Child method1 // \u0026quot;Parent1 method1\u0026quot; - Parent1 comes first // Reorder to change priority Child protos := list(Parent2, Parent1) Child method1 // \u0026quot;Parent2 method1\u0026quot; - Parent2 now comes first Shallow vs Deep Cloning # By default, cloning is shallow—slot values are shared:\nOriginal := Object clone Original data := list(1, 2, 3) Original info := Map clone atPut(\u0026quot;key\u0026quot;, \u0026quot;value\u0026quot;) Shallow := Original clone // Modifying mutable objects affects both Shallow data append(4) Original data println // list(1, 2, 3, 4) - changed! // Need deep cloning for independence Object deepClone := method( new := self clone self slotNames foreach(name, value := self getSlot(name) if(value hasSlot(\u0026quot;clone\u0026quot;), new setSlot(name, value clone) ) ) new ) Deep := Original deepClone Deep data append(5) Original data println // list(1, 2, 3, 4) - unchanged Deep data println // list(1, 2, 3, 4, 5) init Methods and Constructors # While Io doesn\u0026rsquo;t have constructors, you can create initialization patterns:\nPerson := Object clone Person init := method( self name := \u0026quot;Unknown\u0026quot; self age := 0 self contacts := list() // Important: new list for each instance self // Return self for chaining ) // Override clone to call init Person clone := method( resend init ) // Now each person gets their own contacts list alice := Person clone alice name = \u0026quot;Alice\u0026quot; alice contacts append(\u0026quot;Bob\u0026quot;) bob := Person clone bob name = \u0026quot;Bob\u0026quot; bob contacts append(\u0026quot;Charlie\u0026quot;) alice contacts println // list(\u0026quot;Bob\u0026quot;) - independent! bob contacts println // list(\u0026quot;Charlie\u0026quot;) Factory Methods # Create specialized cloning methods:\nAnimal := Object clone Animal species := \u0026quot;Unknown\u0026quot; Animal sound := \u0026quot;...\u0026quot; Animal withSpecies := method(s, new := self clone new species = s new ) Animal dog := method( self clone species = \u0026quot;Dog\u0026quot; sound = \u0026quot;Woof\u0026quot; ) Animal cat := method( self clone species = \u0026quot;Cat\u0026quot; sound = \u0026quot;Meow\u0026quot; ) // Usage myDog := Animal dog myCat := Animal cat genericAnimal := Animal withSpecies(\u0026quot;Elephant\u0026quot;) Prototype Switching # Unlike class-based languages, you can change an object\u0026rsquo;s prototype at runtime:\n// Start with one prototype Bird := Object clone Bird fly := method(\u0026quot;Flying...\u0026quot; println) Fish := Object clone Fish swim := method(\u0026quot;Swimming...\u0026quot; println) creature := Bird clone creature fly // \u0026quot;Flying...\u0026quot; // Change its prototype! creature protos = list(Fish) creature swim // \u0026quot;Swimming...\u0026quot; creature fly // Exception - no longer a Bird! // Or add capabilities creature appendProto(Bird) creature fly // \u0026quot;Flying...\u0026quot; - now it can do both creature swim // \u0026quot;Swimming...\u0026quot; Mixins and Traits # Use prototypes as mixins for composable behavior:\n// Define mixins Comparable := Object clone Comparable \u0026lt; := method(other, self compare(other) \u0026lt; 0) Comparable \u0026gt; := method(other, self compare(other) \u0026gt; 0) Comparable == := method(other, self compare(other) == 0) Comparable \u0026lt;= := method(other, self compare(other) \u0026lt;= 0) Comparable \u0026gt;= := method(other, self compare(other) \u0026gt;= 0) Enumerable := Object clone Enumerable select := method(block, result := list() self foreach(item, if(block call(item), result append(item)) ) result ) Enumerable map := method(block, result := list() self foreach(item, result append(block call(item)) ) result ) // Use mixins SortedList := List clone SortedList appendProto(Comparable) SortedList appendProto(Enumerable) SortedList compare := method(other, self size compare(other size) ) list1 := SortedList clone append(1, 2, 3) list2 := SortedList clone append(4, 5) (list1 \u0026gt; list2) println // true (3 \u0026gt; 2) Clone Hooks # Customize cloning behavior:\nCounted := Object clone Counted instances := 0 Counted clone := method( Counted instances = Counted instances + 1 new := resend new id := Counted instances new ) // Each clone gets a unique ID obj1 := Counted clone obj2 := Counted clone obj3 := Counted clone obj1 id println // 1 obj2 id println // 2 obj3 id println // 3 Counted instances println // 3 Inheritance Patterns # Classical Inheritance Pattern # Emulate class-based inheritance:\n// Base \u0026quot;class\u0026quot; Class := Object clone Class new := method( instance := self clone instance init instance ) // Define a \u0026quot;class\u0026quot; Rectangle := Class clone Rectangle init := method( self width := 0 self height := 0 ) Rectangle area := method(width * height) // Inheritance Square := Rectangle clone Square init := method( resend // Call parent init self side := 0 ) Square setSide := method(s, side = s width = s height = s ) // Usage rect := Rectangle new rect width = 10 rect height = 20 rect area println // 200 square := Square new square setSide(5) square area println // 25 Delegation Pattern # Delegator := Object clone Delegator delegate := nil Delegator forward := method( if(delegate, delegate doMessage(call message, call sender) , Exception raise(\u0026quot;No delegate set\u0026quot;) ) ) Logger := Object clone Logger log := method(msg, (\u0026quot;[LOG] \u0026quot; .. msg) println) obj := Delegator clone obj delegate = Logger obj log(\u0026quot;Hello\u0026quot;) // [LOG] Hello Testing Inheritance # Check inheritance relationships:\nObject isKindOf := method(proto, obj := self while(obj, if(obj == proto, return true) if(obj protos, obj protos foreach(p, if(p isKindOf(proto), return true) ) ) obj = obj proto ) false ) Animal := Object clone Dog := Animal clone fido := Dog clone fido isKindOf(Dog) println // true fido isKindOf(Animal) println // true fido isKindOf(Object) println // true fido isKindOf(Number) println // false Performance Considerations # Prototype chains affect performance:\n// Deep chain - slower lookup A := Object clone B := A clone C := B clone D := C clone E := D clone obj := E clone obj method := method(\u0026quot;Found!\u0026quot;) // Shallow chain - faster lookup Flat := Object clone Flat method := method(\u0026quot;Found!\u0026quot;) obj2 := Flat clone // Benchmark time(100000 times(obj method)) // Slower time(100000 times(obj2 method)) // Faster Common Pitfalls # Shared Mutable State # // WRONG - shares list between instances BadTemplate := Object clone BadTemplate items := list() obj1 := BadTemplate clone obj2 := BadTemplate clone obj1 items append(1) obj2 items println // list(1) - Oops! Shared! // RIGHT - create new list for each instance GoodTemplate := Object clone GoodTemplate init := method( self items := list() self ) GoodTemplate clone := method(resend init) Circular Prototypes # // Don't do this! A := Object clone B := Object clone A appendProto(B) B appendProto(A) // Circular! // A foo // Infinite loop! Exercises # Instance Counter: Create a prototype that tracks how many objects have been cloned from it, directly or indirectly.\nPrototype Inspector: Write a method that visualizes an object\u0026rsquo;s complete prototype hierarchy as a tree.\nDeep Clone: Implement a robust deep cloning method that handles circular references.\nMultiple Inheritance Resolver: Create a system that detects and reports conflicts in multiple inheritance.\nClass Emulator: Build a complete class-based OOP system on top of Io\u0026rsquo;s prototypes, including abstract classes and interfaces.\nReal-World Example: Game Entity System # // Base entity Entity := Object clone Entity init := method( self x := 0 self y := 0 self health := 100 self ) Entity clone := method(resend init) Entity takeDamage := method(amount, health = health - amount if(health \u0026lt;= 0, self die) ) Entity die := method(\u0026quot;Entity died\u0026quot; println) // Moveable capability Moveable := Object clone Moveable speed := 1 Moveable moveTo := method(newX, newY, x = newX y = newY ) // Attacker capability Attacker := Object clone Attacker damage := 10 Attacker attack := method(target, target takeDamage(damage) ) // Compose entities Player := Entity clone Player appendProto(Moveable) Player appendProto(Attacker) Player speed = 5 Player damage = 20 Enemy := Entity clone Enemy appendProto(Moveable) Enemy appendProto(Attacker) Enemy speed = 3 Enemy damage = 15 // Static entity Turret := Entity clone Turret appendProto(Attacker) Turret damage = 25 // Usage player := Player clone enemy := Enemy clone turret := Turret clone player moveTo(10, 10) player attack(enemy) turret attack(player) Conclusion # Cloning and inheritance in Io demonstrate how complex behavior can emerge from simple mechanisms. Instead of classes, instances, and inheritance hierarchies defined at compile time, you have objects cloning objects, maintaining prototype links, and delegating message handling up the chain.\nThis flexibility enables patterns impossible in class-based languages: changing inheritance at runtime, mixing in capabilities dynamically, and treating \u0026ldquo;classes\u0026rdquo; as first-class objects that can be modified like any other. The trade-off is that you must be more careful about shared state and initialization, but the power and expressiveness gained often make it worthwhile.\nUnderstanding cloning and inheritance deeply is essential for effective Io programming. These mechanisms aren\u0026rsquo;t just how you create objects—they\u0026rsquo;re how you structure entire programs.\nNext: Chapter 7 - Control Flow\n"},{"id":9,"href":"/docs/07-control-flow/","title":"Control Flow","section":"Chapters","content":" Chapter 7: Control Flow # In most programming languages, control flow structures like if, while, and for are built-in syntax with special rules. In Io, they\u0026rsquo;re just methods that receive messages. This chapter explores how Io\u0026rsquo;s message-passing philosophy extends to control flow, and how you can create your own control structures.\nEverything Is a Message # Let\u0026rsquo;s start with a simple comparison. In C or Java:\nif (x \u0026gt; 5) { printf(\u0026quot;Big\\n\u0026quot;); } else { printf(\u0026quot;Small\\n\u0026quot;); } This is special syntax that the compiler understands. But in Io:\nif(x \u0026gt; 5, \u0026quot;Big\u0026quot; println, \u0026quot;Small\u0026quot; println ) The if is just a method call! You can even see its implementation:\nif println // method(...) // You could redefine it (don't actually do this!) Object if := method(condition, trueBlock, falseBlock, \u0026quot;Making a decision!\u0026quot; println resend // Call original if ) The if Method # The if method takes two or three arguments:\n// Two arguments: if-then if(temperature \u0026gt; 30, \u0026quot;It's hot!\u0026quot; println ) // Three arguments: if-then-else if(temperature \u0026gt; 30, \u0026quot;It's hot!\u0026quot; println, \u0026quot;It's nice!\u0026quot; println ) // if returns the value of the executed block result := if(5 \u0026gt; 3, \u0026quot;yes\u0026quot;, \u0026quot;no\u0026quot;) result println // \u0026quot;yes\u0026quot; // Nested if category := if(score \u0026gt; 90, \u0026quot;A\u0026quot;, if(score \u0026gt; 80, \u0026quot;B\u0026quot;, if(score \u0026gt; 70, \u0026quot;C\u0026quot;, \u0026quot;F\u0026quot;) ) ) Understanding Blocks # The key to Io\u0026rsquo;s control flow is that code blocks are objects that aren\u0026rsquo;t evaluated immediately:\n// This prints immediately \u0026quot;Hello\u0026quot; println // This creates a block object but doesn't execute it block := method(\u0026quot;Hello\u0026quot; println) // Execute it later block call // Now it prints \u0026quot;Hello\u0026quot; // Blocks in if if(true, \u0026quot;This is a block\u0026quot; println // Not executed until if decides to ) This lazy evaluation is crucial. If both branches of an if were evaluated immediately, both would execute!\n// In a hypothetical eager language: eagerIf := method(condition, trueValue, falseValue, if(condition, trueValue, falseValue) ) x := 5 eagerIf(x \u0026gt; 3, \u0026quot;Greater\u0026quot; println, // This executes immediately \u0026quot;Lesser\u0026quot; println // This also executes immediately! ) // Would print both! // But Io's if receives unevaluated blocks if(x \u0026gt; 3, \u0026quot;Greater\u0026quot; println, // Only this executes \u0026quot;Lesser\u0026quot; println // This never executes ) The while Loop # The while method repeatedly evaluates its condition and body:\ni := 0 while(i \u0026lt; 5, i println i = i + 1 ) // Prints 0, 1, 2, 3, 4 // while returns nil by default result := while(false, \u0026quot;Never runs\u0026quot;) result println // nil // Infinite loops while(true, input := File standardInput readLine if(input == \u0026quot;quit\u0026quot;, break) (\u0026quot;You said: \u0026quot; .. input) println ) The for Loop # The for method provides a counting loop:\n// Basic for loop for(i, 1, 5, i println ) // Prints 1, 2, 3, 4, 5 // With step for(i, 0, 10, 2, i println ) // Prints 0, 2, 4, 6, 8, 10 // Backward for(i, 5, 1, i println ) // Prints 5, 4, 3, 2, 1 // for can return values sum := 0 for(i, 1, 100, sum = sum + i ) sum println // 5050 The loop Method # Io provides a loop method for infinite loops:\ncount := 0 loop( count = count + 1 if(count \u0026gt; 10, break) count println ) // Equivalent to while(true, ...) break and continue # These work like in other languages, but they\u0026rsquo;re methods too:\n// break exits the loop for(i, 1, 10, if(i == 5, break) i println ) // Prints 1, 2, 3, 4 // continue skips to next iteration for(i, 1, 10, if(i % 2 == 0, continue) i println ) // Prints 1, 3, 5, 7, 9 // break can return a value result := for(i, 1, 100, if(i * i \u0026gt; 50, break(i)) ) result println // 8 (first i where i*i \u0026gt; 50) The repeat Method # A simpler counting mechanism:\n5 repeat(\u0026quot;Hello\u0026quot; println) // Prints \u0026quot;Hello\u0026quot; 5 times // repeat with index 5 repeat(i, (\u0026quot;Count: \u0026quot; .. i) println ) // Count: 0 // Count: 1 // Count: 2 // Count: 3 // Count: 4 Creating Custom Control Structures # Since control structures are just methods, you can create your own:\n// unless: opposite of if Object unless := method(condition, falseBlock, if(condition not, falseBlock call) ) unless(5 \u0026gt; 10, \u0026quot;5 is not greater than 10\u0026quot; println ) // until: opposite of while Object until := method(condition, body, while(condition not, body) ) x := 0 until(x \u0026gt; 5, x println x = x + 1 ) // times: repeat n times with cleaner syntax Number times := method(body, for(i, 1, self, body) ) 3 times(\u0026quot;Hello\u0026quot; println) The elseif Pattern # Io uses elseif for chained conditionals:\nscore := 85 if(score \u0026gt;= 90) then( \u0026quot;A\u0026quot; println ) elseif(score \u0026gt;= 80) then( \u0026quot;B\u0026quot; println ) elseif(score \u0026gt;= 70) then( \u0026quot;C\u0026quot; println ) else( \u0026quot;F\u0026quot; println ) // Prints \u0026quot;B\u0026quot; // This is actually a chain of methods // if returns a special object when false // that object has elseif and else methods Switch-like Behavior # Io doesn\u0026rsquo;t have a switch statement, but you can build one:\nObject switch := method(value, self switchValue := value self ) Object case := method(testValue, action, if(switchValue == testValue, action call self switchMatched := true ) self ) Object default := method(action, if(hasSlot(\u0026quot;switchMatched\u0026quot;) not, action call ) self ) // Usage day := \u0026quot;Tuesday\u0026quot; switch(day) case(\u0026quot;Monday\u0026quot;, \u0026quot;Start of the week\u0026quot; println ) case(\u0026quot;Tuesday\u0026quot;, \u0026quot;Second day\u0026quot; println ) case(\u0026quot;Friday\u0026quot;, \u0026quot;TGIF!\u0026quot; println ) default( \u0026quot;Regular day\u0026quot; println ) // Prints \u0026quot;Second day\u0026quot; Pattern Matching # Build more sophisticated matching:\nObject match := method( self matchValue := call evalArgAt(0) self matchContext := call sender self ) Object when := method(pattern, action, if(hasSlot(\u0026quot;matchFound\u0026quot;) not, matched := false // Check different pattern types if(pattern type == \u0026quot;Block\u0026quot;, matched = pattern call(matchValue), matched = (pattern == matchValue) ) if(matched, self matchResult := action call(matchValue) self matchFound := true ) ) self ) Object otherwise := method(action, if(hasSlot(\u0026quot;matchFound\u0026quot;) not, self matchResult := action call(matchValue) ) matchResult ) // Usage result := match(x) when( block(v, v \u0026lt; 0), method(v, \u0026quot;negative\u0026quot;) ) when( 0, method(v, \u0026quot;zero\u0026quot;) ) when( block(v, v \u0026gt; 0), method(v, \u0026quot;positive\u0026quot;) ) otherwise( method(v, \u0026quot;unknown\u0026quot;) ) Iterating Over Collections # Collections have their own iteration methods:\n// List iteration list(1, 2, 3) foreach(item, item println ) // With index list(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;) foreach(i, item, (i .. \u0026quot;: \u0026quot; .. item) println ) // 0: a // 1: b // 2: c // Map iteration map := Map clone map atPut(\u0026quot;name\u0026quot;, \u0026quot;Alice\u0026quot;) map atPut(\u0026quot;age\u0026quot;, 30) map foreach(key, value, (key .. \u0026quot; = \u0026quot; .. value) println ) // name = Alice // age = 30 Functional Control Flow # Io supports functional programming patterns:\n// map: transform each element squares := list(1, 2, 3, 4) map(x, x * x) squares println // list(1, 4, 9, 16) // select: filter elements evens := list(1, 2, 3, 4, 5, 6) select(x, x % 2 == 0) evens println // list(2, 4, 6) // detect: find first matching element first_big := list(1, 3, 5, 7, 9) detect(x, x \u0026gt; 5) first_big println // 7 // reduce: aggregate elements sum := list(1, 2, 3, 4, 5) reduce(+) sum println // 15 product := list(1, 2, 3, 4) reduce(a, b, a * b) product println // 24 Lazy Evaluation Control # Create control structures with lazy evaluation:\nObject lazyIf := method( condition := call argAt(0) trueBlock := call argAt(1) falseBlock := call argAt(2) if(condition doInContext(call sender), trueBlock doInContext(call sender), if(falseBlock, falseBlock doInContext(call sender) ) ) ) // Both condition and blocks are lazy x := 5 lazyIf(x \u0026gt; 3 and computeExpensive(), \u0026quot;True branch\u0026quot; println, \u0026quot;False branch\u0026quot; println ) Exception Handling as Control Flow # Io\u0026rsquo;s try is also a control flow method:\ntry( // Code that might fail riskyOperation() ) catch(Exception, \u0026quot;An error occurred\u0026quot; println ) // try-catch-finally pattern result := try( file := File with(\u0026quot;data.txt\u0026quot;) openForReading file contents ) catch(Exception, e, (\u0026quot;Error: \u0026quot; .. e message) println nil ) finally( if(file, file close) ) Performance Considerations # Since control structures are methods, they have overhead:\n// Method-based loop (slower) i := 0 while(i \u0026lt; 1000000, i = i + 1 ) // But you can't really avoid it in Io // The language is optimized for expressiveness over speed Advanced: Coroutine-based Control # Io\u0026rsquo;s coroutines enable advanced control flow:\n// Generator pattern Generator := Object clone Generator init := method( self coro := Coroutine currentCoroutine self ) Generator yield := method(value, coro pause(value) ) Generator fibonacci := method( a := 0 b := 1 loop( yield(a) temp := a + b a = b b = temp ) ) // Usage gen := Generator clone fib := gen @fibonacci // @ runs in new coroutine 10 repeat( fib resume println ) // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 Common Patterns # Early Return Pattern # Object findFirst := method(list, condition, list foreach(item, if(condition call(item), return item ) ) nil ) result := findFirst(list(1, 2, 3, 4, 5), block(x, x \u0026gt; 3) ) result println // 4 Guard Clause Pattern # processData := method(data, if(data isNil, return \u0026quot;No data\u0026quot;) if(data size == 0, return \u0026quot;Empty data\u0026quot;) if(data size \u0026gt; 1000, return \u0026quot;Too much data\u0026quot;) // Process data \u0026quot;Processed\u0026quot; return ) Loop with State # Object loopWithState := method(initial, condition, update, body, state := initial while(condition call(state), body call(state) state = update call(state) ) state ) // Sum squares until sum \u0026gt; 100 result := loopWithState( list(0, 1), // [sum, n] block(state, state at(0) \u0026lt;= 100), block(state, list(state at(0) + state at(1) squared, state at(1) + 1)), block(state, (\u0026quot;n=\u0026quot; .. state at(1) .. \u0026quot; sum=\u0026quot; .. state at(0)) println) ) Debugging Control Flow # Object trace := method(label, (label .. \u0026quot; - evaluating\u0026quot;) println self ) Object debugIf := method(condition, trueBlock, falseBlock, \u0026quot;Evaluating condition...\u0026quot; println result := condition (\u0026quot;Condition is: \u0026quot; .. result) println if(result, \u0026quot;Taking true branch\u0026quot; println trueBlock, \u0026quot;Taking false branch\u0026quot; println falseBlock ) ) x := 5 debugIf(x trace(\u0026quot;x\u0026quot;) \u0026gt; trace(\u0026quot;3\u0026quot;) 3, \u0026quot;Greater\u0026quot; println, \u0026quot;Lesser\u0026quot; println ) Exercises # do-while Loop: Implement a doWhile method that executes the body at least once.\nfor-each with Break: Create a forEachBreakable that allows breaking with a return value.\nRetry Logic: Build a retry control structure that retries an operation n times on failure.\nParallel If: Create a parallelIf that evaluates both branches concurrently and returns the first to complete.\nState Machine: Implement a state machine DSL using custom control structures.\nReal-World Example: Retry with Backoff # Object retryWithBackoff := method(maxAttempts, baseDelay, operation, attempt := 1 lastError := nil while(attempt \u0026lt;= maxAttempts, try( return operation call(attempt) ) catch(Exception, e, lastError = e if(attempt \u0026lt; maxAttempts, delay := baseDelay * (2 pow(attempt - 1)) (\u0026quot;Attempt \u0026quot; .. attempt .. \u0026quot; failed, waiting \u0026quot; .. delay .. \u0026quot;ms\u0026quot;) println System sleep(delay / 1000) ) ) attempt = attempt + 1 ) Exception raise(\u0026quot;Failed after \u0026quot; .. maxAttempts .. \u0026quot; attempts: \u0026quot; .. lastError message) ) // Usage result := retryWithBackoff(3, 100, block(attempt, (\u0026quot;Trying attempt \u0026quot; .. attempt) println if(Random value \u0026lt; 0.7, Exception raise(\u0026quot;Random failure\u0026quot;), \u0026quot;Success!\u0026quot; ) ) ) Conclusion # Io\u0026rsquo;s approach to control flow—implementing everything as methods rather than special syntax—is both radical and elegant. It demonstrates the power of Io\u0026rsquo;s uniform message-passing model: when everything is a message, even fundamental programming constructs become malleable and extensible.\nThis flexibility allows you to:\nCreate domain-specific control structures Implement new programming paradigms Debug and trace control flow Understand exactly how your program executes The cost is performance and perhaps initial unfamiliarity. But the benefit is a deep understanding of control flow and the ability to shape the language to your needs rather than being constrained by built-in constructs.\nNext: Chapter 8 - Collections\n"},{"id":10,"href":"/docs/08-collections/","title":"Collections","section":"Chapters","content":" Chapter 8: Collections # Collections are fundamental to any programming language. Io provides three main collection types: List (ordered, indexed), Map (key-value pairs), and Sequence (strings). This chapter explores these collections, their methods, and how to create custom collection types.\nLists: Ordered Collections # Lists in Io are dynamic arrays that can hold any type of object:\n// Creating lists empty := list() numbers := list(1, 2, 3, 4, 5) mixed := list(\u0026quot;hello\u0026quot;, 42, true, Object clone) // Lists are objects numbers type println // List // Basic operations numbers size println // 5 numbers isEmpty println // false numbers first println // 1 numbers last println // 5 numbers at(2) println // 3 (zero-indexed) List Manipulation # fruits := list(\u0026quot;apple\u0026quot;, \u0026quot;banana\u0026quot;) // Adding elements fruits append(\u0026quot;orange\u0026quot;) fruits prepend(\u0026quot;grape\u0026quot;) fruits println // list(grape, apple, banana, orange) // Insert at position fruits atInsert(2, \u0026quot;mango\u0026quot;) fruits println // list(grape, apple, mango, banana, orange) // Removing elements fruits remove(\u0026quot;mango\u0026quot;) fruits removeAt(0) fruits pop // Removes and returns last element fruits println // list(apple, banana) // Multiple operations fruits appendSeq(list(\u0026quot;kiwi\u0026quot;, \u0026quot;peach\u0026quot;)) fruits println // list(apple, banana, kiwi, peach) List Iteration # numbers := list(1, 2, 3, 4, 5) // Basic iteration numbers foreach(n, n println ) // With index numbers foreach(i, n, (i .. \u0026quot;: \u0026quot; .. n) println ) // Reverse iteration numbers reverseForEach(n, n println ) Functional Operations # numbers := list(1, 2, 3, 4, 5) // Map: transform each element squared := numbers map(x, x * x) squared println // list(1, 4, 9, 16, 25) // Select: filter elements evens := numbers select(x, x % 2 == 0) evens println // list(2, 4) // Reject: inverse of select odds := numbers reject(x, x % 2 == 0) odds println // list(1, 3, 5) // Detect: find first match firstEven := numbers detect(x, x % 2 == 0) firstEven println // 2 // Reduce: aggregate sum := numbers reduce(+) sum println // 15 // Custom reduce product := numbers reduce(a, b, a * b) product println // 120 // Any/all predicates numbers contains(3) println // true numbers containsAll(list(2, 4)) println // true numbers containsAny(list(10, 3)) println // true List Slicing and Manipulation # letters := list(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;d\u0026quot;, \u0026quot;e\u0026quot;) // Slicing letters slice(1, 3) println // list(b, c, d) letters slice(2) println // list(c, d, e) // Copying copy := letters copy copy atPut(0, \u0026quot;z\u0026quot;) letters println // list(a, b, c, d, e) - unchanged copy println // list(z, b, c, d, e) // Sorting numbers := list(3, 1, 4, 1, 5, 9) numbers sort println // list(1, 1, 3, 4, 5, 9) // Custom sort people := list( Object clone do(name := \u0026quot;Alice\u0026quot;; age := 30), Object clone do(name := \u0026quot;Bob\u0026quot;; age := 25), Object clone do(name := \u0026quot;Charlie\u0026quot;; age := 35) ) people sortBy(block(p, p age)) foreach(p, (p name .. \u0026quot;: \u0026quot; .. p age) println ) // Bob: 25 // Alice: 30 // Charlie: 35 Maps: Key-Value Stores # Maps (also called dictionaries or hash tables) store key-value pairs:\n// Creating maps empty := Map clone person := Map clone atPut(\u0026quot;name\u0026quot;, \u0026quot;Alice\u0026quot;) atPut(\u0026quot;age\u0026quot;, 30) // Alternative creation person := Map with( \u0026quot;name\u0026quot;, \u0026quot;Alice\u0026quot;, \u0026quot;age\u0026quot;, 30, \u0026quot;city\u0026quot;, \u0026quot;New York\u0026quot; ) // Accessing values person at(\u0026quot;name\u0026quot;) println // Alice person at(\u0026quot;missing\u0026quot;) println // nil person at(\u0026quot;missing\u0026quot;, \u0026quot;default\u0026quot;) println // default // Setting values person atPut(\u0026quot;age\u0026quot;, 31) person atPut(\u0026quot;email\u0026quot;, \u0026quot;alice@example.com\u0026quot;) // Checking keys person hasKey(\u0026quot;name\u0026quot;) println // true person hasKey(\u0026quot;phone\u0026quot;) println // false Map Operations # map := Map with(\u0026quot;a\u0026quot;, 1, \u0026quot;b\u0026quot;, 2, \u0026quot;c\u0026quot;, 3) // Get all keys and values map keys println // list(a, b, c) map values println // list(1, 2, 3) // Size and emptiness map size println // 3 map isEmpty println // false // Removing entries map removeAt(\u0026quot;b\u0026quot;) map println // Map_0x...: a=1, c=3 // Iteration map foreach(key, value, (key .. \u0026quot; =\u0026gt; \u0026quot; .. value) println ) // Merging maps other := Map with(\u0026quot;c\u0026quot;, 30, \u0026quot;d\u0026quot;, 4) map merge(other) map println // a=1, c=30, d=4 (note c was overwritten) Maps as Objects # Maps can act like objects with dynamic properties:\n// Create object-like map obj := Map clone obj atPut(\u0026quot;greet\u0026quot;, method(name, (\u0026quot;Hello, \u0026quot; .. name .. \u0026quot;!\u0026quot;) println )) obj atPut(\u0026quot;x\u0026quot;, 10) obj atPut(\u0026quot;y\u0026quot;, 20) // Use like object (sort of) obj at(\u0026quot;greet\u0026quot;) call(\u0026quot;World\u0026quot;) // Hello, World! obj at(\u0026quot;x\u0026quot;) println // 10 Sequences: String Handling # Sequences are Io\u0026rsquo;s strings, but they\u0026rsquo;re mutable and act like byte arrays:\ntext := \u0026quot;Hello, World!\u0026quot; // Basic operations text size println // 13 text at(0) println // 72 (ASCII 'H') text at(0) asCharacter println // H // Slicing text slice(0, 5) println // Hello text slice(7) println // World! // Searching text findSeq(\u0026quot;World\u0026quot;) println // 7 (index) text containsSeq(\u0026quot;Hello\u0026quot;) println // true text beginsWithSeq(\u0026quot;Hello\u0026quot;) println // true text endsWithSeq(\u0026quot;!\u0026quot;) println // true String Manipulation # text := \u0026quot; Hello, World! \u0026quot; // Trimming text strip println // \u0026quot;Hello, World!\u0026quot; text lstrip println // \u0026quot;Hello, World! \u0026quot; text rstrip println // \u0026quot; Hello, World!\u0026quot; // Case conversion \u0026quot;hello\u0026quot; upper println // HELLO \u0026quot;WORLD\u0026quot; lower println // world \u0026quot;hello world\u0026quot; asCapitalized println // Hello world // Replacement \u0026quot;hello world\u0026quot; replaceSeq(\u0026quot;world\u0026quot;, \u0026quot;Io\u0026quot;) println // hello Io \u0026quot;abcabc\u0026quot; replaceFirstSeq(\u0026quot;a\u0026quot;, \u0026quot;X\u0026quot;) println // Xbcabc // Splitting and joining words := \u0026quot;apple,banana,orange\u0026quot; split(\u0026quot;,\u0026quot;) words println // list(apple, banana, orange) words join(\u0026quot;-\u0026quot;) println // apple-banana-orange String Building # // Inefficient string concatenation result := \u0026quot;\u0026quot; for(i, 1, 1000, result = result .. i .. \u0026quot;, \u0026quot; ) // Better: use a list parts := list() for(i, 1, 1000, parts append(i) ) result := parts join(\u0026quot;, \u0026quot;) // Or use Sequence's mutable nature seq := Sequence clone for(i, 1, 100, seq appendSeq(i asString) appendSeq(\u0026quot;, \u0026quot;) ) Regular Expressions # Io has built-in regex support:\ntext := \u0026quot;The year 2024 has 365 days\u0026quot; // Find matches text findRegex(\u0026quot;\\\\d+\u0026quot;) println // MatchResult... text allMatchesOfRegex(\u0026quot;\\\\d+\u0026quot;) foreach(match, match println // 2024, 365 ) // Replace with regex text replaceAllRegex(\u0026quot;\\\\d+\u0026quot;, \u0026quot;N\u0026quot;) println // The year N has N days // Capture groups email := \u0026quot;user@example.com\u0026quot; match := email matchesOfRegex(\u0026quot;(\\\\w+)@(\\\\w+\\\\.\\\\w+)\u0026quot;) if(match, match at(1) println // user match at(2) println // example.com ) Creating Custom Collections # Stack Implementation # Stack := List clone Stack push := method(item, self append(item) ) Stack pop := method( if(size \u0026gt; 0, removeAt(size - 1), nil ) ) Stack peek := method( if(size \u0026gt; 0, at(size - 1), nil ) ) // Usage stack := Stack clone stack push(1) push(2) push(3) stack pop println // 3 stack peek println // 2 stack pop println // 2 stack pop println // 1 Queue Implementation # Queue := Object clone Queue init := method( self items := list() self ) Queue enqueue := method(item, items append(item) self ) Queue dequeue := method( if(items size \u0026gt; 0, items removeAt(0), nil ) ) Queue isEmpty := method(items isEmpty) Queue size := method(items size) // Usage queue := Queue clone init queue enqueue(\u0026quot;a\u0026quot;) enqueue(\u0026quot;b\u0026quot;) enqueue(\u0026quot;c\u0026quot;) queue dequeue println // a queue dequeue println // b queue size println // 1 Set Implementation # Set := Object clone Set init := method( self items := Map clone self ) Set add := method(item, items atPut(item asString, item) self ) Set remove := method(item, items removeAt(item asString) self ) Set contains := method(item, items hasKey(item asString) ) Set union := method(other, result := Set clone init items foreach(k, v, result add(v)) other items foreach(k, v, result add(v)) result ) Set intersection := method(other, result := Set clone init items foreach(k, v, if(other contains(v), result add(v)) ) result ) // Usage set1 := Set clone init add(1) add(2) add(3) set2 := Set clone init add(2) add(3) add(4) set1 contains(2) println // true union := set1 union(set2) intersection := set1 intersection(set2) Advanced Collection Patterns # Lazy Evaluation # LazyList := Object clone LazyList init := method(generator, self generator := generator self cache := list() self ) LazyList at := method(index, while(cache size \u0026lt;= index, cache append(generator call(cache size)) ) cache at(index) ) LazyList take := method(n, result := list() for(i, 0, n - 1, result append(self at(i)) ) result ) // Infinite fibonacci sequence fibGen := LazyList clone init(block(n, if(n \u0026lt; 2, n, self at(n - 1) + self at(n - 2)) )) fibGen take(10) println // list(0, 1, 1, 2, 3, 5, 8, 13, 21, 34) Collection Pipeline # // Method chaining for data processing data := list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) result := data select(x, x % 2 == 0) \\ map(x, x * x) \\ select(x, x \u0026gt; 10) \\ reduce(+) result println // 120 (16 + 36 + 64) // Custom pipeline List pipeline := method( Pipeline clone setList(self) ) Pipeline := Object clone Pipeline setList := method(list, self list := list self ) Pipeline where := method(predicate, self list = list select(predicate) self ) Pipeline transform := method(mapper, self list = list map(mapper) self ) Pipeline aggregate := method(reducer, list reduce(reducer) ) // Usage numbers := list(1, 2, 3, 4, 5) total := numbers pipeline \\ where(x, x % 2 == 0) \\ transform(x, x * x) \\ aggregate(+) total println // 20 (4 + 16) Nested Collections # // Matrix as list of lists matrix := list( list(1, 2, 3), list(4, 5, 6), list(7, 8, 9) ) // Access element matrix at(1) at(2) println // 6 // Transpose transpose := method(matrix, rows := matrix size cols := matrix at(0) size result := list() for(c, 0, cols - 1, col := list() for(r, 0, rows - 1, col append(matrix at(r) at(c)) ) result append(col) ) result ) transpose(matrix) println // list(list(1, 4, 7), list(2, 5, 8), list(3, 6, 9)) Performance Considerations # // List operations performance list := List clone // O(1) operations list append(item) // Constant time list at(index) // Constant time list size // Constant time // O(n) operations list indexOf(item) // Linear search list contains(item) // Linear search list remove(item) // Linear search + shift // Map operations are generally O(1) map := Map clone map atPut(key, value) // Constant average map at(key) // Constant average map removeAt(key) // Constant average // Choose the right collection for your needs Collection Serialization # // JSON serialization list := list(1, 2, 3, Map with(\u0026quot;name\u0026quot;, \u0026quot;Alice\u0026quot;)) json := list asJson json println // [1,2,3,{\u0026quot;name\u0026quot;:\u0026quot;Alice\u0026quot;}] // Deserialize restored := json parseJson restored println // Custom serialization Collection := Object clone Collection serialize := method( result := list() self foreach(item, if(item hasSlot(\u0026quot;serialize\u0026quot;), result append(item serialize), result append(item asString) ) ) result join(\u0026quot;|\u0026quot;) ) Common Pitfalls # Shared References # // PROBLEM: Shared reference original := list(1, 2, 3) copy := original // Not a copy! copy append(4) original println // list(1, 2, 3, 4) - modified! // SOLUTION: Use copy original := list(1, 2, 3) copy := original copy copy append(4) original println // list(1, 2, 3) - unchanged Iterator Invalidation # // PROBLEM: Modifying while iterating list := list(1, 2, 3, 4, 5) list foreach(item, if(item % 2 == 0, list remove(item) // Dangerous! ) ) // SOLUTION: Use select/reject or iterate on copy list := list(1, 2, 3, 4, 5) list = list reject(item, item % 2 == 0) Exercises # Circular Buffer: Implement a fixed-size circular buffer that overwrites old elements.\nMultiMap: Create a map that can store multiple values per key.\nSorted List: Implement a list that maintains sorted order on insertion.\nTree Structure: Build a tree collection with parent-child relationships.\nGraph: Implement a graph data structure with nodes and edges.\nReal-World Example: Todo List with Tags # TodoItem := Object clone TodoItem init := method(description, self description := description self tags := Set clone init self completed := false self ) TodoList := Object clone TodoList init := method( self items := list() self ) TodoList add := method(description, item := TodoItem clone init(description) items append(item) item ) TodoList taggedWith := method(tag, items select(item, item tags contains(tag)) ) TodoList pending := method( items select(item, item completed not) ) TodoList complete := method(description, item := items detect(i, i description == description) if(item, item completed = true) self ) // Usage todos := TodoList clone init todos add(\u0026quot;Write documentation\u0026quot;) tags add(\u0026quot;work\u0026quot;) add(\u0026quot;writing\u0026quot;) todos add(\u0026quot;Fix bugs\u0026quot;) tags add(\u0026quot;work\u0026quot;) add(\u0026quot;urgent\u0026quot;) todos add(\u0026quot;Buy groceries\u0026quot;) tags add(\u0026quot;personal\u0026quot;) todos taggedWith(\u0026quot;urgent\u0026quot;) foreach(item, item description println ) // Fix bugs todos complete(\u0026quot;Buy groceries\u0026quot;) todos pending foreach(item, item description println ) // Write documentation // Fix bugs Conclusion # Io\u0026rsquo;s collections—List, Map, and Sequence—provide a solid foundation for data manipulation. They\u0026rsquo;re all objects, following Io\u0026rsquo;s uniform object model, and support functional programming patterns like map, select, and reduce.\nThe real power comes from Io\u0026rsquo;s flexibility: you can add methods to existing collection types, create custom collections that integrate seamlessly, and build sophisticated data structures using simple object composition. Understanding collections deeply is essential for effective Io programming, as they form the backbone of most data processing tasks.\nNext: Chapter 9 - Blocks and Closures\n"},{"id":11,"href":"/docs/09-blocks-and-closures/","title":"Blocks and Closures","section":"Chapters","content":" Chapter 9: Blocks and Closures # Blocks in Io are first-class objects representing unevaluated code. They capture their creation context, making them closures. This chapter explores blocks, methods, closures, and how they enable functional programming patterns in Io.\nUnderstanding Blocks and Methods # In Io, block and method are similar but have a crucial difference:\n// Block - creates its own scope blk := block(x, x * 2) blk call(5) println // 10 // Method - shares scope with receiver obj := Object clone obj value := 10 obj meth := method(x, x * value) // Can access 'value' obj blk := block(x, x * value) // Error when called - no 'value' in block scope obj meth(5) println // 50 // obj blk call(5) // Exception: value not found The key difference:\nMethods have access to self and the receiver\u0026rsquo;s slots Blocks create their own scope and don\u0026rsquo;t have automatic access to self Creating and Calling Blocks # // Simple block double := block(x, x * 2) double call(5) println // 10 // Multi-argument block add := block(a, b, a + b) add call(3, 4) println // 7 // No-argument block greet := block(\u0026quot;Hello!\u0026quot; println) greet call // Hello! // Blocks are objects double type println // Block double proto println // Block_0x... Blocks as Closures # Blocks capture variables from their creation context:\nmakeCounter := method( count := 0 block( count = count + 1 count ) ) counter1 := makeCounter() counter2 := makeCounter() counter1 call println // 1 counter1 call println // 2 counter2 call println // 1 (independent) counter1 call println // 3 This is different from many languages where you need special syntax for closures:\n// JavaScript function makeCounter() { let count = 0; return function() { count++; return count; }; } In Io, all blocks are closures automatically.\nThe Scope Chain # Understanding scope is crucial for blocks:\nx := \u0026quot;global\u0026quot; outer := method( x := \u0026quot;outer\u0026quot; inner := block( x println // What prints? ) inner ) myBlock := outer() myBlock call // \u0026quot;outer\u0026quot; - captured from creation context x = \u0026quot;changed global\u0026quot; myBlock call // Still \u0026quot;outer\u0026quot; - closure captures variables, not global Methods and self # Methods have access to self (the receiver):\nCalculator := Object clone Calculator value := 0 Calculator add := method(n, self value = self value + n // Explicit self value // Implicit self ) Calculator addBlock := block(n, // No automatic self here! // Would need to pass it explicitly ) calc := Calculator clone calc add(5) println // 5 calc add(3) println // 8 Block Arguments and Defaults # // Variable arguments sumAll := block( args := call message arguments total := 0 args foreach(arg, total = total + call sender doMessage(arg) ) total ) sumAll call(1, 2, 3, 4, 5) println // 15 // Default arguments (manual) greetWithDefault := block(name, if(name isNil, name = \u0026quot;World\u0026quot;) (\u0026quot;Hello, \u0026quot; .. name .. \u0026quot;!\u0026quot;) println ) greetWithDefault call(\u0026quot;Alice\u0026quot;) // Hello, Alice! greetWithDefault call() // Hello, World! Higher-Order Functions # Blocks enable functional programming patterns:\n// Functions returning functions makeMultiplier := method(factor, block(x, x * factor) ) double := makeMultiplier(2) triple := makeMultiplier(3) double call(5) println // 10 triple call(5) println // 15 // Functions taking functions twice := method(f, x, f call(f call(x)) ) twice(block(n, n + 1), 5) println // 7 // Composition compose := method(f, g, block(x, f call(g call(x))) ) addOne := block(x, x + 1) double := block(x, x * 2) doubleThenAddOne := compose(addOne, double) doubleThenAddOne call(5) println // 11 Partial Application and Currying # // Partial application add := block(a, b, a + b) addFive := block(x, add call(5, x)) addFive call(3) println // 8 // Currying curry := method(f, block(a, block(b, f call(a, b) ) ) ) curriedAdd := curry(add) add5 := curriedAdd call(5) add5 call(3) println // 8 // More practical example formatString := block(template, value, template interpolate(value) ) curriedFormat := curry(formatString) errorFormatter := curriedFormat call(\u0026quot;Error: #{value}\u0026quot;) successFormatter := curriedFormat call(\u0026quot;Success: #{value}\u0026quot;) errorFormatter call(\u0026quot;File not found\u0026quot;) println // Error: File not found successFormatter call(\u0026quot;Operation complete\u0026quot;) println // Success: Operation complete Lazy Evaluation with Blocks # Blocks don\u0026rsquo;t evaluate until called, enabling lazy patterns:\n// Lazy if (already built-in, but here's how it works) lazyIf := method(condition, trueBlock, falseBlock, if(condition, trueBlock call, falseBlock call ) ) x := 5 lazyIf(x \u0026gt; 3, block(\u0026quot;Greater\u0026quot; println), block(\u0026quot;Lesser\u0026quot; println) ) // Lazy infinite sequences naturals := method(start, block( n := start block( current := n n = n + 1 current ) ) call ) seq := naturals(1) 5 repeat(seq call println) // 1, 2, 3, 4, 5 Memoization # Use closures to cache expensive computations:\nmemoize := method(f, cache := Map clone block( args := call message arguments key := args asString if(cache hasKey(key), cache at(key), result := f call(args) cache atPut(key, result) result ) ) ) // Expensive fibonacci fib := block(n, if(n \u0026lt; 2, n, fib call(n - 1) + fib call(n - 2)) ) // Memoized version fastFib := memoize(fib) // Much faster on repeated calls time(fib call(30)) println time(fastFib call(30)) println Block Introspection # Blocks are objects you can inspect:\nmyBlock := block(x, y, x + y * 2) // Inspect structure myBlock argumentNames println // list(x, y) myBlock code println // x +(y *(2)) // Modify blocks myBlock setArgumentNames(list(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;)) myBlock argumentNames println // list(a, b) // Create blocks programmatically code := \u0026quot;a + b\u0026quot; args := list(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;) dynamicBlock := Block clone setArgumentNames(args) setCode(code) dynamicBlock call(3, 4) println // 7 Blocks in Data Structures # // Table of operations operations := Map with( \u0026quot;+\u0026quot;, block(a, b, a + b), \u0026quot;-\u0026quot;, block(a, b, a - b), \u0026quot;*\u0026quot;, block(a, b, a * b), \u0026quot;/\u0026quot;, block(a, b, a / b) ) calculate := method(op, a, b, operations at(op) call(a, b) ) calculate(\u0026quot;+\u0026quot;, 5, 3) println // 8 calculate(\u0026quot;*\u0026quot;, 4, 7) println // 28 // Event handlers EventEmitter := Object clone EventEmitter init := method( self events := Map clone self ) EventEmitter on := method(event, handler, if(events hasKey(event) not, events atPut(event, list()) ) events at(event) append(handler) self ) EventEmitter emit := method(event, data, if(events hasKey(event), events at(event) foreach(handler, handler call(data) ) ) self ) // Usage emitter := EventEmitter clone init emitter on(\u0026quot;click\u0026quot;, block(data, (\u0026quot;Clicked at: \u0026quot; .. data) println )) emitter on(\u0026quot;click\u0026quot;, block(data, (\u0026quot;Another handler: \u0026quot; .. data) println )) emitter emit(\u0026quot;click\u0026quot;, \u0026quot;x=10, y=20\u0026quot;) // Clicked at: x=10, y=20 // Another handler: x=10, y=20 Control Flow with Blocks # Create custom control structures:\n// Retry logic retry := method(times, block, attempts := 0 loop( attempts = attempts + 1 e := try(result := block call) if(e isNil, return result) if(attempts \u0026gt;= times, Exception raise(e)) (\u0026quot;Attempt \u0026quot; .. attempts .. \u0026quot; failed, retrying...\u0026quot;) println ) ) // Usage result := retry(3, block( if(Random value \u0026lt; 0.7, Exception raise(\u0026quot;Random failure\u0026quot;), \u0026quot;Success!\u0026quot; ) )) // While with condition block whileTrue := method(conditionBlock, bodyBlock, while(conditionBlock call, bodyBlock call) ) i := 0 whileTrue( block(i \u0026lt; 5), block( i println i = i + 1 ) ) Performance Considerations # // Method vs Block performance obj := Object clone obj value := 10 obj method1 := method(x, x + value) obj block1 := block(x, x + 10) // Methods are slightly faster for object operations time(100000 repeat(obj method1(5))) time(100000 repeat(obj block1 call(5))) // But blocks are better for functional patterns numbers := list(1, 2, 3, 4, 5) time(numbers map(x, x * 2)) // Using block syntax Advanced Patterns # Continuation-Style Programming # // Continuation passing style factorial := method(n, continuation, if(n \u0026lt;= 1, continuation call(1), factorial(n - 1, block(result, continuation call(n * result) )) ) ) factorial(5, block(result, result println)) // 120 Monadic Patterns # // Maybe monad Maybe := Object clone Maybe Nothing := Maybe clone Maybe Just := method(value, m := Maybe clone m value := value m isNothing := false m ) Maybe Nothing isNothing := true Maybe bind := method(f, if(isNothing, Maybe Nothing, f call(value)) ) Maybe map := method(f, if(isNothing, Maybe Nothing, Maybe Just(f call(value)) ) ) // Usage result := Maybe Just(5) \\ map(block(x, x * 2)) \\ bind(block(x, if(x \u0026gt; 5, Maybe Just(x), Maybe Nothing) )) \\ map(block(x, x + 1)) if(result isNothing not, result value println // 11 ) Transducers # // Composable transformations mapping := method(f, method(reducer, block(acc, item, reducer call(acc, f call(item)) ) ) ) filtering := method(pred, method(reducer, block(acc, item, if(pred call(item), reducer call(acc, item), acc ) ) ) ) // Compose transducers transduce := method(xform, reducer, init, coll, xreducer := xform call(reducer) coll foreach(item, init = xreducer call(init, item) ) init ) // Usage xform := filtering(block(x, x % 2 == 0)) call( mapping(block(x, x * 2)) ) result := transduce(xform, block(acc, x, acc + x), 0, list(1, 2, 3, 4, 5, 6) ) result println // 24 (2*2 + 4*2 + 6*2) Common Pitfalls # Variable Capture # // PROBLEM: Loop variable capture handlers := list() for(i, 1, 3, handlers append(block(i println)) ) handlers foreach(h, h call) // All print 3! // SOLUTION: Create new scope handlers := list() for(i, 1, 3, handlers append( method(n, block(n println)) call(i) ) ) handlers foreach(h, h call) // 1, 2, 3 Memory Leaks with Closures # // PROBLEM: Closure keeps large object alive makeClosure := method( hugeData := List clone 10000 repeat(hugeData append(Random value)) block(x, x * 2) // Doesn't use hugeData but keeps it alive! ) // SOLUTION: Be explicit about captured variables makeClosure := method( hugeData := List clone 10000 repeat(hugeData append(Random value)) processedValue := hugeData size // Extract what you need hugeData = nil // Release reference block(x, x * processedValue) ) Exercises # Promise Implementation: Create a Promise/Future system using blocks for async operations.\nStream Processing: Build a lazy stream processor with map, filter, and reduce.\nFunction Decorator: Implement decorators for logging, timing, and caching.\nParser Combinators: Create a simple parser combinator library using blocks.\nReactive System: Build a simple FRP (Functional Reactive Programming) system.\nReal-World Example: Pipeline Builder # Pipeline := Object clone Pipeline init := method( self steps := list() self ) Pipeline add := method(step, steps append(step) self ) Pipeline map := method(f, self add(block(data, data map(f) )) ) Pipeline filter := method(pred, self add(block(data, data select(pred) )) ) Pipeline tap := method(f, self add(block(data, f call(data) data )) ) Pipeline run := method(input, result := input steps foreach(step, result = step call(result) ) result ) // Usage pipeline := Pipeline clone init \\ filter(block(x, x % 2 == 0)) \\ map(block(x, x * x)) \\ tap(block(data, (\u0026quot;After squaring: \u0026quot; .. data) println)) \\ filter(block(x, x \u0026gt; 10)) \\ map(block(x, x asString)) result := pipeline run(list(1, 2, 3, 4, 5, 6)) // After squaring: list(4, 16, 36) result println // list(\u0026quot;16\u0026quot;, \u0026quot;36\u0026quot;) Conclusion # Blocks and closures are fundamental to Io\u0026rsquo;s expressiveness. They\u0026rsquo;re not just anonymous functions—they\u0026rsquo;re first-class objects that capture context, enable functional programming, and allow you to extend the language with new control structures.\nThe distinction between blocks (isolated scope) and methods (shared scope with receiver) provides flexibility in how you structure code. Closures emerge naturally from Io\u0026rsquo;s scope rules, making complex patterns like memoization, continuations, and higher-order functions straightforward to implement.\nUnderstanding blocks deeply unlocks Io\u0026rsquo;s full potential, enabling you to write code that\u0026rsquo;s both powerful and elegant.\nNext: Chapter 10 - Exceptions\n"},{"id":12,"href":"/docs/10-exceptions/","title":"Exceptions","section":"Chapters","content":" Chapter 10: Exceptions # Error handling is crucial for robust programs. Io provides an exception system that, like everything else in the language, is built on objects and messages. This chapter explores how exceptions work, how to handle errors gracefully, and how to create custom exception types.\nBasic Exception Handling # Io uses try, catch, and raise for exception handling:\n// Basic try-catch try( 10 / 0 // Division by zero ) catch(Exception, e, (\u0026quot;Error: \u0026quot; .. e message) println ) // Error: divide by zero // Multiple catch blocks try( someRiskyOperation() ) catch(TypeError, e, \u0026quot;Type error occurred\u0026quot; println ) catch(IOException, e, \u0026quot;IO error occurred\u0026quot; println ) catch(Exception, e, \u0026quot;Some other error occurred\u0026quot; println ) Compare with other languages:\n# Python try: result = 10 / 0 except ZeroDivisionError as e: print(f\u0026quot;Error: {e}\u0026quot;) // Java try { int result = 10 / 0; } catch (ArithmeticException e) { System.out.println(\u0026quot;Error: \u0026quot; + e.getMessage()); } Raising Exceptions # // Raise a simple exception Exception raise(\u0026quot;Something went wrong\u0026quot;) // Raise with more information e := Exception clone e setMessage(\u0026quot;File not found\u0026quot;) e raise // Conditional raising validateAge := method(age, if(age \u0026lt; 0, Exception raise(\u0026quot;Age cannot be negative\u0026quot;)) if(age \u0026gt; 150, Exception raise(\u0026quot;Age seems unrealistic\u0026quot;)) age ) try( validateAge(-5) ) catch(Exception, e, e message println // Age cannot be negative ) Exception Objects # Exceptions are just objects:\n// Examine exception structure e := Exception clone e type println // Exception e proto println // Object_0x... // Exception slots e setMessage(\u0026quot;Test error\u0026quot;) e message println // Test error // Stack trace try( Exception raise(\u0026quot;Test\u0026quot;) ) catch(Exception, e, e showStack // Prints full stack trace e coroutine println // The coroutine where error occurred ) Creating Custom Exceptions # // Define custom exception types ValidationError := Exception clone ValidationError type := \u0026quot;ValidationError\u0026quot; NetworkError := Exception clone NetworkError type := \u0026quot;NetworkError\u0026quot; NetworkError code := nil NetworkError setCode := method(c, self code = c; self) // Use custom exceptions validateEmail := method(email, if(email containsSeq(\u0026quot;@\u0026quot;) not, ValidationError clone setMessage(\u0026quot;Invalid email format\u0026quot;) raise ) email ) fetchData := method(url, // Simulate network error if(Random value \u0026lt; 0.3, NetworkError clone setMessage(\u0026quot;Connection timeout\u0026quot;) setCode(408) raise ) \u0026quot;data\u0026quot; ) // Handle specific exception types try( validateEmail(\u0026quot;badEmail\u0026quot;) ) catch(ValidationError, e, (\u0026quot;Validation failed: \u0026quot; .. e message) println ) catch(Exception, e, (\u0026quot;Unexpected error: \u0026quot; .. e message) println ) The finally Block # // Ensure cleanup with finally file := nil try( file = File with(\u0026quot;data.txt\u0026quot;) openForReading contents := file contents processData(contents) ) catch(Exception, e, (\u0026quot;Error reading file: \u0026quot; .. e message) println ) finally( if(file, file close) \u0026quot;Cleanup complete\u0026quot; println ) // finally always executes result := try( \u0026quot;Success\u0026quot; println 42 ) catch(Exception, e, \u0026quot;Error\u0026quot; println 0 ) finally( \u0026quot;Always runs\u0026quot; println ) // Prints: Success, Always runs result println // 42 Return Values and Exceptions # // try returns a value result := try( 10 / 2 ) catch(Exception, e, 0 // Default value on error ) result println // 5 // With error result := try( 10 / 0 ) catch(Exception, e, 0 // Default value on error ) result println // 0 // Pattern: Result or default safeDiv := method(a, b, try(a / b) catch(Exception, 0) ) safeDiv(10, 2) println // 5 safeDiv(10, 0) println // 0 Exception Propagation # Exceptions bubble up through the call stack:\nlevel3 := method( Exception raise(\u0026quot;Error at level 3\u0026quot;) ) level2 := method( \u0026quot;Level 2 start\u0026quot; println level3() \u0026quot;Level 2 end\u0026quot; println // Never reached ) level1 := method( \u0026quot;Level 1 start\u0026quot; println level2() \u0026quot;Level 1 end\u0026quot; println // Never reached ) try( level1() ) catch(Exception, e, (\u0026quot;Caught at top level: \u0026quot; .. e message) println ) // Level 1 start // Level 2 start // Caught at top level: Error at level 3 Rethrowing Exceptions # processFile := method(filename, try( file := File with(filename) openForReading // Process file ) catch(Exception, e, (\u0026quot;Failed to process \u0026quot; .. filename) println e raise // Rethrow the original exception ) ) try( processFile(\u0026quot;nonexistent.txt\u0026quot;) ) catch(Exception, e, \u0026quot;Caught rethrown exception\u0026quot; println ) Error Recovery Patterns # Retry Pattern # retryOperation := method(operation, maxAttempts, attempts := 0 lastError := nil while(attempts \u0026lt; maxAttempts, attempts = attempts + 1 e := try( return operation call(attempts) ) if(e, lastError = e (\u0026quot;Attempt \u0026quot; .. attempts .. \u0026quot; failed: \u0026quot; .. e message) println if(attempts \u0026lt; maxAttempts, wait(0.5)) ) ) Exception raise(\u0026quot;All \u0026quot; .. maxAttempts .. \u0026quot; attempts failed. Last error: \u0026quot; .. lastError message) ) // Usage result := retryOperation( block(attempt, if(Random value \u0026lt; 0.7, Exception raise(\u0026quot;Random failure\u0026quot;), \u0026quot;Success on attempt \u0026quot; .. attempt ) ), 3 ) Circuit Breaker # CircuitBreaker := Object clone CircuitBreaker init := method(threshold, timeout, self failureCount := 0 self threshold := threshold self timeout := timeout self state := \u0026quot;closed\u0026quot; // closed, open, half-open self lastFailureTime := nil self ) CircuitBreaker call := method(operation, if(state == \u0026quot;open\u0026quot;, if(Date now - lastFailureTime \u0026gt; timeout, state = \u0026quot;half-open\u0026quot; \u0026quot;Circuit breaker entering half-open state\u0026quot; println, Exception raise(\u0026quot;Circuit breaker is open\u0026quot;) ) ) e := try( result := operation call if(state == \u0026quot;half-open\u0026quot;, state = \u0026quot;closed\u0026quot; failureCount = 0 \u0026quot;Circuit breaker closed\u0026quot; println ) return result ) if(e, failureCount = failureCount + 1 lastFailureTime = Date now if(failureCount \u0026gt;= threshold, state = \u0026quot;open\u0026quot; \u0026quot;Circuit breaker opened\u0026quot; println ) e raise ) ) // Usage breaker := CircuitBreaker clone init(3, 5) unreliableService := block( if(Random value \u0026lt; 0.8, Exception raise(\u0026quot;Service unavailable\u0026quot;), \u0026quot;Service response\u0026quot; ) ) 5 repeat( try( breaker call(unreliableService) println ) catch(Exception, e, (\u0026quot;Failed: \u0026quot; .. e message) println ) wait(1) ) Assertion and Validation # // Simple assertion assert := method(condition, message, if(condition not, Exception raise(message ifNilEval(\u0026quot;Assertion failed\u0026quot;)) ) ) assert(5 \u0026gt; 3, \u0026quot;Math is broken\u0026quot;) // assert(3 \u0026gt; 5, \u0026quot;This will fail\u0026quot;) // Validation framework Validator := Object clone Validator rules := list() Validator addRule := method(rule, message, rules append(list(rule, message)) self ) Validator validate := method(value, errors := list() rules foreach(rule, if(rule at(0) call(value) not, errors append(rule at(1)) ) ) if(errors size \u0026gt; 0, ValidationError clone setMessage(errors join(\u0026quot;, \u0026quot;)) raise ) value ) // Usage ageValidator := Validator clone \\ addRule(block(v, v isKindOf(Number)), \u0026quot;Must be a number\u0026quot;) \\ addRule(block(v, v \u0026gt;= 0), \u0026quot;Must be non-negative\u0026quot;) \\ addRule(block(v, v \u0026lt;= 150), \u0026quot;Must be realistic\u0026quot;) try( ageValidator validate(25) println // 25 ageValidator validate(-5) // Throws ) catch(ValidationError, e, e message println // Must be non-negative ) Exception Context and Debugging # // Enhanced exception with context ContextualException := Exception clone ContextualException context := Map clone ContextualException addContext := method(key, value, context atPut(key, value) self ) ContextualException describe := method( result := message .. \u0026quot;\\nContext:\\n\u0026quot; context foreach(key, value, result = result .. \u0026quot; \u0026quot; .. key .. \u0026quot;: \u0026quot; .. value .. \u0026quot;\\n\u0026quot; ) result ) // Usage processUser := method(userData, if(userData at(\u0026quot;age\u0026quot;) \u0026lt; 18, ContextualException clone \\ setMessage(\u0026quot;User too young\u0026quot;) \\ addContext(\u0026quot;userId\u0026quot;, userData at(\u0026quot;id\u0026quot;)) \\ addContext(\u0026quot;age\u0026quot;, userData at(\u0026quot;age\u0026quot;)) \\ addContext(\u0026quot;timestamp\u0026quot;, Date now) \\ raise ) ) try( processUser(Map with(\u0026quot;id\u0026quot;, 123, \u0026quot;age\u0026quot;, 16)) ) catch(ContextualException, e, e describe println ) Resource Management # // RAII-style resource management withResource := method(resourceCreator, resourceUser, resource := nil try( resource = resourceCreator call resourceUser call(resource) ) finally( if(resource and resource hasSlot(\u0026quot;close\u0026quot;), resource close ) ) ) // Usage withResource( block(File with(\u0026quot;test.txt\u0026quot;) openForReading), block(file, file contents println ) ) // Database connection example withConnection := method(dbUrl, operation, conn := nil try( conn = Database connect(dbUrl) conn beginTransaction result := operation call(conn) conn commit result ) catch(Exception, e, if(conn, conn rollback) e raise ) finally( if(conn, conn close) ) ) Global Exception Handling # // Install global exception handler System handleException := method(e, logFile := File with(\u0026quot;errors.log\u0026quot;) openForAppending logFile write(Date now asString .. \u0026quot; - \u0026quot; .. e message .. \u0026quot;\\n\u0026quot;) logFile close // Original behavior e showStack System exit(1) ) // Uncaught exceptions now get logged // Exception raise(\u0026quot;Uncaught error\u0026quot;) Testing with Exceptions # // Test framework with exception support Test := Object clone Test assertRaises := method(exceptionType, block, raised := false try( block call ) catch(Exception, e, if(e type == exceptionType type, raised = true, Exception raise(\u0026quot;Wrong exception type: expected \u0026quot; .. exceptionType type .. \u0026quot;, got \u0026quot; .. e type) ) ) if(raised not, Exception raise(\u0026quot;Expected exception \u0026quot; .. exceptionType type .. \u0026quot; was not raised\u0026quot;) ) ) // Usage Test assertRaises(ValidationError, block( validateEmail(\u0026quot;invalid\u0026quot;) )) \u0026quot;Test passed\u0026quot; println Performance Considerations # // Exceptions have overhead benchmark := method(name, iterations, block, start := Date now iterations repeat(block) elapsed := Date now - start (name .. \u0026quot;: \u0026quot; .. elapsed) println ) // Without exceptions benchmark(\u0026quot;No exceptions\u0026quot;, 100000, block( if(Random value \u0026lt; 0.1, nil, \u0026quot;success\u0026quot;) )) // With exceptions benchmark(\u0026quot;With exceptions\u0026quot;, 100000, block( try( if(Random value \u0026lt; 0.1, Exception raise(\u0026quot;error\u0026quot;)) \u0026quot;success\u0026quot; ) catch(Exception, nil) )) // Exceptions are slower - use for exceptional cases, not control flow Common Pitfalls # Catching Too Broadly # // BAD: Catches everything, hiding bugs try( complexOperation() ) catch(Exception, e, // Silently ignore all errors ) // GOOD: Catch specific exceptions try( complexOperation() ) catch(NetworkError, e, handleNetworkError(e) ) catch(ValidationError, e, handleValidationError(e) ) Resource Leaks # // BAD: File not closed on error file := File with(\u0026quot;data.txt\u0026quot;) openForReading processFile(file) // If this throws, file never closes file close // GOOD: Use finally file := nil try( file = File with(\u0026quot;data.txt\u0026quot;) openForReading processFile(file) ) finally( if(file, file close) ) Exercises # Result Type: Implement a Result type that can be either Ok(value) or Error(error), similar to Rust.\nRetry with Exponential Backoff: Create a retry mechanism with exponential backoff and jitter.\nException Logger: Build a logging system that captures and categorizes exceptions.\nValidation Chain: Create a validation system that accumulates all errors instead of failing on first.\nAsync Exception Handling: Implement exception handling for coroutine-based async operations.\nReal-World Example: HTTP Client with Error Handling # HttpClient := Object clone HttpClient timeoutMs := 5000 HttpClient maxRetries := 3 HttpError := Exception clone HttpError statusCode := nil HttpClient get := method(url, retryCount := 0 loop( try( response := self doRequest(url) if(response statusCode \u0026gt;= 200 and response statusCode \u0026lt; 300, return response body ) if(response statusCode \u0026gt;= 400 and response statusCode \u0026lt; 500, // Client error - don't retry HttpError clone \\ setMessage(\u0026quot;HTTP \u0026quot; .. response statusCode) \\ setSlot(\u0026quot;statusCode\u0026quot;, response statusCode) \\ raise ) // Server error - might retry if(response statusCode \u0026gt;= 500, error := HttpError clone \\ setMessage(\u0026quot;Server error: \u0026quot; .. response statusCode) \\ setSlot(\u0026quot;statusCode\u0026quot;, response statusCode) if(retryCount \u0026lt; maxRetries, retryCount = retryCount + 1 delay := (2 pow(retryCount)) * 100 (\u0026quot;Retry \u0026quot; .. retryCount .. \u0026quot; after \u0026quot; .. delay .. \u0026quot;ms\u0026quot;) println wait(delay / 1000) continue, error raise ) ) ) catch(NetworkError, e, if(retryCount \u0026lt; maxRetries, retryCount = retryCount + 1 (\u0026quot;Network error, retry \u0026quot; .. retryCount) println wait(1) continue, e raise ) ) ) ) // Usage with comprehensive error handling fetchUserData := method(userId, try( data := HttpClient get(\u0026quot;https://api.example.com/users/\u0026quot; .. userId) JSON parse(data) ) catch(HttpError, e, if(e statusCode == 404, nil, // User not found if(e statusCode == 401, Exception raise(\u0026quot;Authentication required\u0026quot;), Exception raise(\u0026quot;HTTP error: \u0026quot; .. e statusCode) ) ) ) catch(NetworkError, e, Exception raise(\u0026quot;Network unavailable\u0026quot;) ) catch(Exception, e, Exception raise(\u0026quot;Unexpected error: \u0026quot; .. e message) ) ) Conclusion # Io\u0026rsquo;s exception system demonstrates the language\u0026rsquo;s consistency: exceptions are objects, throwing is a message, and catching is a method. This uniformity makes the system easy to understand while remaining powerful enough for sophisticated error handling.\nThe key to effective exception handling in Io is understanding when to use exceptions (for exceptional circumstances) versus return values (for expected conditions), and ensuring proper resource cleanup with finally blocks. Custom exception types and contextual information make debugging easier, while patterns like retry logic and circuit breakers add robustness to applications.\nNext: Chapter 11 - Metaprogramming\n"},{"id":13,"href":"/docs/11-metaprogramming/","title":"Metaprogramming","section":"Chapters","content":" Chapter 11: Metaprogramming # Metaprogramming—writing code that manipulates code—is where Io truly shines. Since everything in Io is an object, including messages and methods, you can inspect, modify, and generate code at runtime. This chapter explores Io\u0026rsquo;s powerful metaprogramming capabilities.\nMessages as Data # In Io, code is data. Messages are objects you can create, inspect, and manipulate:\n// Create a message from code msg := message(2 + 3 * 4) // Inspect its structure msg println // 2 +(3 *(4)) msg name println // + msg arguments println // list(Message_0x...) msg arguments at(0) println // 3 *(4) // Evaluate it result := msg doInContext(Lobby) result println // 14 // Modify it msg setName(\u0026quot;*\u0026quot;) msg doInContext(Lobby) println // 6 (now it's 2 * 3 * 4) Compare this to Lisp\u0026rsquo;s code-as-data philosophy:\n; Lisp (defparameter code '(+ 2 (* 3 4))) (eval code) ; 14 But Io uses messages instead of lists, which feels more natural for object-oriented code.\nBuilding Messages Programmatically # // Build a message from scratch msg := Message clone msg setName(\u0026quot;println\u0026quot;) msg setArguments(list(Message clone setName(\u0026quot;\\\u0026quot;Hello, World!\\\u0026quot;\u0026quot;))) // Execute it Lobby doMessage(msg) // Hello, World! // Build more complex messages createAdder := method(n, msg := Message clone setName(\u0026quot;+\u0026quot;) msg setArguments(list(Message clone setName(n asString))) msg ) adder5 := createAdder(5) 7 doMessage(adder5) println // 12 Method Introspection # Methods are objects you can examine and modify:\nobj := Object clone obj greet := method(name, \u0026quot;Hello, \u0026quot; .. name .. \u0026quot;!\u0026quot;) // Get the method object m := obj getSlot(\u0026quot;greet\u0026quot;) m type println // Block m argumentNames println // list(name) m code println // \u0026quot;Hello, \u0026quot; ..(name) ..(\u0026quot;!\u0026quot;) // Modify method implementation obj greet = method(name, \u0026quot;Goodbye, \u0026quot; .. name .. \u0026quot;!\u0026quot;) obj greet(\u0026quot;World\u0026quot;) println // Goodbye, World! // Copy methods between objects other := Object clone other sayHi := obj getSlot(\u0026quot;greet\u0026quot;) other sayHi(\u0026quot;Io\u0026quot;) println // Goodbye, Io! The call Object # The call object provides runtime context information:\nObject introspect := method( \u0026quot;=== Call Introspection ===\u0026quot; println (\u0026quot;Sender: \u0026quot; .. call sender type) println (\u0026quot;Target: \u0026quot; .. call target type) println (\u0026quot;Message: \u0026quot; .. call message) println (\u0026quot;Arguments: \u0026quot; .. call message arguments) println (\u0026quot;Activated: \u0026quot; .. call activated) println \u0026quot;========================\u0026quot; println ) TestObj := Object clone TestObj test := method(a, b, introspect a + b ) TestObj test(5, 3) // === Call Introspection === // Sender: Lobby // Target: TestObj // Message: introspect // Arguments: list() // Activated: method(...) // ======================== Dynamic Method Creation # Create methods at runtime:\n// Create getters and setters dynamically Object addProperty := method(name, defaultValue, // Create storage slot self setSlot(\u0026quot;_\u0026quot; .. name, defaultValue) // Create getter self setSlot(name, method(self getSlot(\u0026quot;_\u0026quot; .. call message name)) ) // Create setter self setSlot(\u0026quot;set\u0026quot; .. name asCapitalized, method(value, self setSlot(\u0026quot;_\u0026quot; .. call message name beforeSeq(\u0026quot;set\u0026quot;) asLowercase, value) self // For chaining ) ) ) Person := Object clone Person addProperty(\u0026quot;name\u0026quot;, \u0026quot;Unknown\u0026quot;) Person addProperty(\u0026quot;age\u0026quot;, 0) p := Person clone p setName(\u0026quot;Alice\u0026quot;) setAge(30) p name println // Alice p age println // 30 Method Missing Pattern # Intercept undefined method calls:\nDynamicObject := Object clone DynamicObject forward := method( messageName := call message name args := call message arguments (\u0026quot;Intercepted: \u0026quot; .. messageName) println (\u0026quot;Arguments: \u0026quot; .. args) println // Handle dynamically if(messageName beginsWithSeq(\u0026quot;get\u0026quot;), property := messageName afterSeq(\u0026quot;get\u0026quot;) asLowercase return self getSlot(property) ) if(messageName beginsWithSeq(\u0026quot;set\u0026quot;), property := messageName afterSeq(\u0026quot;set\u0026quot;) asLowercase value := call evalArgAt(0) return self setSlot(property, value) ) Exception raise(\u0026quot;Unknown method: \u0026quot; .. messageName) ) obj := DynamicObject clone obj setName(\u0026quot;Bob\u0026quot;) // Intercepted: setName obj getName println // Bob Code Generation # Generate code as strings and evaluate:\n// Generate a class-like structure generateClass := method(className, properties, code := className .. \u0026quot; := Object clone\\n\u0026quot; // Generate init method code = code .. className .. \u0026quot; init := method(\\n\u0026quot; properties foreach(prop, code = code .. \u0026quot; self \u0026quot; .. prop .. \u0026quot; := nil\\n\u0026quot; ) code = code .. \u0026quot; self\\n)\\n\u0026quot; // Generate property accessors properties foreach(prop, // Getter code = code .. className .. \u0026quot; \u0026quot; .. prop .. \u0026quot; := method(_\u0026quot; .. prop .. \u0026quot;)\\n\u0026quot; // Setter code = code .. className .. \u0026quot; set\u0026quot; .. prop asCapitalized .. \u0026quot; := method(v, _\u0026quot; .. prop .. \u0026quot; = v; self)\\n\u0026quot; ) code doString // Evaluate the generated code Lobby getSlot(className) // Return the created object ) // Use the generator Car := generateClass(\u0026quot;Car\u0026quot;, list(\u0026quot;make\u0026quot;, \u0026quot;model\u0026quot;, \u0026quot;year\u0026quot;)) myCar := Car clone init myCar setMake(\u0026quot;Toyota\u0026quot;) setModel(\u0026quot;Camry\u0026quot;) setYear(2020) myCar make println // Toyota Aspect-Oriented Programming # Implement cross-cutting concerns:\n// Method wrapping for logging Object addLogging := method(methodName, original := self getSlot(methodName) self setSlot(methodName, method( (\u0026quot;Calling \u0026quot; .. methodName .. \u0026quot; with args: \u0026quot; .. call message arguments) println result := nil e := try(result = original doMessage(call message, call sender)) if(e, (\u0026quot;Error in \u0026quot; .. methodName .. \u0026quot;: \u0026quot; .. e message) println e raise, (\u0026quot;Returned: \u0026quot; .. result) println result ) )) ) Calculator := Object clone Calculator add := method(a, b, a + b) Calculator divide := method(a, b, a / b) Calculator addLogging(\u0026quot;add\u0026quot;) Calculator addLogging(\u0026quot;divide\u0026quot;) Calculator add(5, 3) // Calling add with args: list(5, 3) // Returned: 8 Calculator divide(10, 0) // Calling divide with args: list(10, 0) // Error in divide: divide by zero Macro System # Io\u0026rsquo;s macros transform code before evaluation:\n// Define a macro Object unless := macro(condition, action, // Macros receive unevaluated arguments as messages // Transform to if(condition not, action) message(if) setArguments( list( message(not) setTarget(condition), action ) ) ) // Use the macro x := 5 unless(x \u0026gt; 10, \u0026quot;x is not greater than 10\u0026quot; println) // x is not greater than 10 // Timing macro Object time := macro(code, // Generate timing code message(do) setArguments(list( message(start := Date now), code, message(elapsed := Date now - start), message((\u0026quot;Elapsed: \u0026quot; .. elapsed) println), message(result) )) ) // Use it time( sum := 0 for(i, 1, 1000000, sum = sum + i) sum ) // Elapsed: 0.234 Self-Modifying Code # Objects can modify their own methods:\nCounter := Object clone Counter count := 0 Counter increment := method( count = count + 1 // Self-modify after 5 calls if(count \u0026gt;= 5, self increment = method( Exception raise(\u0026quot;Counter limit reached\u0026quot;) ) ) count ) c := Counter clone 5 repeat(i, c increment println) // 1, 2, 3, 4, 5 c increment // Exception: Counter limit reached Reflection API # Io provides comprehensive reflection capabilities:\n// Object introspection utilities Object describe := method( (\u0026quot;Type: \u0026quot; .. self type) println \u0026quot;Local Slots:\u0026quot; println self slotNames sort foreach(name, value := self getSlot(name) (\u0026quot; \u0026quot; .. name .. \u0026quot; = \u0026quot; .. value type) println ) \u0026quot;Proto chain:\u0026quot; println proto := self proto while(proto and proto != Object, (\u0026quot; -\u0026gt; \u0026quot; .. proto type) println proto = proto proto ) ) // Usage person := Object clone person name := \u0026quot;Alice\u0026quot; person age := 30 person greet := method(\u0026quot;Hello!\u0026quot;) person describe // Type: Object // Local Slots: // age = Number // greet = Block // name = Sequence // Proto chain: // -\u0026gt; Object DSL Creation with Metaprogramming # Build domain-specific languages:\n// SQL-like DSL Table := Object clone Table columns := list() Table rows := list() Table select := method( query := SelectQuery clone query table := self query ) SelectQuery := Object clone SelectQuery conditions := list() SelectQuery where := method( // Parse conditions from arguments args := call message arguments args foreach(arg, conditions append(arg) ) self ) SelectQuery execute := method( table rows select(row, result := true conditions foreach(cond, result = result and cond doInContext(row) ) result ) ) // Usage users := Table clone users columns = list(\u0026quot;name\u0026quot;, \u0026quot;age\u0026quot;, \u0026quot;city\u0026quot;) users rows = list( Object clone do(name := \u0026quot;Alice\u0026quot;; age := 30; city := \u0026quot;NYC\u0026quot;), Object clone do(name := \u0026quot;Bob\u0026quot;; age := 25; city := \u0026quot;LA\u0026quot;), Object clone do(name := \u0026quot;Charlie\u0026quot;; age := 35; city := \u0026quot;NYC\u0026quot;) ) results := users select where(age \u0026gt; 25, city == \u0026quot;NYC\u0026quot;) execute results foreach(r, (r name .. \u0026quot;: \u0026quot; .. r age) println) // Alice: 30 // Charlie: 35 Performance Profiling # Use metaprogramming for profiling:\nProfiler := Object clone Profiler stats := Map clone Object profile := method(methodName, original := self getSlot(methodName) self setSlot(methodName, method( start := Date now result := original doMessage(call message, call sender) elapsed := Date now - start key := self type .. \u0026quot;::\u0026quot; .. methodName if(Profiler stats hasKey(key) not, Profiler stats atPut(key, list(0, 0)) ) stats := Profiler stats at(key) stats atPut(0, stats at(0) + 1) // Count stats atPut(1, stats at(1) + elapsed) // Total time result )) ) Profiler report := method( \u0026quot;=== Profiling Report ===\u0026quot; println stats foreach(key, data, avg := data at(1) / data at(0) (key .. \u0026quot;: \u0026quot; .. data at(0) .. \u0026quot; calls, \u0026quot; .. data at(1) .. \u0026quot;s total, \u0026quot; .. avg .. \u0026quot;s avg\u0026quot;) println ) ) // Usage Math := Object clone Math factorial := method(n, if(n \u0026lt;= 1, 1, n * factorial(n - 1)) ) Math profile(\u0026quot;factorial\u0026quot;) 10 repeat(Math factorial(20)) Profiler report Compile-Time Computation # Use macros for compile-time optimization:\n// Macro that pre-computes constant expressions Object precompute := macro(expr, // If expression contains only literals, evaluate now result := nil e := try(result = expr doInContext(Object clone)) if(e isNil, // Successfully evaluated - return literal Message clone setName(result asString), // Contains variables - return original expr ) ) // Usage x := 10 y := precompute(5 * 6 + 7) // Computed at parse time z := precompute(x * 2) // Can't precompute, has variable y println // 37 (was precomputed) Method Combination # Implement method combination patterns:\n// Before/After/Around methods Object addBefore := method(methodName, beforeBlock, original := self getSlot(methodName) self setSlot(methodName, method( beforeBlock doMessage(call message, call sender) original doMessage(call message, call sender) )) ) Object addAfter := method(methodName, afterBlock, original := self getSlot(methodName) self setSlot(methodName, method( result := original doMessage(call message, call sender) afterBlock call(result) result )) ) Object addAround := method(methodName, aroundBlock, original := self getSlot(methodName) self setSlot(methodName, method( aroundBlock call(original, call message, call sender) )) ) // Usage BankAccount := Object clone BankAccount balance := 100 BankAccount withdraw := method(amount, balance = balance - amount) BankAccount addBefore(\u0026quot;withdraw\u0026quot;, method(amount, (\u0026quot;Withdrawing \u0026quot; .. amount) println )) BankAccount addAfter(\u0026quot;withdraw\u0026quot;, method(result, (\u0026quot;New balance: \u0026quot; .. balance) println )) BankAccount addAround(\u0026quot;withdraw\u0026quot;, method(original, msg, sender, amount := msg argAt(0) doInContext(sender) if(amount \u0026gt; balance, Exception raise(\u0026quot;Insufficient funds\u0026quot;), original doMessage(msg, sender) ) )) account := BankAccount clone account withdraw(50) // Withdrawing 50 // New balance: 50 Common Pitfalls # Evaluation Context # // PROBLEM: Wrong context makeMethod := method(code, method doString(code) // code evaluates in method's context ) obj := Object clone obj value := 10 obj badMethod := makeMethod(\u0026quot;value * 2\u0026quot;) // obj badMethod // Error: value not found // SOLUTION: Use message objects makeMethod := method(code, method(code doInContext(self)) ) Performance Impact # // Metaprogramming has runtime cost directCall := method(x, x * 2) dynamicCall := method(x, msg := Message clone setName(\u0026quot;*\u0026quot;) setArguments(list(Message clone setName(\u0026quot;2\u0026quot;))) x doMessage(msg) ) // directCall is much faster than dynamicCall Exercises # Memoization Decorator: Create a decorator that automatically memoizes any method.\nContract System: Implement Design by Contract with pre/post conditions.\nMock Object Generator: Build a system that generates mock objects for testing.\nDependency Injection: Create a DI container using metaprogramming.\nORM: Build a simple object-relational mapper that generates methods from table schemas.\nReal-World Example: ActiveRecord Pattern # // Simple ActiveRecord implementation ActiveRecord := Object clone ActiveRecord tableName := nil ActiveRecord connection := nil // Database connection ActiveRecord findById := method(id, sql := \u0026quot;SELECT * FROM \u0026quot; .. tableName .. \u0026quot; WHERE id = \u0026quot; .. id row := connection execute(sql) first if(row, obj := self clone row foreach(column, value, obj setSlot(column, value) ) obj ) ) ActiveRecord save := method( if(hasSlot(\u0026quot;id\u0026quot;), // Update sql := \u0026quot;UPDATE \u0026quot; .. tableName .. \u0026quot; SET \u0026quot; updates := list() slotNames foreach(name, if(name != \u0026quot;id\u0026quot;, updates append(name .. \u0026quot; = '\u0026quot; .. getSlot(name) .. \u0026quot;'\u0026quot;) ) ) sql = sql .. updates join(\u0026quot;, \u0026quot;) .. \u0026quot; WHERE id = \u0026quot; .. id , // Insert sql := \u0026quot;INSERT INTO \u0026quot; .. tableName columns := list() values := list() slotNames foreach(name, columns append(name) values append(\u0026quot;'\u0026quot; .. getSlot(name) .. \u0026quot;'\u0026quot;) ) sql = sql .. \u0026quot; (\u0026quot; .. columns join(\u0026quot;, \u0026quot;) .. \u0026quot;) VALUES (\u0026quot; .. values join(\u0026quot;, \u0026quot;) .. \u0026quot;)\u0026quot; ) connection execute(sql) self ) // Generate model from table generateModel := method(name, table, columns, model := ActiveRecord clone model type := name model tableName = table // Add properties columns foreach(column, model setSlot(column, nil) ) // Add validations model validate := method( // Generated validation code true ) // Store in Lobby Lobby setSlot(name, model) model ) // Usage User := generateModel(\u0026quot;User\u0026quot;, \u0026quot;users\u0026quot;, list(\u0026quot;id\u0026quot;, \u0026quot;name\u0026quot;, \u0026quot;email\u0026quot;, \u0026quot;age\u0026quot;)) user := User clone user name = \u0026quot;Alice\u0026quot; user email = \u0026quot;alice@example.com\u0026quot; user age = 30 // user save foundUser := User findById(1) Conclusion # Metaprogramming in Io isn\u0026rsquo;t a special feature—it\u0026rsquo;s a natural consequence of the language\u0026rsquo;s design. When everything is an object, including code itself, manipulation becomes straightforward. Messages as first-class objects, comprehensive reflection, and runtime modification enable powerful patterns that would require complex machinery in other languages.\nThe key to effective metaprogramming in Io is understanding that you\u0026rsquo;re not working with special metaprogramming constructs, but simply manipulating objects that happen to represent code. This uniformity makes metaprogramming accessible and powerful, though it requires careful consideration of evaluation contexts and performance implications.\nNext: Chapter 12 - Concurrency\n"},{"id":14,"href":"/docs/12-concurrency/","title":"Concurrency","section":"Chapters","content":" Chapter 12: Concurrency # Io provides powerful concurrency primitives: coroutines for cooperative multitasking, actors for message-passing concurrency, and futures for asynchronous computation. This chapter explores these mechanisms and how they enable concurrent and parallel programming in Io.\nCoroutines: Cooperative Multitasking # Coroutines are the foundation of Io\u0026rsquo;s concurrency model. They\u0026rsquo;re lightweight threads that yield control cooperatively:\n// Create a coroutine coro := coroutine( 5 repeat(i, (\u0026quot;Coroutine: \u0026quot; .. i) println yield // Give control back ) ) // Run it 5 repeat( \u0026quot;Main\u0026quot; println coro resume // Resume the coroutine ) // Output interleaves Main and Coroutine messages Compare with threads in other languages:\n# Python with threads (preemptive) import threading def worker(): for i in range(5): print(f\u0026quot;Thread: {i}\u0026quot;) # No explicit yield needed # Python with async (cooperative) async def worker(): for i in range(5): print(f\u0026quot;Coroutine: {i}\u0026quot;) await asyncio.sleep(0) # Explicit yield Creating and Managing Coroutines # // Basic coroutine creation coro := Coroutine clone coro setRunMessage(message( \u0026quot;Running in coroutine\u0026quot; println self // Return value )) coro resume println // \u0026quot;Running in coroutine\u0026quot;, then returns self // Using @ for async execution future := obj @method(arg) // Runs method in new coroutine result := future resolve // Wait for result // Coroutine with arguments producer := coroutine( 10 repeat(i, yield(i * i) // Yield a value ) ) 5 repeat( producer resume println // 0, 1, 4, 9, 16 ) Actors: Message-Passing Concurrency # Actors are objects that process messages asynchronously in their own coroutine:\n// Create an actor Counter := Object clone Counter count := 0 Counter increment := method( count = count + 1 count ) // Make it an actor counter := Counter clone counterActor := counter @ // @ makes it an actor // Send messages asynchronously future1 := counterActor increment future2 := counterActor increment future3 := counterActor increment // Get results future1 resolve println // 1 future2 resolve println // 2 future3 resolve println // 3 This is similar to Erlang\u0026rsquo;s actor model:\n% Erlang counter(Count) -\u0026gt; receive {increment, From} -\u0026gt; From ! Count + 1, counter(Count + 1) end. Futures and Promises # Futures represent values that will be available later:\n// Create a future manually future := Future clone // In another coroutine, fulfill it @( wait(1) // Simulate work future setResult(42) ) // Wait for result \u0026quot;Waiting...\u0026quot; println result := future resolve (\u0026quot;Got result: \u0026quot; .. result) println // Got result: 42 // Futures from async calls slowOperation := method(n, wait(n) n * 2 ) f := self @slowOperation(2) \u0026quot;Doing other work...\u0026quot; println result := f resolve result println // 4 Channels for Communication # Implement Go-style channels:\nChannel := Object clone Channel init := method( self queue := list() self waiters := list() self ) Channel send := method(value, if(waiters size \u0026gt; 0, waiter := waiters removeFirst waiter resume(value), queue append(value) ) ) Channel receive := method( if(queue size \u0026gt; 0, queue removeFirst, waiters append(Coroutine currentCoroutine) Coroutine currentCoroutine pause ) ) // Usage ch := Channel clone init // Producer @( 5 repeat(i, ch send(i * i) wait(0.1) ) ) // Consumer @( 5 repeat( value := ch receive (\u0026quot;Received: \u0026quot; .. value) println ) ) wait(1) // Let them run Synchronization Primitives # Mutex (Mutual Exclusion) # Mutex := Object clone Mutex locked := false Mutex waitQueue := list() Mutex lock := method( while(locked, waitQueue append(Coroutine currentCoroutine) Coroutine currentCoroutine pause ) locked = true ) Mutex unlock := method( locked = false if(waitQueue size \u0026gt; 0, waiter := waitQueue removeFirst waiter resume ) ) Mutex synchronize := method(block, lock e := try(result := block call) unlock if(e, e raise, result) ) // Usage sharedCounter := 0 mutex := Mutex clone 10 repeat( @( mutex synchronize( temp := sharedCounter yield // Simulate race condition sharedCounter = temp + 1 ) ) ) wait(0.5) sharedCounter println // 10 (without mutex would be unpredictable) Semaphore # Semaphore := Object clone Semaphore init := method(permits, self permits := permits self waitQueue := list() self ) Semaphore acquire := method( while(permits \u0026lt;= 0, waitQueue append(Coroutine currentCoroutine) Coroutine currentCoroutine pause ) permits = permits - 1 ) Semaphore release := method( permits = permits + 1 if(waitQueue size \u0026gt; 0, waiter := waitQueue removeFirst waiter resume ) ) // Usage: Limit concurrent connections connectionPool := Semaphore clone init(3) 10 repeat(i, @( connectionPool acquire (\u0026quot;Connection \u0026quot; .. i .. \u0026quot; started\u0026quot;) println wait(Random value) (\u0026quot;Connection \u0026quot; .. i .. \u0026quot; finished\u0026quot;) println connectionPool release ) ) wait(3) Concurrent Collections # // Thread-safe list ConcurrentList := List clone ConcurrentList mutex := Mutex clone ConcurrentList append := method(item, mutex synchronize(resend(item)) ) ConcurrentList at := method(index, mutex synchronize(resend(index)) ) ConcurrentList size := method( mutex synchronize(resend) ) // Usage list := ConcurrentList clone 10 repeat(i, @(list append(i)) ) wait(0.1) list size println // 10 Worker Pool Pattern # WorkerPool := Object clone WorkerPool init := method(workerCount, self workers := list() self taskQueue := Channel clone init self results := Channel clone init workerCount repeat( worker := @( loop( task := taskQueue receive if(task isNil, break) // Poison pill result := task call results send(result) ) ) workers append(worker) ) self ) WorkerPool submit := method(task, taskQueue send(task) ) WorkerPool shutdown := method( workers size repeat(taskQueue send(nil)) ) WorkerPool getResult := method( results receive ) // Usage pool := WorkerPool clone init(4) // Submit tasks 10 repeat(i, pool submit(block( wait(Random value * 0.1) i * i )) ) // Collect results results := list() 10 repeat( results append(pool getResult) ) pool shutdown results println Async/Await Pattern # // Implement async/await style Object async := method( future := Future clone @( e := try(result := call activated doMessage(call message, call sender)) if(e, future setException(e), future setResult(result) ) ) future ) Object await := method(future, future resolve ) // Usage fetchData := async method(url, wait(1) // Simulate network delay \u0026quot;Data from \u0026quot; .. url ) processData := async method( data1 := await(fetchData(\u0026quot;api/users\u0026quot;)) data2 := await(fetchData(\u0026quot;api/posts\u0026quot;)) data1 .. \u0026quot; + \u0026quot; .. data2 ) result := await(processData) result println // Data from api/users + Data from api/posts Parallel Map # List parallelMap := method(block, futures := self map(item, self @(block call(item)) ) futures map(resolve) ) // Usage numbers := list(1, 2, 3, 4, 5) // Sequential map time( sequential := numbers map(n, wait(0.1) n * n ) ) // Parallel map time( parallel := numbers parallelMap(n, wait(0.1) n * n ) ) sequential println // list(1, 4, 9, 16, 25) parallel println // list(1, 4, 9, 16, 25) but faster Deadlock Detection # DeadlockDetector := Object clone DeadlockDetector init := method( self resources := Map clone self waitGraph := Map clone self ) DeadlockDetector requestResource := method(coroutine, resource, // Add to wait graph if(resources hasKey(resource), owner := resources at(resource) if(owner != coroutine, waitGraph atPut(coroutine, resource) // Check for cycle if(hasCycle(coroutine), Exception raise(\u0026quot;Deadlock detected!\u0026quot;) ) ) ) ) DeadlockDetector hasCycle := method(start, // Simplified cycle detection visited := list() current := start while(waitGraph hasKey(current), if(visited contains(current), return true) visited append(current) resource := waitGraph at(current) if(resources hasKey(resource), current = resources at(resource) , break ) ) false ) Event Loop # EventLoop := Object clone EventLoop init := method( self events := list() self running := true self ) EventLoop schedule := method(delay, block, events append(list(Date now + delay, block)) events sortInPlaceBy(block(e, e at(0))) ) EventLoop run := method( while(running and events size \u0026gt; 0, now := Date now while(events size \u0026gt; 0 and events first at(0) \u0026lt;= now, event := events removeFirst event at(1) @call ) if(events size \u0026gt; 0, wait((events first at(0) - now) max(0)) ) ) ) EventLoop stop := method(running = false) // Usage loop := EventLoop clone init loop schedule(0.1, block(\u0026quot;First\u0026quot; println)) loop schedule(0.2, block(\u0026quot;Second\u0026quot; println)) loop schedule(0.15, block(\u0026quot;Between\u0026quot; println)) loop run Common Patterns # Producer-Consumer # Buffer := Object clone Buffer init := method(capacity, self items := list() self capacity := capacity self notFull := Semaphore clone init(capacity) self notEmpty := Semaphore clone init(0) self mutex := Mutex clone self ) Buffer put := method(item, notFull acquire mutex synchronize(items append(item)) notEmpty release ) Buffer get := method( notEmpty acquire item := mutex synchronize(items removeFirst) notFull release item ) // Usage buffer := Buffer clone init(5) // Producer @( 10 repeat(i, (\u0026quot;Producing \u0026quot; .. i) println buffer put(i) wait(Random value * 0.1) ) ) // Consumer @( 10 repeat( item := buffer get (\u0026quot;Consumed \u0026quot; .. item) println wait(Random value * 0.2) ) ) wait(3) Fork-Join # Object forkJoin := method(tasks, futures := tasks map(task, @(task call) ) futures map(resolve) ) // Parallel quicksort quicksort := method(list, if(list size \u0026lt;= 1, return list) pivot := list at(list size / 2) results := forkJoin(list( block(list select(x, x \u0026lt; pivot) quicksort), block(list select(x, x == pivot)), block(list select(x, x \u0026gt; pivot) quicksort) )) results at(0) appendSeq(results at(1)) appendSeq(results at(2)) ) sorted := quicksort(list(3, 1, 4, 1, 5, 9, 2, 6)) sorted println // list(1, 1, 2, 3, 4, 5, 6, 9) Performance Considerations # // Coroutines are lightweight time( coroutines := list() 1000 repeat(i, coroutines append(@(i * i)) ) coroutines map(resolve) ) // But context switching has overhead benchmarkConcurrency := method(taskCount, taskWork, // Sequential seqTime := time( taskCount repeat(i, taskWork call(i)) ) // Concurrent concTime := time( futures := list() taskCount repeat(i, futures append(@(taskWork call(i))) ) futures map(resolve) ) (\u0026quot;Sequential: \u0026quot; .. seqTime) println (\u0026quot;Concurrent: \u0026quot; .. concTime) println (\u0026quot;Speedup: \u0026quot; .. (seqTime / concTime)) println ) // Light work - concurrency overhead dominates benchmarkConcurrency(100, block(i, i * i)) // Heavy work - concurrency helps benchmarkConcurrency(10, block(i, sum := 0 10000 repeat(j, sum = sum + j) sum )) Exercises # Rate Limiter: Implement a rate limiter that allows N operations per second.\nParallel Reduce: Create a parallel version of reduce that divides work among workers.\nActor Supervisor: Build a supervisor that restarts failed actors.\nCSP Channels: Implement Communicating Sequential Processes with select statement.\nSTM: Implement Software Transactional Memory for conflict-free concurrent updates.\nReal-World Example: Web Scraper # WebScraper := Object clone WebScraper init := method(maxConcurrent, self semaphore := Semaphore clone init(maxConcurrent) self visited := ConcurrentSet clone init self results := ConcurrentList clone self ) WebScraper scrape := method(urls, futures := list() urls foreach(url, if(visited contains(url) not, visited add(url) future := @( semaphore acquire e := try( (\u0026quot;Scraping \u0026quot; .. url) println // Simulate HTTP request wait(Random value) content := \u0026quot;Content from \u0026quot; .. url results append(Map with(\u0026quot;url\u0026quot;, url, \u0026quot;content\u0026quot;, content)) // Find more URLs (simplified) if(Random value \u0026lt; 0.3, newUrl := url .. \u0026quot;/\u0026quot; .. Random value round self scrape(list(newUrl)) ) ) semaphore release if(e, (\u0026quot;Error scraping \u0026quot; .. url .. \u0026quot;: \u0026quot; .. e message) println) ) futures append(future) ) ) futures map(resolve) self ) // Usage scraper := WebScraper clone init(3) scraper scrape(list( \u0026quot;https://example.com\u0026quot;, \u0026quot;https://example.org\u0026quot;, \u0026quot;https://example.net\u0026quot; )) wait(2) (\u0026quot;Scraped \u0026quot; .. scraper results size .. \u0026quot; pages\u0026quot;) println Conclusion # Io\u0026rsquo;s concurrency model, built on coroutines, actors, and futures, provides powerful abstractions for concurrent programming. The cooperative nature of coroutines gives you fine control over scheduling, while actors provide isolation and message-passing safety. Futures enable asynchronous programming patterns familiar from other languages.\nThe beauty of Io\u0026rsquo;s approach is that these concurrency primitives are implemented using the same object model as everything else. Coroutines are objects, messages can be sent asynchronously with @, and synchronization primitives can be built from basic objects and messages. This consistency makes concurrent programming in Io both powerful and comprehensible.\nNext: Chapter 13 - Domain-Specific Languages\n"},{"id":15,"href":"/docs/13-domain-specific-languages/","title":"Domain-Specific Languages","section":"Chapters","content":" Chapter 13: Domain-Specific Languages # Io\u0026rsquo;s minimal syntax, message-passing model, and metaprogramming capabilities make it ideal for creating Domain-Specific Languages (DSLs). This chapter explores how to build expressive DSLs that feel native to their problem domains.\nWhy Io Excels at DSLs # Several features make Io particularly suitable for DSLs:\nMinimal syntax - Less language machinery to work around Optional parentheses - Clean, readable DSL code Message chains - Natural expression of domain concepts Runtime flexibility - Modify behavior on the fly Homoiconicity - Code as manipulable data Compare a hypothetical DSL in Io vs Ruby:\n// Io DSL - clean, minimal recipe \u0026quot;Chocolate Cake\u0026quot; makes(8) servings { ingredient \u0026quot;flour\u0026quot; amount(2) cups ingredient \u0026quot;sugar\u0026quot; amount(1.5) cups step \u0026quot;Mix dry ingredients\u0026quot; step \u0026quot;Add wet ingredients\u0026quot; bake at(350) degrees for(30) minutes } # Ruby DSL - more syntax artifacts recipe \u0026quot;Chocolate Cake\u0026quot; do makes 8.servings ingredient \u0026quot;flour\u0026quot;, amount: 2.cups ingredient \u0026quot;sugar\u0026quot;, amount: 1.5.cups step \u0026quot;Mix dry ingredients\u0026quot; step \u0026quot;Add wet ingredients\u0026quot; bake at: 350.degrees, for: 30.minutes end Building Your First DSL # Let\u0026rsquo;s create a simple configuration DSL:\n// Define the DSL Config := Object clone Config settings := Map clone Config set := method(key, value, settings atPut(key asString, value) self // For chaining ) Config get := method(key, settings at(key asString) ) Config section := method(name, sec := Config clone settings atPut(name asString, sec) sec ) // Use the DSL config := Config clone config set(\u0026quot;host\u0026quot;, \u0026quot;localhost\u0026quot;) \\ set(\u0026quot;port\u0026quot;, 8080) \\ section(\u0026quot;database\u0026quot;) \\ set(\u0026quot;driver\u0026quot;, \u0026quot;postgresql\u0026quot;) \\ set(\u0026quot;name\u0026quot;, \u0026quot;myapp\u0026quot;) config get(\u0026quot;host\u0026quot;) println // localhost config get(\u0026quot;database\u0026quot;) get(\u0026quot;driver\u0026quot;) println // postgresql HTML Builder DSL # A more complex example - generating HTML:\nHTML := Object clone // Handle any tag name via forward HTML forward := method( tagName := call message name attributes := Map clone children := list() // Process arguments call message arguments foreach(arg, argValue := call sender doMessage(arg) if(argValue type == \u0026quot;Map\u0026quot;, // It's attributes attributes = argValue , // It's content or children if(argValue type == \u0026quot;Sequence\u0026quot;, children append(argValue), if(argValue type == \u0026quot;List\u0026quot;, children appendSeq(argValue), children append(argValue asString) ) ) ) ) // Build HTML result := \u0026quot;\u0026lt;\u0026quot; .. tagName attributes foreach(key, value, result = result .. \u0026quot; \u0026quot; .. key .. \u0026quot;=\\\u0026quot;\u0026quot; .. value .. \u0026quot;\\\u0026quot;\u0026quot; ) if(children size == 0, result = result .. \u0026quot; /\u0026gt;\u0026quot;, result = result .. \u0026quot;\u0026gt;\u0026quot; children foreach(child, result = result .. child) result = result .. \u0026quot;\u0026lt;/\u0026quot; .. tagName .. \u0026quot;\u0026gt;\u0026quot; ) result ) // Helper for attributes Object attrs := method( args := call message arguments map := Map clone args foreach(arg, pair := arg name split(\u0026quot;:\u0026quot;) if(pair size == 2, map atPut(pair at(0), call sender doMessage(arg arguments at(0))) ) ) map ) // Usage html := HTML clone page := html div(attrs(class: \u0026quot;container\u0026quot;, id: \u0026quot;main\u0026quot;), html h1(\u0026quot;Welcome to My Site\u0026quot;), html p(attrs(class: \u0026quot;intro\u0026quot;), \u0026quot;This is a paragraph with \u0026quot;, html strong(\u0026quot;bold text\u0026quot;), \u0026quot; in it.\u0026quot; ), html ul( html li(\u0026quot;First item\u0026quot;), html li(\u0026quot;Second item\u0026quot;), html li(\u0026quot;Third item\u0026quot;) ) ) page println // \u0026lt;div class=\u0026quot;container\u0026quot; id=\u0026quot;main\u0026quot;\u0026gt;\u0026lt;h1\u0026gt;Welcome to My Site\u0026lt;/h1\u0026gt;... SQL Query Builder # Query := Object clone Query init := method( self selections := list(\u0026quot;*\u0026quot;) self tables := list() self conditions := list() self joins := list() self ) Query select := method( self selections = call message arguments map(arg, call sender doMessage(arg) asString ) self ) Query from := method(table, tables append(table) self ) Query where := method( condition := call argAt(0) conditions append(condition code asString) self ) Query join := method(table, on, joins append(\u0026quot;JOIN \u0026quot; .. table .. \u0026quot; ON \u0026quot; .. on code asString) self ) Query toSQL := method( sql := \u0026quot;SELECT \u0026quot; .. selections join(\u0026quot;, \u0026quot;) sql = sql .. \u0026quot; FROM \u0026quot; .. tables join(\u0026quot;, \u0026quot;) if(joins size \u0026gt; 0, sql = sql .. \u0026quot; \u0026quot; .. joins join(\u0026quot; \u0026quot;) ) if(conditions size \u0026gt; 0, sql = sql .. \u0026quot; WHERE \u0026quot; .. conditions join(\u0026quot; AND \u0026quot;) ) sql ) // Usage query := Query clone init sql := query select(\u0026quot;name\u0026quot;, \u0026quot;age\u0026quot;, \u0026quot;email\u0026quot;) \\ from(\u0026quot;users\u0026quot;) \\ join(\u0026quot;profiles\u0026quot;, users.id == profiles.user_id) \\ where(age \u0026gt; 18) \\ where(status == \u0026quot;active\u0026quot;) \\ toSQL sql println // SELECT name, age, email FROM users JOIN profiles ON users.id == profiles.user_id WHERE age \u0026gt; 18 AND status == \u0026quot;active\u0026quot; Unit Testing DSL # TestSuite := Object clone TestSuite tests := list() TestSuite currentTest := nil TestSuite describe := method(description, suite := TestSuite clone suite description := description suite tests = list() # Execute the test definition block call evalArgAt(1) suite ) TestSuite it := method(testName, test := Object clone test name := testName test block := call argAt(1) tests append(test) ) TestSuite before := method( self beforeBlock := call argAt(0) ) TestSuite after := method( self afterBlock := call argAt(0) ) TestSuite run := method( (\u0026quot;\\n\u0026quot; .. description) println (\u0026quot;=\u0026quot; repeated(description size)) println passed := 0 failed := 0 tests foreach(test, if(hasSlot(\u0026quot;beforeBlock\u0026quot;), beforeBlock doInContext(self)) e := try( test block doInContext(self) (\u0026quot;✓ \u0026quot; .. test name) println passed = passed + 1 ) catch(Exception, e, (\u0026quot;✗ \u0026quot; .. test name) println (\u0026quot; \u0026quot; .. e message) println failed = failed + 1 ) if(hasSlot(\u0026quot;afterBlock\u0026quot;), afterBlock doInContext(self)) ) (\u0026quot;\\nPassed: \u0026quot; .. passed .. \u0026quot;, Failed: \u0026quot; .. failed) println ) // Assertion helpers Object expect := method(actual, Expectation clone setActual(actual) ) Expectation := Object clone Expectation setActual := method(value, self actual := value self ) Expectation toBe := method(expected, if(actual != expected, Exception raise(\u0026quot;Expected \u0026quot; .. expected .. \u0026quot; but got \u0026quot; .. actual) ) ) Expectation toEqual := method(expected, if(actual != expected, Exception raise(\u0026quot;Expected \u0026quot; .. expected .. \u0026quot; but got \u0026quot; .. actual) ) ) Expectation toContain := method(item, if(actual contains(item) not, Exception raise(\u0026quot;Expected \u0026quot; .. actual .. \u0026quot; to contain \u0026quot; .. item) ) ) // Usage MathTests := describe(\u0026quot;Math operations\u0026quot;, before( self calculator := Object clone calculator add := method(a, b, a + b) calculator multiply := method(a, b, a * b) ) it(\u0026quot;should add numbers correctly\u0026quot;, expect(calculator add(2, 3)) toBe(5) expect(calculator add(-1, 1)) toBe(0) ) it(\u0026quot;should multiply numbers correctly\u0026quot;, expect(calculator multiply(3, 4)) toBe(12) expect(calculator multiply(0, 5)) toBe(0) ) it(\u0026quot;should handle edge cases\u0026quot;, expect(calculator add(0, 0)) toBe(0) ) ) MathTests run State Machine DSL # StateMachine := Object clone StateMachine states := Map clone StateMachine currentState := nil StateMachine initialState := nil StateMachine state := method(name, s := State clone s name := name s machine := self states atPut(name, s) if(initialState isNil, initialState = s) s ) State := Object clone State transitions := Map clone State on := method(event, targetState, transitions atPut(event, targetState) self ) State enter := method( self enterBlock := call argAt(0) self ) State exit := method( self exitBlock := call argAt(0) self ) StateMachine start := method( currentState = initialState if(currentState hasSlot(\u0026quot;enterBlock\u0026quot;), currentState enterBlock call ) ) StateMachine trigger := method(event, if(currentState transitions hasKey(event), nextStateName := currentState transitions at(event) nextState := states at(nextStateName) if(currentState hasSlot(\u0026quot;exitBlock\u0026quot;), currentState exitBlock call ) (\u0026quot;Transitioning from \u0026quot; .. currentState name .. \u0026quot; to \u0026quot; .. nextStateName) println currentState = nextState if(currentState hasSlot(\u0026quot;enterBlock\u0026quot;), currentState enterBlock call ) , (\u0026quot;No transition for event '\u0026quot; .. event .. \u0026quot;' from state '\u0026quot; .. currentState name .. \u0026quot;'\u0026quot;) println ) ) // Usage door := StateMachine clone door state(\u0026quot;closed\u0026quot;) \\ on(\u0026quot;open\u0026quot;, \u0026quot;opened\u0026quot;) \\ on(\u0026quot;lock\u0026quot;, \u0026quot;locked\u0026quot;) \\ enter(block(\u0026quot;Door is now closed\u0026quot; println)) door state(\u0026quot;opened\u0026quot;) \\ on(\u0026quot;close\u0026quot;, \u0026quot;closed\u0026quot;) \\ enter(block(\u0026quot;Door is now open\u0026quot; println)) door state(\u0026quot;locked\u0026quot;) \\ on(\u0026quot;unlock\u0026quot;, \u0026quot;closed\u0026quot;) \\ enter(block(\u0026quot;Door is now locked\u0026quot; println)) door start door trigger(\u0026quot;open\u0026quot;) // Transitioning from closed to opened door trigger(\u0026quot;close\u0026quot;) // Transitioning from opened to closed door trigger(\u0026quot;lock\u0026quot;) // Transitioning from closed to locked door trigger(\u0026quot;open\u0026quot;) // No transition for event 'open' from state 'locked' Routing DSL (Web Framework Style) # Router := Object clone Router routes := list() Router get := method(path, addRoute(\u0026quot;GET\u0026quot;, path, call argAt(1)) ) Router post := method(path, addRoute(\u0026quot;POST\u0026quot;, path, call argAt(1)) ) Router put := method(path, addRoute(\u0026quot;PUT\u0026quot;, path, call argAt(1)) ) Router delete := method(path, addRoute(\u0026quot;DELETE\u0026quot;, path, call argAt(1)) ) Router addRoute := method(method, path, handler, routes append(Map with( \u0026quot;method\u0026quot;, method, \u0026quot;path\u0026quot;, path, \u0026quot;pattern\u0026quot;, pathToRegex(path), \u0026quot;handler\u0026quot;, handler )) self ) Router pathToRegex := method(path, // Convert :param to regex groups pattern := path pattern = pattern replaceAllRegex(\u0026quot;:([^/]+)\u0026quot;, \u0026quot;([^/]+)\u0026quot;) \u0026quot;^\u0026quot; .. pattern .. \u0026quot;$\u0026quot; ) Router handle := method(method, path, routes foreach(route, if(route at(\u0026quot;method\u0026quot;) == method, match := path matchesRegex(route at(\u0026quot;pattern\u0026quot;)) if(match, params := extractParams(route at(\u0026quot;path\u0026quot;), path, match) return route at(\u0026quot;handler\u0026quot;) call(params) ) ) ) Map with(\u0026quot;status\u0026quot;, 404, \u0026quot;body\u0026quot;, \u0026quot;Not Found\u0026quot;) ) Router extractParams := method(pattern, path, match, params := Map clone // Extract named parameters names := pattern allMatchesOfRegex(\u0026quot;:([^/]+)\u0026quot;) map(m, m at(1)) names foreach(i, name, params atPut(name, match at(i + 1)) ) params ) // Usage app := Router clone app get(\u0026quot;/\u0026quot;, block(params, Map with(\u0026quot;status\u0026quot;, 200, \u0026quot;body\u0026quot;, \u0026quot;Welcome to the home page\u0026quot;) )) app get(\u0026quot;/users/:id\u0026quot;, block(params, Map with(\u0026quot;status\u0026quot;, 200, \u0026quot;body\u0026quot;, \u0026quot;User \u0026quot; .. params at(\u0026quot;id\u0026quot;)) )) app post(\u0026quot;/users\u0026quot;, block(params, Map with(\u0026quot;status\u0026quot;, 201, \u0026quot;body\u0026quot;, \u0026quot;User created\u0026quot;) )) // Simulate requests app handle(\u0026quot;GET\u0026quot;, \u0026quot;/\u0026quot;) at(\u0026quot;body\u0026quot;) println // Welcome to the home page app handle(\u0026quot;GET\u0026quot;, \u0026quot;/users/123\u0026quot;) at(\u0026quot;body\u0026quot;) println // User 123 app handle(\u0026quot;POST\u0026quot;, \u0026quot;/users\u0026quot;) at(\u0026quot;body\u0026quot;) println // User created app handle(\u0026quot;GET\u0026quot;, \u0026quot;/unknown\u0026quot;) at(\u0026quot;body\u0026quot;) println // Not Found Data Validation DSL # Validator := Object clone Validator field := method(name, f := Field clone f name := name f rules := list() self currentField := f f ) Field := Object clone Field required := method( rules append(block(value, if(value isNil or value == \u0026quot;\u0026quot;, Exception raise(name .. \u0026quot; is required\u0026quot;), true ) )) self ) Field minLength := method(min, rules append(block(value, if(value size \u0026lt; min, Exception raise(name .. \u0026quot; must be at least \u0026quot; .. min .. \u0026quot; characters\u0026quot;), true ) )) self ) Field maxLength := method(max, rules append(block(value, if(value size \u0026gt; max, Exception raise(name .. \u0026quot; must be at most \u0026quot; .. max .. \u0026quot; characters\u0026quot;), true ) )) self ) Field matches := method(regex, rules append(block(value, if(value matchesRegex(regex) not, Exception raise(name .. \u0026quot; has invalid format\u0026quot;), true ) )) self ) Field validate := method(value, rules foreach(rule, rule call(value) ) true ) // Usage userValidator := Validator clone username := userValidator field(\u0026quot;username\u0026quot;) \\ required \\ minLength(3) \\ maxLength(20) \\ matches(\u0026quot;^[a-zA-Z0-9_]+$\u0026quot;) email := userValidator field(\u0026quot;email\u0026quot;) \\ required \\ matches(\u0026quot;^[^@]+@[^@]+\\\\.[^@]+$\u0026quot;) // Test validation try( username validate(\u0026quot;ab\u0026quot;) ) catch(Exception, e, e message println // username must be at least 3 characters ) try( email validate(\u0026quot;not-an-email\u0026quot;) ) catch(Exception, e, e message println // email has invalid format ) username validate(\u0026quot;valid_user123\u0026quot;) println // true email validate(\u0026quot;user@example.com\u0026quot;) println // true DSL Best Practices # 1. Natural Language Flow # // Good - reads naturally recipe needs(2) cups of(\u0026quot;flour\u0026quot;) order shipping priority within(3) days // Bad - programmer-centric recipe setAmount(2) setUnit(\u0026quot;cups\u0026quot;) setIngredient(\u0026quot;flour\u0026quot;) order setShipping(\u0026quot;priority\u0026quot;) setDeliveryDays(3) 2. Method Chaining # // Enable fluent interfaces Object withChaining := method( call message arguments foreach(arg, slotName := arg name self setSlot(slotName, call evalArgAt(0)) ) self // Always return self ) Person := Object clone Person configure := method( withChaining( name(n, self name := n), age(a, self age := a), email(e, self email := e) ) ) person := Person clone configure \\ name(\u0026quot;Alice\u0026quot;) \\ age(30) \\ email(\u0026quot;alice@example.com\u0026quot;) 3. Context Management # DSLContext := Object clone DSLContext stack := list() DSLContext push := method(obj, stack append(obj) ) DSLContext pop := method( stack pop ) DSLContext current := method( stack last ) DSLContext with := method(obj, block, push(obj) e := try(result := block call) pop if(e, e raise, result) ) // Usage in DSL Form := Object clone Form fields := list() Form field := method(name, f := Field clone f name := name DSLContext with(f, call evalArgAt(1) ) fields append(f) ) Field label := method(text, DSLContext current label := text ) Exercises # CSS DSL: Create a DSL for generating CSS with nested rules and variables.\nGraph Description Language: Build a DSL for describing graphs and their relationships.\nBuild System DSL: Implement a make/rake-like build system DSL.\nBDD Testing DSL: Create a Behavior-Driven Development testing framework.\nConfiguration Management: Build a DSL for system configuration management.\nReal-World Example: Migration DSL # Migration := Object clone Migration changes := list() Migration createTable := method(name, table := TableDefinition clone table name := name table columns := list() call evalArgAt(1) changes append(Map with( \u0026quot;type\u0026quot;, \u0026quot;createTable\u0026quot;, \u0026quot;table\u0026quot;, table )) self ) Migration dropTable := method(name, changes append(Map with( \u0026quot;type\u0026quot;, \u0026quot;dropTable\u0026quot;, \u0026quot;name\u0026quot;, name )) self ) TableDefinition := Object clone TableDefinition column := method(name, type, columns append(Map with( \u0026quot;name\u0026quot;, name, \u0026quot;type\u0026quot;, type, \u0026quot;constraints\u0026quot;, list() )) self ) TableDefinition primaryKey := method(col, columns last at(\u0026quot;constraints\u0026quot;) append(\u0026quot;PRIMARY KEY\u0026quot;) self ) TableDefinition notNull := method( columns last at(\u0026quot;constraints\u0026quot;) append(\u0026quot;NOT NULL\u0026quot;) self ) TableDefinition unique := method( columns last at(\u0026quot;constraints\u0026quot;) append(\u0026quot;UNIQUE\u0026quot;) self ) Migration toSQL := method( sql := list() changes foreach(change, if(change at(\u0026quot;type\u0026quot;) == \u0026quot;createTable\u0026quot;, table := change at(\u0026quot;table\u0026quot;) stmt := \u0026quot;CREATE TABLE \u0026quot; .. table name .. \u0026quot; (\\n\u0026quot; cols := table columns map(col, \u0026quot; \u0026quot; .. col at(\u0026quot;name\u0026quot;) .. \u0026quot; \u0026quot; .. col at(\u0026quot;type\u0026quot;) .. if(col at(\u0026quot;constraints\u0026quot;) size \u0026gt; 0, \u0026quot; \u0026quot; .. col at(\u0026quot;constraints\u0026quot;) join(\u0026quot; \u0026quot;), \u0026quot;\u0026quot; ) ) stmt = stmt .. cols join(\u0026quot;,\\n\u0026quot;) .. \u0026quot;\\n);\u0026quot; sql append(stmt) ) if(change at(\u0026quot;type\u0026quot;) == \u0026quot;dropTable\u0026quot;, sql append(\u0026quot;DROP TABLE \u0026quot; .. change at(\u0026quot;name\u0026quot;) .. \u0026quot;;\u0026quot;) ) ) sql join(\u0026quot;\\n\\n\u0026quot;) ) // Usage migration := Migration clone migration createTable(\u0026quot;users\u0026quot;, column(\u0026quot;id\u0026quot;, \u0026quot;INTEGER\u0026quot;) primaryKey, column(\u0026quot;username\u0026quot;, \u0026quot;VARCHAR(50)\u0026quot;) notNull unique, column(\u0026quot;email\u0026quot;, \u0026quot;VARCHAR(100)\u0026quot;) notNull unique, column(\u0026quot;created_at\u0026quot;, \u0026quot;TIMESTAMP\u0026quot;) notNull ) migration createTable(\u0026quot;posts\u0026quot;, column(\u0026quot;id\u0026quot;, \u0026quot;INTEGER\u0026quot;) primaryKey, column(\u0026quot;user_id\u0026quot;, \u0026quot;INTEGER\u0026quot;) notNull, column(\u0026quot;title\u0026quot;, \u0026quot;VARCHAR(200)\u0026quot;) notNull, column(\u0026quot;content\u0026quot;, \u0026quot;TEXT\u0026quot;), column(\u0026quot;published_at\u0026quot;, \u0026quot;TIMESTAMP\u0026quot;) ) migration toSQL println Conclusion # Domain-Specific Languages in Io demonstrate the language\u0026rsquo;s expressive power. By leveraging message passing, optional parentheses, method chaining, and metaprogramming, you can create DSLs that feel natural to domain experts while remaining fully integrated with the host language.\nThe key to successful DSLs in Io is understanding that you\u0026rsquo;re not fighting against language syntax—you\u0026rsquo;re working with it. Messages become domain commands, objects become domain concepts, and the minimal syntax stays out of your way. This makes Io ideal for creating internal DSLs that are both powerful and readable.\nNext: Chapter 14 - C Integration\n"},{"id":16,"href":"/docs/14-c-integration/","title":"C Integration","section":"Chapters","content":" Chapter 14: C Integration # Io is implemented in C and provides excellent C integration capabilities. You can extend Io with C libraries, create high-performance addons, and embed Io in C applications. This chapter explores the bidirectional relationship between Io and C.\nUnderstanding Io\u0026rsquo;s C Architecture # Io\u0026rsquo;s core is a small C library (around 10,000 lines) that implements:\nThe object model (IoObject) The message passing system Basic types (Number, String, List, etc.) The VM and garbage collector Everything else is built on top of this foundation, either in C addons or pure Io.\nCreating a Simple C Addon # Let\u0026rsquo;s create a basic C addon that adds a method to calculate factorials:\n// factorial.c #include \u0026quot;IoState.h\u0026quot; #include \u0026quot;IoObject.h\u0026quot; #include \u0026quot;IoNumber.h\u0026quot; IoObject *IoObject_factorial(IoObject *self, IoObject *locals, IoMessage *m) { // Get the number from the receiver double n = IoNumber_asDouble(self); if (n \u0026lt; 0) { IoState_error_(IOSTATE, m, \u0026quot;factorial of negative number\u0026quot;); return IONIL(self); } double result = 1; for (int i = 2; i \u0026lt;= n; i++) { result *= i; } return IoNumber_newWithDouble_(IOSTATE, result); } // Initialize the addon void IoFactorial_init(IoState *state) { IoObject *self = IoState_lobby(state); // Add method to Number prototype IoObject *number = IoState_protoWithName_(state, \u0026quot;Number\u0026quot;); IoObject_addMethod_(number, IOSYMBOL(\u0026quot;factorial\u0026quot;), IoObject_factorial); } To compile and use:\n# Compile as shared library gcc -shared -fPIC -o factorial.so factorial.c -lIo # In Io DynLib load(\u0026quot;./factorial.so\u0026quot;) 5 factorial println // 120 Working with Io Objects in C # // Creating Io objects from C IoObject *IoAddon_createObject(IoObject *self, IoObject *locals, IoMessage *m) { IoState *state = IOSTATE; // Create different types IoObject *num = IoNumber_newWithDouble_(state, 42.0); IoObject *str = IoSeq_newWithCString_(state, \u0026quot;Hello from C\u0026quot;); IoObject *list = IoList_new(state); // Add items to list IoList_append_(list, num); IoList_append_(list, str); // Create a new object with slots IoObject *obj = IoObject_new(state); IoObject_setSlot_to_(obj, IOSYMBOL(\u0026quot;x\u0026quot;), num); IoObject_setSlot_to_(obj, IOSYMBOL(\u0026quot;message\u0026quot;), str); IoObject_setSlot_to_(obj, IOSYMBOL(\u0026quot;items\u0026quot;), list); return obj; } // Accessing Io objects from C IoObject *IoAddon_processObject(IoObject *self, IoObject *locals, IoMessage *m) { // Get the first argument IoObject *arg = IoMessage_locals_valueArgAt_(m, locals, 0); // Check type if (ISSEQ(arg)) { char *cstr = IoSeq_asCString(arg); printf(\u0026quot;String argument: %s\\n\u0026quot;, cstr); } else if (ISNUMBER(arg)) { double num = IoNumber_asDouble(arg); printf(\u0026quot;Number argument: %f\\n\u0026quot;, num); } else if (ISLIST(arg)) { size_t size = IoList_size(arg); printf(\u0026quot;List with %zu items\\n\u0026quot;, size); } return self; } Creating Custom Types # // customtype.c - Define a Point type #include \u0026quot;IoState.h\u0026quot; #include \u0026quot;IoObject.h\u0026quot; #include \u0026quot;IoNumber.h\u0026quot; // Define the type structure typedef struct { IoObject obj; // Must be first double x; double y; } IoPoint; // Type tag IoTag *IoPoint_tag(void) { static IoTag *tag = NULL; if (!tag) { tag = IoTag_newWithName_(\u0026quot;Point\u0026quot;); } return tag; } // Constructor IoPoint *IoPoint_new(IoState *state, double x, double y) { IoPoint *self = IoObject_new(state); IoObject_tag_(self, IoPoint_tag()); self-\u0026gt;x = x; self-\u0026gt;y = y; return self; } // Methods IoObject *IoPoint_x(IoPoint *self, IoObject *locals, IoMessage *m) { return IoNumber_newWithDouble_(IOSTATE, self-\u0026gt;x); } IoObject *IoPoint_y(IoPoint *self, IoObject *locals, IoMessage *m) { return IoNumber_newWithDouble_(IOSTATE, self-\u0026gt;y); } IoObject *IoPoint_distance(IoPoint *self, IoObject *locals, IoMessage *m) { IoPoint *other = IoMessage_locals_valueArgAt_(m, locals, 0); if (IoObject_tag(other) != IoPoint_tag()) { IoState_error_(IOSTATE, m, \u0026quot;argument must be a Point\u0026quot;); return IONIL(self); } double dx = self-\u0026gt;x - other-\u0026gt;x; double dy = self-\u0026gt;y - other-\u0026gt;y; double distance = sqrt(dx*dx + dy*dy); return IoNumber_newWithDouble_(IOSTATE, distance); } // Initialize the type void IoPoint_init(IoState *state) { IoObject *self = IoState_lobby(state); // Create prototype IoPoint *proto = IoPoint_new(state, 0, 0); IoState_registerProtoWithName_(state, proto, \u0026quot;Point\u0026quot;); // Add methods IoObject_addMethod_(proto, IOSYMBOL(\u0026quot;x\u0026quot;), IoPoint_x); IoObject_addMethod_(proto, IOSYMBOL(\u0026quot;y\u0026quot;), IoPoint_y); IoObject_addMethod_(proto, IOSYMBOL(\u0026quot;distance\u0026quot;), IoPoint_distance); } Calling Io from C # // Evaluate Io code from C IoObject *result = IoState_doString_(state, \u0026quot;1 + 2 * 3\u0026quot;); double value = IoNumber_asDouble(result); printf(\u0026quot;Result: %f\\n\u0026quot;, value); // 7.0 // Call Io methods from C IoObject *obj = IoState_doString_(state, \u0026quot;Object clone\u0026quot;); IoObject *method = IoObject_getSlot_(obj, IOSYMBOL(\u0026quot;type\u0026quot;)); IoObject *result = IoObject_activate(method, obj, locals, m, NULL); char *type = IoSeq_asCString(result); printf(\u0026quot;Type: %s\\n\u0026quot;, type); // Object // Send messages IoMessage *msg = IoMessage_newWithName_(state, IOSYMBOL(\u0026quot;println\u0026quot;)); IoMessage_setCachedResult_(msg, NULL); IoObject *result = IoObject_perform(obj, locals, msg); Memory Management # Io uses a garbage collector, but when interfacing with C, you need to be careful:\n// Protecting objects from GC IoObject *IoAddon_keepAlive(IoObject *self, IoObject *locals, IoMessage *m) { IoState *state = IOSTATE; // Create object that needs to survive GC IoObject *important = IoObject_new(state); // Add reference from a persistent object IoObject_setSlot_to_(IoState_lobby(state), IOSYMBOL(\u0026quot;_keepAlive\u0026quot;), important); // Or use IoState_retain/release IoState_retain_(state, important); // Do work... // Release when done IoState_release_(state, important); return important; } // Managing C memory typedef struct { IoObject obj; void *cdata; } IoCWrapper; void IoCWrapper_free(IoCWrapper *self) { if (self-\u0026gt;cdata) { free(self-\u0026gt;cdata); self-\u0026gt;cdata = NULL; } } // Set up finalizer IoTag *tag = IoTag_newWithName_(\u0026quot;CWrapper\u0026quot;); IoTag_freeFunc_(tag, (IoTagFreeFunc *)IoCWrapper_free); Wrapping C Libraries # Example: Wrapping a simple math library:\n// mathlib_wrapper.c #include \u0026lt;math.h\u0026gt; #include \u0026quot;IoState.h\u0026quot; #include \u0026quot;IoObject.h\u0026quot; #include \u0026quot;IoNumber.h\u0026quot; #include \u0026quot;IoList.h\u0026quot; // Wrap sin function IoObject *IoMath_sin(IoObject *self, IoObject *locals, IoMessage *m) { double x = IoMessage_locals_doubleArgAt_(m, locals, 0); return IoNumber_newWithDouble_(IOSTATE, sin(x)); } // Wrap complex function IoObject *IoMath_stats(IoObject *self, IoObject *locals, IoMessage *m) { IoList *list = IoMessage_locals_listArgAt_(m, locals, 0); size_t count = IoList_size(list); if (count == 0) { return IoList_new(IOSTATE); } double sum = 0, min = INFINITY, max = -INFINITY; for (size_t i = 0; i \u0026lt; count; i++) { IoObject *item = IoList_at_(list, i); double value = IoNumber_asDouble(item); sum += value; if (value \u0026lt; min) min = value; if (value \u0026gt; max) max = value; } double mean = sum / count; // Return statistics as list IoList *result = IoList_new(IOSTATE); IoList_append_(result, IoNumber_newWithDouble_(IOSTATE, mean)); IoList_append_(result, IoNumber_newWithDouble_(IOSTATE, min)); IoList_append_(result, IoNumber_newWithDouble_(IOSTATE, max)); return result; } void IoMathLib_init(IoState *state) { IoObject *math = IoObject_new(state); IoState_registerProtoWithName_(state, math, \u0026quot;Math\u0026quot;); IoObject_addMethod_(math, IOSYMBOL(\u0026quot;sin\u0026quot;), IoMath_sin); IoObject_addMethod_(math, IOSYMBOL(\u0026quot;stats\u0026quot;), IoMath_stats); } Usage in Io:\nDynLib load(\u0026quot;./mathlib.so\u0026quot;) Math sin(3.14159 / 2) println // 1.0 stats := Math stats(list(1, 2, 3, 4, 5)) \u0026quot;Mean: \u0026quot; .. stats at(0) println // Mean: 3 \u0026quot;Min: \u0026quot; .. stats at(1) println // Min: 1 \u0026quot;Max: \u0026quot; .. stats at(2) println // Max: 5 Embedding Io in C Applications # // embed_io.c - Embedding Io in a C application #include \u0026lt;stdio.h\u0026gt; #include \u0026quot;IoState.h\u0026quot; #include \u0026quot;IoObject.h\u0026quot; #include \u0026quot;IoSeq.h\u0026quot; // Custom function exposed to Io IoObject *App_log(IoObject *self, IoObject *locals, IoMessage *m) { char *msg = IoMessage_locals_cStringArgAt_(m, locals, 0); printf(\u0026quot;[APP LOG] %s\\n\u0026quot;, msg); return self; } int main(int argc, char *argv[]) { // Initialize Io IoState *state = IoState_new(); IoState_init(state); // Add custom functions IoObject *lobby = IoState_lobby(state); IoObject *app = IoObject_new(state); IoState_registerProtoWithName_(state, app, \u0026quot;App\u0026quot;); IoObject_addMethod_(app, IOSYMBOL(\u0026quot;log\u0026quot;), App_log); // Load and run Io script IoState_doFile_(state, \u0026quot;script.io\u0026quot;); // Interact with Io objects IoObject *result = IoState_doString_(state, \u0026quot;x := 10; y := 20; x + y\u0026quot;); printf(\u0026quot;Result from Io: %f\\n\u0026quot;, IoNumber_asDouble(result)); // Clean up IoState_free(state); return 0; } The Io script (script.io):\nApp log(\u0026quot;Hello from Io!\u0026quot;) // Define functions for C to call calculate := method(a, b, App log(\u0026quot;Calculating in Io\u0026quot;) a * b + 100 ) Performance Optimization # // Optimized array operations IoObject *IoArray_sum(IoObject *self, IoObject *locals, IoMessage *m) { // Get underlying C array for performance UArray *array = IoSeq_rawUArray(self); size_t size = UArray_size(array); uint8_t *data = UArray_bytes(array); int itemSize = UArray_itemSize(array); double sum = 0; // Fast path for different types if (itemSize == sizeof(double)) { double *doubles = (double *)data; for (size_t i = 0; i \u0026lt; size; i++) { sum += doubles[i]; } } else if (itemSize == sizeof(float)) { float *floats = (float *)data; for (size_t i = 0; i \u0026lt; size; i++) { sum += floats[i]; } } return IoNumber_newWithDouble_(IOSTATE, sum); } // Batch operations IoObject *IoMatrix_multiply(IoObject *self, IoObject *locals, IoMessage *m) { IoObject *other = IoMessage_locals_valueArgAt_(m, locals, 0); // Get dimensions int rows1 = IoMessage_locals_intArgAt_(m, locals, 1); int cols1 = IoMessage_locals_intArgAt_(m, locals, 2); int cols2 = IoMessage_locals_intArgAt_(m, locals, 3); // Get raw data pointers double *data1 = (double *)IoSeq_rawBytes(self); double *data2 = (double *)IoSeq_rawBytes(other); // Allocate result IoSeq *result = IoSeq_newWithData_length_(IOSTATE, NULL, rows1 * cols2 * sizeof(double)); double *resultData = (double *)IoSeq_rawBytes(result); // Optimized matrix multiplication for (int i = 0; i \u0026lt; rows1; i++) { for (int j = 0; j \u0026lt; cols2; j++) { double sum = 0; for (int k = 0; k \u0026lt; cols1; k++) { sum += data1[i * cols1 + k] * data2[k * cols2 + j]; } resultData[i * cols2 + j] = sum; } } return result; } Debugging C Addons # // Debug helpers #define IO_DEBUG 1 #ifdef IO_DEBUG #define DEBUG_PRINT(fmt, ...) \\ fprintf(stderr, \u0026quot;DEBUG: \u0026quot; fmt \u0026quot;\\n\u0026quot;, ##__VA_ARGS__) #else #define DEBUG_PRINT(fmt, ...) #endif IoObject *IoDebug_function(IoObject *self, IoObject *locals, IoMessage *m) { DEBUG_PRINT(\u0026quot;Function called with %d arguments\u0026quot;, IoMessage_argCount(m)); // Print argument types for (int i = 0; i \u0026lt; IoMessage_argCount(m); i++) { IoObject *arg = IoMessage_locals_valueArgAt_(m, locals, i); DEBUG_PRINT(\u0026quot; Arg %d: %s\u0026quot;, i, IoObject_name(arg)); } // Check for memory issues IoState *state = IOSTATE; IoState_check(state); return self; } Common Integration Patterns # Callback Pattern # // Store Io blocks as callbacks typedef struct { IoObject obj; IoObject *callback; } IoCallbackWrapper; IoObject *IoWrapper_setCallback(IoCallbackWrapper *self, IoObject *locals, IoMessage *m) { IoObject *block = IoMessage_locals_valueArgAt_(m, locals, 0); // Retain the block IoState_retain_(IOSTATE, block); if (self-\u0026gt;callback) { IoState_release_(IOSTATE, self-\u0026gt;callback); } self-\u0026gt;callback = block; return self; } // Call the Io callback from C void triggerCallback(IoCallbackWrapper *wrapper, double value) { if (wrapper-\u0026gt;callback) { IoObject *arg = IoNumber_newWithDouble_(IOSTATE, value); IoObject_perform(wrapper-\u0026gt;callback, wrapper, IoMessage_newWithName_label_(IOSTATE, IOSYMBOL(\u0026quot;call\u0026quot;), arg)); } } Event System # // Event emitter in C typedef struct { IoObject obj; IoMap *handlers; // Event name -\u0026gt; List of handlers } IoEventEmitter; IoObject *IoEventEmitter_on(IoEventEmitter *self, IoObject *locals, IoMessage *m) { IoSeq *event = IoMessage_locals_seqArgAt_(m, locals, 0); IoObject *handler = IoMessage_locals_valueArgAt_(m, locals, 1); IoList *handlers = IoMap_at_(self-\u0026gt;handlers, event); if (!handlers) { handlers = IoList_new(IOSTATE); IoMap_atPut_(self-\u0026gt;handlers, event, handlers); } IoList_append_(handlers, handler); return self; } IoObject *IoEventEmitter_emit(IoEventEmitter *self, IoObject *locals, IoMessage *m) { IoSeq *event = IoMessage_locals_seqArgAt_(m, locals, 0); IoList *handlers = IoMap_at_(self-\u0026gt;handlers, event); if (handlers) { size_t count = IoList_size(handlers); for (size_t i = 0; i \u0026lt; count; i++) { IoObject *handler = IoList_at_(handlers, i); // Pass remaining arguments to handler IoMessage *msg = IoMessage_newWithName_(IOSTATE, IOSYMBOL(\u0026quot;call\u0026quot;)); for (int j = 1; j \u0026lt; IoMessage_argCount(m); j++) { IoMessage_addArg_(msg, IoMessage_argAt_(m, j)); } IoObject_perform(handler, locals, msg); } } return self; } Build System Integration # Makefile for Io addon:\n# Makefile for Io addon CC = gcc CFLAGS = -shared -fPIC -Wall -O2 INCLUDES = -I$(IO_HOME)/include LIBS = -L$(IO_HOME)/lib -lIo ADDON = myaddon.so SOURCES = myaddon.c utils.c OBJECTS = $(SOURCES:.c=.o) all: $(ADDON) $(ADDON): $(OBJECTS) $(CC) $(CFLAGS) -o $@ $^ $(LIBS) %.o: %.c $(CC) $(CFLAGS) $(INCLUDES) -c $\u0026lt; -o $@ clean: rm -f $(OBJECTS) $(ADDON) install: $(ADDON) cp $(ADDON) $(IO_HOME)/addons/ test: $(ADDON) io test_addon.io Exercises # SQLite Wrapper: Create a complete SQLite wrapper for Io.\nGraphics Library: Wrap SDL or Cairo for graphics programming.\nNetwork Addon: Implement high-performance networking primitives.\nCrypto Library: Wrap OpenSSL for cryptographic operations.\nScientific Computing: Create bindings for BLAS/LAPACK.\nConclusion # C integration is one of Io\u0026rsquo;s strongest features. The ability to seamlessly extend Io with C libraries, create high-performance addons, and embed Io in C applications makes it practical for real-world applications. The clean C API and simple object model make integration straightforward, while the garbage collector handles most memory management concerns.\nWhether you\u0026rsquo;re optimizing hot paths, wrapping existing libraries, or embedding a scripting language in your application, Io\u0026rsquo;s C integration provides the tools you need while maintaining the simplicity and elegance of the language.\nNext: Chapter 15 - Real-World Patterns\n"},{"id":17,"href":"/docs/15-real-world-patterns/","title":"Real-World Patterns","section":"Chapters","content":" Chapter 15: Real-World Patterns # After exploring Io\u0026rsquo;s features in isolation, this chapter brings everything together by examining patterns and architectures for building real applications. We\u0026rsquo;ll see how Io\u0026rsquo;s unique features enable elegant solutions to common programming challenges.\nModel-View-Controller (MVC) # Implementing MVC in Io leverages prototypes and message passing:\n// Model Model := Object clone Model init := method( self observers := list() self data := Map clone self ) Model set := method(key, value, oldValue := data at(key) if(oldValue != value, data atPut(key, value) notifyObservers(key, oldValue, value) ) self ) Model get := method(key, data at(key) ) Model observe := method(observer, observers append(observer) self ) Model notifyObservers := method(key, oldValue, newValue, observers foreach(observer, if(observer hasSlot(\u0026quot;modelChanged\u0026quot;), observer modelChanged(self, key, oldValue, newValue) ) ) ) // View View := Object clone View init := method(model, self model := model model observe(self) self elements := Map clone self ) View modelChanged := method(model, key, oldValue, newValue, render ) View render := method( // Override in subclasses ) // Controller Controller := Object clone Controller init := method(model, view, self model := model self view := view self ) Controller handleInput := method(input, // Process input and update model ) // Example: Todo MVC TodoModel := Model clone TodoModel init := method( resend self set(\u0026quot;todos\u0026quot;, list()) self ) TodoModel addTodo := method(text, todos := get(\u0026quot;todos\u0026quot;) copy todos append(Map with(\u0026quot;text\u0026quot;, text, \u0026quot;done\u0026quot;, false)) set(\u0026quot;todos\u0026quot;, todos) ) TodoModel toggleTodo := method(index, todos := get(\u0026quot;todos\u0026quot;) copy todo := todos at(index) todo atPut(\u0026quot;done\u0026quot;, todo at(\u0026quot;done\u0026quot;) not) set(\u0026quot;todos\u0026quot;, todos) ) TodoView := View clone TodoView render := method( \u0026quot;=== Todo List ===\u0026quot; println model get(\u0026quot;todos\u0026quot;) foreach(i, todo, status := if(todo at(\u0026quot;done\u0026quot;), \u0026quot;[✓]\u0026quot;, \u0026quot;[ ]\u0026quot;) (i .. \u0026quot;. \u0026quot; .. status .. \u0026quot; \u0026quot; .. todo at(\u0026quot;text\u0026quot;)) println ) \u0026quot;================\u0026quot; println ) TodoController := Controller clone TodoController processCommand := method(cmd, parts := cmd split(\u0026quot; \u0026quot;) action := parts at(0) if(action == \u0026quot;add\u0026quot;, text := parts slice(1) join(\u0026quot; \u0026quot;) model addTodo(text) ) if(action == \u0026quot;toggle\u0026quot;, index := parts at(1) asNumber model toggleTodo(index) ) if(action == \u0026quot;quit\u0026quot;, System exit ) ) // Usage app := Object clone app model := TodoModel clone init app view := TodoView clone init(app model) app controller := TodoController clone init(app model, app view) app view render // Simulate commands app controller processCommand(\u0026quot;add Buy groceries\u0026quot;) app controller processCommand(\u0026quot;add Write documentation\u0026quot;) app controller processCommand(\u0026quot;toggle 0\u0026quot;) Repository Pattern # Abstracting data access:\n// Base Repository Repository := Object clone Repository init := method( self storage := list() self nextId := 1 self ) Repository save := method(entity, if(entity hasSlot(\u0026quot;id\u0026quot;) not or entity id isNil, entity id := nextId nextId = nextId + 1 storage append(entity) , // Update existing index := storage detectIndex(e, e id == entity id) if(index, storage atPut(index, entity)) ) entity ) Repository findById := method(id, storage detect(e, e id == id) ) Repository findAll := method( storage copy ) Repository delete := method(entity, storage remove(entity) ) Repository where := method(predicate, storage select(predicate) ) // Specialized repository with persistence FileRepository := Repository clone FileRepository filename := \u0026quot;data.json\u0026quot; FileRepository init := method( resend load self ) FileRepository load := method( if(File with(filename) exists, data := File with(filename) contents parseJson storage = data map(item, entityFromMap(item)) nextId = storage map(e, e id) max + 1 ) ) FileRepository save := method(entity, resend(entity) persist entity ) FileRepository persist := method( data := storage map(e, e asMap) File with(filename) openForWriting write(data asJson) close ) // Entity User := Object clone User init := method(name, email, self id := nil self name := name self email := email self createdAt := Date now self ) User asMap := method( Map with( \u0026quot;id\u0026quot;, id, \u0026quot;name\u0026quot;, name, \u0026quot;email\u0026quot;, email, \u0026quot;createdAt\u0026quot;, createdAt asString ) ) // Usage userRepo := FileRepository clone init user1 := User clone init(\u0026quot;Alice\u0026quot;, \u0026quot;alice@example.com\u0026quot;) user2 := User clone init(\u0026quot;Bob\u0026quot;, \u0026quot;bob@example.com\u0026quot;) userRepo save(user1) userRepo save(user2) found := userRepo findById(1) active := userRepo where(u, u createdAt \u0026gt; Date now - Duration days(30)) Observer Pattern # Native implementation using Io\u0026rsquo;s message passing:\nObservable := Object clone Observable init := method( self observers := Map clone self ) Observable on := method(event, observer, methodName, if(observers hasKey(event) not, observers atPut(event, list()) ) observers at(event) append(list(observer, methodName)) self ) Observable off := method(event, observer, if(observers hasKey(event), observers at(event) := observers at(event) reject(pair, pair at(0) == observer ) ) self ) Observable emit := method(event, args := call message arguments slice(1) if(observers hasKey(event), observers at(event) foreach(pair, observer := pair at(0) methodName := pair at(1) msg := Message clone setName(methodName) args foreach(arg, msg appendArg(arg)) observer doMessage(msg) ) ) self ) // Example: Stock price monitor Stock := Observable clone Stock init := method(symbol, price, resend self symbol := symbol self price := price self ) Stock setPrice := method(newPrice, oldPrice := price price = newPrice change := ((newPrice - oldPrice) / oldPrice * 100) round emit(\u0026quot;priceChanged\u0026quot;, symbol, oldPrice, newPrice, change) if(change abs \u0026gt; 5, emit(\u0026quot;largeMoveDetected\u0026quot;, symbol, change) ) ) StockAlert := Object clone StockAlert onPriceChange := method(symbol, oldPrice, newPrice, change, (\u0026quot;Price alert: \u0026quot; .. symbol .. \u0026quot; moved from $\u0026quot; .. oldPrice .. \u0026quot; to $\u0026quot; .. newPrice .. \u0026quot; (\u0026quot; .. change .. \u0026quot;%)\u0026quot;) println ) StockAlert onLargeMove := method(symbol, change, (\u0026quot;⚠️ Large move detected: \u0026quot; .. symbol .. \u0026quot; changed \u0026quot; .. change .. \u0026quot;%\u0026quot;) println ) // Usage apple := Stock clone init(\u0026quot;AAPL\u0026quot;, 150.00) alert := StockAlert clone apple on(\u0026quot;priceChanged\u0026quot;, alert, \u0026quot;onPriceChange\u0026quot;) apple on(\u0026quot;largeMoveDetected\u0026quot;, alert, \u0026quot;onLargeMove\u0026quot;) apple setPrice(155.00) // Normal change apple setPrice(165.00) // Large move triggers both alerts Dependency Injection # Using Io\u0026rsquo;s dynamic nature for DI:\n// DI Container Container := Object clone Container init := method( self services := Map clone self singletons := Map clone self ) Container register := method(name, factory, services atPut(name, factory) self ) Container singleton := method(name, factory, services atPut(name, factory) singletons atPut(name, nil) self ) Container get := method(name, if(services hasKey(name) not, Exception raise(\u0026quot;Service '\u0026quot; .. name .. \u0026quot;' not registered\u0026quot;) ) // Check if singleton if(singletons hasKey(name), if(singletons at(name) isNil, singletons atPut(name, services at(name) call(self)) ) return singletons at(name) ) // Regular service services at(name) call(self) ) // Services Logger := Object clone Logger init := method(output, self output := output self ) Logger log := method(message, output write(\u0026quot;[\u0026quot; .. Date now .. \u0026quot;] \u0026quot; .. message .. \u0026quot;\\n\u0026quot;) ) Database := Object clone Database init := method(connectionString, logger, self connectionString := connectionString self logger := logger logger log(\u0026quot;Database initialized: \u0026quot; .. connectionString) self ) UserService := Object clone UserService init := method(database, logger, self database := database self logger := logger self ) UserService createUser := method(name, logger log(\u0026quot;Creating user: \u0026quot; .. name) // database operations... Map with(\u0026quot;id\u0026quot;, 1, \u0026quot;name\u0026quot;, name) ) // Configure container container := Container clone init container singleton(\u0026quot;logger\u0026quot;, block(c, Logger clone init(File standardOutput) )) container singleton(\u0026quot;database\u0026quot;, block(c, Database clone init(\u0026quot;postgres://localhost/myapp\u0026quot;, c get(\u0026quot;logger\u0026quot;)) )) container register(\u0026quot;userService\u0026quot;, block(c, UserService clone init(c get(\u0026quot;database\u0026quot;), c get(\u0026quot;logger\u0026quot;)) )) // Usage service := container get(\u0026quot;userService\u0026quot;) service createUser(\u0026quot;Alice\u0026quot;) // Different instance each time service1 := container get(\u0026quot;userService\u0026quot;) service2 := container get(\u0026quot;userService\u0026quot;) (service1 == service2) println // false // Same logger instance logger1 := container get(\u0026quot;logger\u0026quot;) logger2 := container get(\u0026quot;logger\u0026quot;) (logger1 == logger2) println // true Strategy Pattern # Leveraging blocks and dynamic dispatch:\n// Sorting strategies SortStrategy := Object clone BubbleSort := SortStrategy clone BubbleSort execute := method(list, result := list copy n := result size for(i, 0, n - 2, for(j, 0, n - i - 2, if(result at(j) \u0026gt; result at(j + 1), temp := result at(j) result atPut(j, result at(j + 1)) result atPut(j + 1, temp) ) ) ) result ) QuickSort := SortStrategy clone QuickSort execute := method(list, if(list size \u0026lt;= 1, return list) pivot := list at(list size / 2) less := list select(x, x \u0026lt; pivot) equal := list select(x, x == pivot) greater := list select(x, x \u0026gt; pivot) execute(less) appendSeq(equal) appendSeq(execute(greater)) ) // Context DataProcessor := Object clone DataProcessor init := method( self strategy := QuickSort self ) DataProcessor setStrategy := method(s, strategy = s self ) DataProcessor process := method(data, \u0026quot;Processing data...\u0026quot; println strategy execute(data) ) // Usage with different strategies processor := DataProcessor clone init data := list(3, 1, 4, 1, 5, 9, 2, 6) processor setStrategy(BubbleSort) process(data) println processor setStrategy(QuickSort) process(data) println // Dynamic strategy selection selectStrategy := method(dataSize, if(dataSize \u0026lt; 10, BubbleSort, QuickSort) ) processor setStrategy(selectStrategy(data size)) Chain of Responsibility # Building processing pipelines:\nHandler := Object clone Handler init := method( self next := nil self ) Handler setNext := method(handler, next = handler handler ) Handler handle := method(request, if(canHandle(request), process(request), if(next, next handle(request), nil) ) ) // Concrete handlers AuthenticationHandler := Handler clone AuthenticationHandler canHandle := method(request, request at(\u0026quot;requiresAuth\u0026quot;) ) AuthenticationHandler process := method(request, if(request at(\u0026quot;token\u0026quot;) == \u0026quot;valid-token\u0026quot;, \u0026quot;Authentication successful\u0026quot; println request atPut(\u0026quot;authenticated\u0026quot;, true) if(next, next handle(request), request) , Exception raise(\u0026quot;Authentication failed\u0026quot;) ) ) LoggingHandler := Handler clone LoggingHandler canHandle := method(request, true) LoggingHandler process := method(request, (\u0026quot;Logging request: \u0026quot; .. request at(\u0026quot;path\u0026quot;)) println if(next, next handle(request), request) ) RateLimitHandler := Handler clone RateLimitHandler init := method( resend self requests := Map clone self limit := 10 self window := 60 // seconds self ) RateLimitHandler canHandle := method(request, request hasKey(\u0026quot;clientId\u0026quot;) ) RateLimitHandler process := method(request, clientId := request at(\u0026quot;clientId\u0026quot;) now := Date now if(requests hasKey(clientId) not, requests atPut(clientId, list()) ) // Clean old requests clientRequests := requests at(clientId) select(time, now - time \u0026lt; window ) if(clientRequests size \u0026gt;= limit, Exception raise(\u0026quot;Rate limit exceeded\u0026quot;), clientRequests append(now) requests atPut(clientId, clientRequests) if(next, next handle(request), request) ) ) // Build chain chain := LoggingHandler clone \\ setNext(RateLimitHandler clone \\ setNext(AuthenticationHandler clone)) // Process requests request := Map with( \u0026quot;path\u0026quot;, \u0026quot;/api/users\u0026quot;, \u0026quot;clientId\u0026quot;, \u0026quot;client-123\u0026quot;, \u0026quot;requiresAuth\u0026quot;, true, \u0026quot;token\u0026quot;, \u0026quot;valid-token\u0026quot; ) result := chain handle(request) Plugin Architecture # Dynamic loading and extension:\nPluginManager := Object clone PluginManager init := method( self plugins := Map clone self hooks := Map clone self ) PluginManager registerHook := method(name, if(hooks hasKey(name) not, hooks atPut(name, list()) ) self ) PluginManager loadPlugin := method(path, plugin := doFile(path) if(plugin hasSlot(\u0026quot;name\u0026quot;) not, Exception raise(\u0026quot;Plugin must have a name\u0026quot;) ) plugins atPut(plugin name, plugin) if(plugin hasSlot(\u0026quot;init\u0026quot;), plugin init(self) ) (\u0026quot;Plugin loaded: \u0026quot; .. plugin name) println self ) PluginManager hook := method(name, args := call message arguments slice(1) results := list() if(hooks hasKey(name), hooks at(name) foreach(handler, result := handler doMessage(Message clone setName(\u0026quot;call\u0026quot;) setArguments(args)) results append(result) ) ) results ) PluginManager addHook := method(hookName, handler, if(hooks hasKey(hookName) not, registerHook(hookName) ) hooks at(hookName) append(handler) self ) // Example plugin MarkdownPlugin := Object clone MarkdownPlugin name := \u0026quot;markdown\u0026quot; MarkdownPlugin init := method(manager, manager addHook(\u0026quot;processText\u0026quot;, block(text, // Simple markdown processing text replaceAllRegex(\u0026quot;\\\\*\\\\*(.*?)\\\\*\\\\*\u0026quot;, \u0026quot;\u0026lt;strong\u0026gt;$1\u0026lt;/strong\u0026gt;\u0026quot;) \\ replaceAllRegex(\u0026quot;\\\\*(.*?)\\\\*\u0026quot;, \u0026quot;\u0026lt;em\u0026gt;$1\u0026lt;/em\u0026gt;\u0026quot;) )) manager addHook(\u0026quot;getFormats\u0026quot;, block( list(\u0026quot;markdown\u0026quot;, \u0026quot;md\u0026quot;) )) ) // Usage manager := PluginManager clone init manager registerHook(\u0026quot;processText\u0026quot;) manager registerHook(\u0026quot;getFormats\u0026quot;) // Load plugins manager loadPlugin(\u0026quot;markdown_plugin.io\u0026quot;) // Use hooks text := \u0026quot;This is **bold** and this is *italic*\u0026quot; processed := manager hook(\u0026quot;processText\u0026quot;, text) processed foreach(result, result println) formats := manager hook(\u0026quot;getFormats\u0026quot;) \u0026quot;Supported formats: \u0026quot; print formats flatten unique println Event Sourcing # Implementing event-driven architecture:\n// Event Event := Object clone Event init := method(type, data, self type := type self data := data self timestamp := Date now self id := Random uuid self ) // Event Store EventStore := Object clone EventStore init := method( self events := list() self snapshots := Map clone self ) EventStore append := method(event, events append(event) self ) EventStore getEvents := method(afterId, if(afterId isNil, return events ) startIndex := events detectIndex(e, e id == afterId) if(startIndex, events slice(startIndex + 1), list() ) ) // Aggregate Aggregate := Object clone Aggregate init := method(id, self id := id self version := 0 self uncommittedEvents := list() self ) Aggregate applyEvent := method(event, // Override in subclasses ) Aggregate raiseEvent := method(event, applyEvent(event) uncommittedEvents append(event) version = version + 1 ) Aggregate markEventsAsCommitted := method( uncommittedEvents = list() ) Aggregate loadFromHistory := method(events, events foreach(event, applyEvent(event) version = version + 1 ) ) // Example: Bank Account aggregate BankAccount := Aggregate clone BankAccount init := method(id, resend(id) self balance := 0 self ) BankAccount deposit := method(amount, if(amount \u0026lt;= 0, Exception raise(\u0026quot;Amount must be positive\u0026quot;) ) raiseEvent(Event clone init(\u0026quot;MoneyDeposited\u0026quot;, Map with(\u0026quot;accountId\u0026quot;, id, \u0026quot;amount\u0026quot;, amount))) ) BankAccount withdraw := method(amount, if(amount \u0026lt;= 0, Exception raise(\u0026quot;Amount must be positive\u0026quot;) ) if(amount \u0026gt; balance, Exception raise(\u0026quot;Insufficient funds\u0026quot;) ) raiseEvent(Event clone init(\u0026quot;MoneyWithdrawn\u0026quot;, Map with(\u0026quot;accountId\u0026quot;, id, \u0026quot;amount\u0026quot;, amount))) ) BankAccount applyEvent := method(event, if(event type == \u0026quot;MoneyDeposited\u0026quot;, balance = balance + event data at(\u0026quot;amount\u0026quot;) ) if(event type == \u0026quot;MoneyWithdrawn\u0026quot;, balance = balance - event data at(\u0026quot;amount\u0026quot;) ) ) // Repository using event sourcing AccountRepository := Object clone AccountRepository init := method(eventStore, self eventStore := eventStore self ) AccountRepository save := method(account, account uncommittedEvents foreach(event, eventStore append(event) ) account markEventsAsCommitted ) AccountRepository getById := method(id, events := eventStore getEvents select(e, e data at(\u0026quot;accountId\u0026quot;) == id ) account := BankAccount clone init(id) account loadFromHistory(events) account ) // Usage store := EventStore clone init repo := AccountRepository clone init(store) account := BankAccount clone init(\u0026quot;acc-123\u0026quot;) account deposit(100) account withdraw(30) account deposit(50) repo save(account) account balance println // 120 // Rebuild from events rebuilt := repo getById(\u0026quot;acc-123\u0026quot;) rebuilt balance println // 120 Caching Strategy # Multi-level caching with different policies:\nCache := Object clone Cache init := method(maxSize, ttl, self maxSize := maxSize self ttl := ttl // Time to live in seconds self entries := Map clone self accessOrder := list() self ) Cache get := method(key, if(entries hasKey(key), entry := entries at(key) // Check TTL if(Date now - entry at(\u0026quot;time\u0026quot;) \u0026gt; ttl, entries removeAt(key) accessOrder remove(key) return nil ) // Update access order (LRU) accessOrder remove(key) accessOrder append(key) entry at(\u0026quot;value\u0026quot;) , nil ) ) Cache put := method(key, value, // Evict if necessary while(entries size \u0026gt;= maxSize, evictKey := accessOrder removeFirst entries removeAt(evictKey) (\u0026quot;Cache evicted: \u0026quot; .. evictKey) println ) entries atPut(key, Map with( \u0026quot;value\u0026quot;, value, \u0026quot;time\u0026quot;, Date now )) accessOrder append(key) value ) Cache getOrCompute := method(key, computeBlock, value := get(key) if(value isNil, value = computeBlock call put(key, value) ) value ) // Multi-level cache MultiLevelCache := Object clone MultiLevelCache init := method( self l1 := Cache clone init(10, 60) // Small, fast, 1 minute TTL self l2 := Cache clone init(100, 600) // Larger, 10 minute TTL self ) MultiLevelCache get := method(key, // Check L1 value := l1 get(key) if(value, return value) // Check L2 value = l2 get(key) if(value, l1 put(key, value) // Promote to L1 return value ) nil ) MultiLevelCache put := method(key, value, l1 put(key, value) l2 put(key, value) value ) // Usage with expensive computation fibonacci := Object clone fibonacci cache := MultiLevelCache clone init fibonacci compute := method(n, if(n \u0026lt;= 1, return n) cache get(n) ifNil( (\u0026quot;Computing fib(\u0026quot; .. n .. \u0026quot;)\u0026quot;) println result := compute(n - 1) + compute(n - 2) cache put(n, result) result ) ) fibonacci compute(10) println // Computes fibonacci compute(10) println // From cache Conclusion # These patterns demonstrate how Io\u0026rsquo;s features—prototype-based inheritance, message passing, blocks, and metaprogramming—combine to create elegant solutions to real-world problems. The language\u0026rsquo;s flexibility allows patterns to be implemented more directly than in many mainstream languages, often with less boilerplate and more expressive code.\nThe key insight is that Io\u0026rsquo;s uniform object model means patterns aren\u0026rsquo;t special constructs but natural expressions of the language\u0026rsquo;s core concepts. This makes it easy to adapt patterns to specific needs or create entirely new architectural approaches.\nNext: Chapter 16 - Case Studies\n"},{"id":18,"href":"/docs/16-case-studies/","title":"Case Studies","section":"Chapters","content":" Chapter 16: Case Studies # This chapter presents complete, real-world applications built in Io. Each case study demonstrates how Io\u0026rsquo;s features work together to solve practical problems, showing both the elegance and challenges of building substantial systems in the language.\nCase Study 1: Web Server # Building a simple but functional HTTP server demonstrates Io\u0026rsquo;s networking, concurrency, and string handling:\n// HTTP Server Implementation HttpServer := Object clone HttpServer init := method(port, self port := port self routes := Map clone self middlewares := list() self ) HttpRequest := Object clone HttpRequest parse := method(rawData, lines := rawData split(\u0026quot;\\r\\n\u0026quot;) if(lines size == 0, return nil) // Parse request line requestLine := lines at(0) split(\u0026quot; \u0026quot;) self method := requestLine at(0) self path := requestLine at(1) self version := requestLine at(2) // Parse headers self headers := Map clone self body := \u0026quot;\u0026quot; bodyStart := false lines slice(1) foreach(line, if(bodyStart, body = body .. line, if(line size == 0, bodyStart = true, parts := line split(\u0026quot;: \u0026quot;) if(parts size == 2, headers atPut(parts at(0), parts at(1)) ) ) ) ) // Parse query parameters self params := Map clone if(path containsSeq(\u0026quot;?\u0026quot;), parts := path split(\u0026quot;?\u0026quot;) self path = parts at(0) queryString := parts at(1) queryString split(\u0026quot;\u0026amp;\u0026quot;) foreach(param, kv := param split(\u0026quot;=\u0026quot;) if(kv size == 2, params atPut(kv at(0), kv at(1) urlDecode) ) ) ) self ) HttpResponse := Object clone HttpResponse init := method( self status := 200 self headers := Map clone self body := \u0026quot;\u0026quot; headers atPut(\u0026quot;Content-Type\u0026quot;, \u0026quot;text/html\u0026quot;) headers atPut(\u0026quot;Server\u0026quot;, \u0026quot;Io-Server/1.0\u0026quot;) self ) HttpResponse setStatus := method(code, status = code self ) HttpResponse setHeader := method(key, value, headers atPut(key, value) self ) HttpResponse write := method(content, body = body .. content self ) HttpResponse json := method(data, setHeader(\u0026quot;Content-Type\u0026quot;, \u0026quot;application/json\u0026quot;) write(data asJson) self ) HttpResponse build := method( statusText := Map with( 200, \u0026quot;OK\u0026quot;, 404, \u0026quot;Not Found\u0026quot;, 500, \u0026quot;Internal Server Error\u0026quot; ) at(status, \u0026quot;Unknown\u0026quot;) result := \u0026quot;HTTP/1.1 \u0026quot; .. status .. \u0026quot; \u0026quot; .. statusText .. \u0026quot;\\r\\n\u0026quot; headers atPut(\u0026quot;Content-Length\u0026quot;, body size asString) headers foreach(key, value, result = result .. key .. \u0026quot;: \u0026quot; .. value .. \u0026quot;\\r\\n\u0026quot; ) result .. \u0026quot;\\r\\n\u0026quot; .. body ) // Middleware support HttpServer use := method(middleware, middlewares append(middleware) self ) // Routing HttpServer route := method(method, path, handler, key := method .. \u0026quot;:\u0026quot; .. path routes atPut(key, handler) self ) HttpServer get := method(path, handler, route(\u0026quot;GET\u0026quot;, path, handler) ) HttpServer post := method(path, handler, route(\u0026quot;POST\u0026quot;, path, handler) ) // Request handling HttpServer handleConnection := method(socket, rawData := socket readUntilSeq(\u0026quot;\\r\\n\\r\\n\u0026quot;) request := HttpRequest parse(rawData) if(request isNil, socket close return ) response := HttpResponse clone init // Run middlewares middlewares foreach(middleware, middleware call(request, response) ) // Find route key := request method .. \u0026quot;:\u0026quot; .. request path handler := routes at(key) if(handler, e := try( handler call(request, response) ) catch(Exception, e, response setStatus(500) write(\u0026quot;Internal Server Error: \u0026quot; .. e message) ) , // Try pattern matching for dynamic routes handled := false routes foreach(routeKey, routeHandler, parts := routeKey split(\u0026quot;:\u0026quot;) routeMethod := parts at(0) routePath := parts at(1) if(routeMethod == request method and matchPath(routePath, request path), routeHandler call(request, response) handled = true break ) ) if(handled not, response setStatus(404) write(\u0026quot;Not Found\u0026quot;) ) ) socket write(response build) socket close ) HttpServer matchPath := method(pattern, path, // Simple pattern matching (e.g., /users/:id) if(pattern containsSeq(\u0026quot;:\u0026quot;), patternParts := pattern split(\u0026quot;/\u0026quot;) pathParts := path split(\u0026quot;/\u0026quot;) if(patternParts size != pathParts size, return false) patternParts foreach(i, part, if(part beginsWithSeq(\u0026quot;:\u0026quot;) not, if(part != pathParts at(i), return false) ) ) true , pattern == path ) ) HttpServer start := method( server := Socket clone server setHost(\u0026quot;127.0.0.1\u0026quot;) server setPort(port) server bind server listen (\u0026quot;Server listening on port \u0026quot; .. port) println loop( client := server accept @handleConnection(client) // Handle async ) ) // Example application app := HttpServer clone init(8080) // Middleware for logging app use(block(request, response, (\u0026quot;[\u0026quot; .. Date now .. \u0026quot;] \u0026quot; .. request method .. \u0026quot; \u0026quot; .. request path) println )) // Static content app get(\u0026quot;/\u0026quot;, block(request, response, response write(\u0026quot;\u0026lt;h1\u0026gt;Welcome to Io Web Server\u0026lt;/h1\u0026gt;\u0026quot;) response write(\u0026quot;\u0026lt;p\u0026gt;A simple server built with Io\u0026lt;/p\u0026gt;\u0026quot;) )) // JSON API app get(\u0026quot;/api/info\u0026quot;, block(request, response, info := Map with( \u0026quot;server\u0026quot;, \u0026quot;Io-Server\u0026quot;, \u0026quot;version\u0026quot;, \u0026quot;1.0\u0026quot;, \u0026quot;time\u0026quot;, Date now asString ) response json(info) )) // Dynamic routes app get(\u0026quot;/users/:id\u0026quot;, block(request, response, // Extract ID from path id := request path split(\u0026quot;/\u0026quot;) at(2) response write(\u0026quot;\u0026lt;h1\u0026gt;User Profile\u0026lt;/h1\u0026gt;\u0026quot;) response write(\u0026quot;\u0026lt;p\u0026gt;User ID: \u0026quot; .. id .. \u0026quot;\u0026lt;/p\u0026gt;\u0026quot;) )) // Form handling app post(\u0026quot;/submit\u0026quot;, block(request, response, // Parse form data from body response write(\u0026quot;\u0026lt;h1\u0026gt;Form Submitted\u0026lt;/h1\u0026gt;\u0026quot;) response write(\u0026quot;\u0026lt;p\u0026gt;Data: \u0026quot; .. request body .. \u0026quot;\u0026lt;/p\u0026gt;\u0026quot;) )) // Start server app start Case Study 2: Database ORM # A simple object-relational mapper showcasing metaprogramming and DSL capabilities:\n// ORM Implementation ORM := Object clone // Database connection (simplified) Database := Object clone Database connections := Map clone Database connect := method(name, config, conn := Connection clone init(config) connections atPut(name, conn) conn ) Connection := Object clone Connection init := method(config, self config := config self tables := Map clone self ) Connection execute := method(sql, (\u0026quot;[SQL] \u0026quot; .. sql) println // Simulate results list() ) // Model base class Model := Object clone Model tableName := nil Model fields := Map clone Model connection := nil Model field := method(name, type, fields atPut(name, Map with(\u0026quot;type\u0026quot;, type, \u0026quot;name\u0026quot;, name)) // Generate getter self setSlot(name, method( self getSlot(\u0026quot;_\u0026quot; .. name) )) // Generate setter self setSlot(\u0026quot;set\u0026quot; .. name asCapitalized, method(value, self setSlot(\u0026quot;_\u0026quot; .. name, value) self )) self ) Model belongsTo := method(name, targetModel, fields atPut(name .. \u0026quot;_id\u0026quot;, Map with(\u0026quot;type\u0026quot;, \u0026quot;INTEGER\u0026quot;, \u0026quot;name\u0026quot;, name .. \u0026quot;_id\u0026quot;)) self setSlot(name, method( targetModel findById(self getSlot(\u0026quot;_\u0026quot; .. name .. \u0026quot;_id\u0026quot;)) )) self ) Model hasMany := method(name, targetModel, foreignKey, self setSlot(name, method( targetModel where(foreignKey .. \u0026quot; = \u0026quot; .. self id) )) self ) Model createTable := method( sql := \u0026quot;CREATE TABLE IF NOT EXISTS \u0026quot; .. tableName .. \u0026quot; (\\n\u0026quot; sql = sql .. \u0026quot; id INTEGER PRIMARY KEY AUTOINCREMENT,\\n\u0026quot; fieldDefs := fields map(name, field, \u0026quot; \u0026quot; .. name .. \u0026quot; \u0026quot; .. field at(\u0026quot;type\u0026quot;) ) sql = sql .. fieldDefs join(\u0026quot;,\\n\u0026quot;) .. \u0026quot;\\n);\u0026quot; connection execute(sql) self ) Model dropTable := method( connection execute(\u0026quot;DROP TABLE IF EXISTS \u0026quot; .. tableName) self ) Model init := method( fields foreach(name, field, self setSlot(\u0026quot;_\u0026quot; .. name, nil) ) self setSlot(\u0026quot;_id\u0026quot;, nil) self ) Model save := method( if(_id, update, insert ) ) Model insert := method( columns := list() values := list() fields foreach(name, field, value := self getSlot(\u0026quot;_\u0026quot; .. name) if(value isNil not, columns append(name) values append(\u0026quot;'\u0026quot; .. value asString .. \u0026quot;'\u0026quot;) ) ) sql := \u0026quot;INSERT INTO \u0026quot; .. tableName .. \u0026quot; (\u0026quot; .. columns join(\u0026quot;, \u0026quot;) .. \u0026quot;) VALUES (\u0026quot; .. values join(\u0026quot;, \u0026quot;) .. \u0026quot;)\u0026quot; connection execute(sql) self _id := connection lastInsertId // Simulated self ) Model update := method( updates := list() fields foreach(name, field, value := self getSlot(\u0026quot;_\u0026quot; .. name) if(value isNil not, updates append(name .. \u0026quot; = '\u0026quot; .. value asString .. \u0026quot;'\u0026quot;) ) ) sql := \u0026quot;UPDATE \u0026quot; .. tableName .. \u0026quot; SET \u0026quot; .. updates join(\u0026quot;, \u0026quot;) .. \u0026quot; WHERE id = \u0026quot; .. _id connection execute(sql) self ) Model delete := method( if(_id, connection execute(\u0026quot;DELETE FROM \u0026quot; .. tableName .. \u0026quot; WHERE id = \u0026quot; .. _id) self _id := nil ) self ) // Class methods Model all := method( sql := \u0026quot;SELECT * FROM \u0026quot; .. tableName rows := connection execute(sql) rows map(row, fromRow(row)) ) Model findById := method(id, sql := \u0026quot;SELECT * FROM \u0026quot; .. tableName .. \u0026quot; WHERE id = \u0026quot; .. id rows := connection execute(sql) if(rows size \u0026gt; 0, fromRow(rows first), nil ) ) Model where := method(condition, sql := \u0026quot;SELECT * FROM \u0026quot; .. tableName .. \u0026quot; WHERE \u0026quot; .. condition rows := connection execute(sql) rows map(row, fromRow(row)) ) Model fromRow := method(row, instance := self clone init instance _id := row at(\u0026quot;id\u0026quot;) fields foreach(name, field, instance setSlot(\u0026quot;_\u0026quot; .. name, row at(name)) ) instance ) // Query builder QueryBuilder := Object clone QueryBuilder init := method(model, self model := model self selections := list(\u0026quot;*\u0026quot;) self conditions := list() self orderBy := nil self limitValue := nil self ) QueryBuilder select := method( self selections = call message arguments map(arg, call sender doMessage(arg) asString ) self ) QueryBuilder where := method(condition, conditions append(condition) self ) QueryBuilder order := method(column, direction, orderBy = column .. \u0026quot; \u0026quot; .. if(direction, direction, \u0026quot;ASC\u0026quot;) self ) QueryBuilder limit := method(n, limitValue = n self ) QueryBuilder build := method( sql := \u0026quot;SELECT \u0026quot; .. selections join(\u0026quot;, \u0026quot;) .. \u0026quot; FROM \u0026quot; .. model tableName if(conditions size \u0026gt; 0, sql = sql .. \u0026quot; WHERE \u0026quot; .. conditions join(\u0026quot; AND \u0026quot;) ) if(orderBy, sql = sql .. \u0026quot; ORDER BY \u0026quot; .. orderBy ) if(limitValue, sql = sql .. \u0026quot; LIMIT \u0026quot; .. limitValue ) sql ) QueryBuilder execute := method( sql := build rows := model connection execute(sql) rows map(row, model fromRow(row)) ) // Define models User := Model clone User tableName = \u0026quot;users\u0026quot; User connection = Database connect(\u0026quot;main\u0026quot;, Map with(\u0026quot;file\u0026quot;, \u0026quot;app.db\u0026quot;)) User field(\u0026quot;name\u0026quot;, \u0026quot;VARCHAR(100)\u0026quot;) \\ field(\u0026quot;email\u0026quot;, \u0026quot;VARCHAR(100)\u0026quot;) \\ field(\u0026quot;age\u0026quot;, \u0026quot;INTEGER\u0026quot;) \\ field(\u0026quot;created_at\u0026quot;, \u0026quot;DATETIME\u0026quot;) User hasMany(\u0026quot;posts\u0026quot;, Post, \u0026quot;user_id\u0026quot;) Post := Model clone Post tableName = \u0026quot;posts\u0026quot; Post connection = User connection Post field(\u0026quot;title\u0026quot;, \u0026quot;VARCHAR(200)\u0026quot;) \\ field(\u0026quot;content\u0026quot;, \u0026quot;TEXT\u0026quot;) \\ field(\u0026quot;published\u0026quot;, \u0026quot;BOOLEAN\u0026quot;) \\ field(\u0026quot;user_id\u0026quot;, \u0026quot;INTEGER\u0026quot;) Post belongsTo(\u0026quot;user\u0026quot;, User) // Validations User validate := method( errors := list() if(_name isNil or _name size == 0, errors append(\u0026quot;Name is required\u0026quot;) ) if(_email isNil or _email containsSeq(\u0026quot;@\u0026quot;) not, errors append(\u0026quot;Invalid email\u0026quot;) ) if(_age and (_age \u0026lt; 0 or _age \u0026gt; 150), errors append(\u0026quot;Invalid age\u0026quot;) ) if(errors size \u0026gt; 0, Exception raise(errors join(\u0026quot;, \u0026quot;)) ) true ) User beforeSave := method( validate _created_at := Date now ) // Usage example User createTable Post createTable user := User clone init user setName(\u0026quot;Alice\u0026quot;) setEmail(\u0026quot;alice@example.com\u0026quot;) setAge(30) user save post := Post clone init post setTitle(\u0026quot;First Post\u0026quot;) \\ setContent(\u0026quot;Hello, World!\u0026quot;) \\ setPublished(true) \\ setUserId(user id) post save // Query examples allUsers := User all youngUsers := User where(\u0026quot;age \u0026lt; 25\u0026quot;) userPosts := user posts // Query builder query := QueryBuilder clone init(User) results := query select(\u0026quot;name\u0026quot;, \u0026quot;email\u0026quot;) \\ where(\u0026quot;age \u0026gt; 21\u0026quot;) \\ order(\u0026quot;name\u0026quot;) \\ limit(10) \\ execute Case Study 3: Game Engine # A simple 2D game engine demonstrating real-time systems and graphics:\n// Game Engine Core GameEngine := Object clone GameEngine init := method(width, height, self width := width self height := height self entities := list() self systems := list() self running := true self fps := 60 self frameTime := 1.0 / fps self ) // Entity Component System Entity := Object clone Entity init := method( self id := Random uuid self components := Map clone self active := true self ) Entity addComponent := method(name, component, components atPut(name, component) component entity := self self ) Entity getComponent := method(name, components at(name) ) Entity hasComponent := method(name, components hasKey(name) ) // Components Component := Object clone PositionComponent := Component clone PositionComponent init := method(x, y, self x := x self y := y self ) VelocityComponent := Component clone VelocityComponent init := method(dx, dy, self dx := dx self dy := dy self ) SpriteComponent := Component clone SpriteComponent init := method(image, width, height, self image := image self width := width self height := height self ) ColliderComponent := Component clone ColliderComponent init := method(width, height, self width := width self height := height self ) HealthComponent := Component clone HealthComponent init := method(maxHealth, self maxHealth := maxHealth self currentHealth := maxHealth self ) // Systems System := Object clone System init := method( self requiredComponents := list() self ) System process := method(entity, deltaTime, // Override in subclasses ) System canProcess := method(entity, requiredComponents all(comp, entity hasComponent(comp) ) ) MovementSystem := System clone MovementSystem requiredComponents = list(\u0026quot;position\u0026quot;, \u0026quot;velocity\u0026quot;) MovementSystem process := method(entity, deltaTime, pos := entity getComponent(\u0026quot;position\u0026quot;) vel := entity getComponent(\u0026quot;velocity\u0026quot;) pos x = pos x + vel dx * deltaTime pos y = pos y + vel dy * deltaTime ) CollisionSystem := System clone CollisionSystem requiredComponents = list(\u0026quot;position\u0026quot;, \u0026quot;collider\u0026quot;) CollisionSystem init := method( resend self collisions := list() self ) CollisionSystem update := method(entities, deltaTime, collisions = list() // Check all pairs entities foreach(i, e1, if(canProcess(e1), entities slice(i + 1) foreach(e2, if(canProcess(e2) and checkCollision(e1, e2), collisions append(list(e1, e2)) onCollision(e1, e2) ) ) ) ) ) CollisionSystem checkCollision := method(e1, e2, p1 := e1 getComponent(\u0026quot;position\u0026quot;) c1 := e1 getComponent(\u0026quot;collider\u0026quot;) p2 := e2 getComponent(\u0026quot;position\u0026quot;) c2 := e2 getComponent(\u0026quot;collider\u0026quot;) // AABB collision p1 x \u0026lt; p2 x + c2 width and p1 x + c1 width \u0026gt; p2 x and p1 y \u0026lt; p2 y + c2 height and p1 y + c1 height \u0026gt; p2 y ) CollisionSystem onCollision := method(e1, e2, (\u0026quot;Collision between \u0026quot; .. e1 id .. \u0026quot; and \u0026quot; .. e2 id) println ) // Rendering (simulated) RenderSystem := System clone RenderSystem requiredComponents = list(\u0026quot;position\u0026quot;, \u0026quot;sprite\u0026quot;) RenderSystem init := method( resend self screen := list() self ) RenderSystem render := method(entities, // Clear screen screen = list() entities foreach(entity, if(canProcess(entity), pos := entity getComponent(\u0026quot;position\u0026quot;) sprite := entity getComponent(\u0026quot;sprite\u0026quot;) screen append(Map with( \u0026quot;x\u0026quot;, pos x, \u0026quot;y\u0026quot;, pos y, \u0026quot;image\u0026quot;, sprite image )) ) ) // Draw screen (simulated) drawScreen ) RenderSystem drawScreen := method( \u0026quot;Frame:\u0026quot; println screen foreach(item, (\u0026quot; [\u0026quot; .. item at(\u0026quot;image\u0026quot;) .. \u0026quot;] at (\u0026quot; .. item at(\u0026quot;x\u0026quot;) round .. \u0026quot;, \u0026quot; .. item at(\u0026quot;y\u0026quot;) round .. \u0026quot;)\u0026quot;) println ) ) // Input handling InputManager := Object clone InputManager init := method( self keys := Map clone self mouseX := 0 self mouseY := 0 self ) InputManager isKeyPressed := method(key, keys at(key, false) ) InputManager setKey := method(key, pressed, keys atPut(key, pressed) ) // Game states GameState := Object clone GameState enter := method() GameState exit := method() GameState update := method(deltaTime) GameState render := method() MenuState := GameState clone MenuState enter := method( \u0026quot;Entering menu\u0026quot; println self selectedOption := 0 self options := list(\u0026quot;Start Game\u0026quot;, \u0026quot;Options\u0026quot;, \u0026quot;Quit\u0026quot;) ) MenuState update := method(deltaTime, // Handle menu input if(InputManager isKeyPressed(\u0026quot;up\u0026quot;), selectedOption = (selectedOption - 1) max(0) ) if(InputManager isKeyPressed(\u0026quot;down\u0026quot;), selectedOption = (selectedOption + 1) min(options size - 1) ) if(InputManager isKeyPressed(\u0026quot;enter\u0026quot;), handleSelection ) ) MenuState handleSelection := method( option := options at(selectedOption) if(option == \u0026quot;Start Game\u0026quot;, GameEngine setState(PlayState) ) if(option == \u0026quot;Quit\u0026quot;, GameEngine stop ) ) PlayState := GameState clone PlayState enter := method( \u0026quot;Starting game\u0026quot; println createLevel ) PlayState createLevel := method( // Create player player := Entity clone init player addComponent(\u0026quot;position\u0026quot;, PositionComponent clone init(100, 100)) player addComponent(\u0026quot;velocity\u0026quot;, VelocityComponent clone init(0, 0)) player addComponent(\u0026quot;sprite\u0026quot;, SpriteComponent clone init(\u0026quot;player\u0026quot;, 32, 32)) player addComponent(\u0026quot;collider\u0026quot;, ColliderComponent clone init(32, 32)) player addComponent(\u0026quot;health\u0026quot;, HealthComponent clone init(100)) GameEngine addEntity(player) // Create enemies 3 repeat(i, enemy := Entity clone init enemy addComponent(\u0026quot;position\u0026quot;, PositionComponent clone init(200 + i * 50, 200)) enemy addComponent(\u0026quot;velocity\u0026quot;, VelocityComponent clone init(Random value * 20 - 10, Random value * 20 - 10)) enemy addComponent(\u0026quot;sprite\u0026quot;, SpriteComponent clone init(\u0026quot;enemy\u0026quot;, 24, 24)) enemy addComponent(\u0026quot;collider\u0026quot;, ColliderComponent clone init(24, 24)) GameEngine addEntity(enemy) ) ) PlayState update := method(deltaTime, // Handle player input player := GameEngine entities first if(player, vel := player getComponent(\u0026quot;velocity\u0026quot;) vel dx = 0 vel dy = 0 if(InputManager isKeyPressed(\u0026quot;left\u0026quot;), vel dx = -100) if(InputManager isKeyPressed(\u0026quot;right\u0026quot;), vel dx = 100) if(InputManager isKeyPressed(\u0026quot;up\u0026quot;), vel dy = -100) if(InputManager isKeyPressed(\u0026quot;down\u0026quot;), vel dy = 100) ) ) // Main game engine methods GameEngine addEntity := method(entity, entities append(entity) entity ) GameEngine removeEntity := method(entity, entities remove(entity) ) GameEngine addSystem := method(system, systems append(system) system ) GameEngine setState := method(state, if(hasSlot(\u0026quot;currentState\u0026quot;) and currentState, currentState exit ) currentState := state currentState enter ) GameEngine update := method(deltaTime, // Update current state if(currentState, currentState update(deltaTime) ) // Update systems systems foreach(system, if(system hasSlot(\u0026quot;update\u0026quot;), system update(entities, deltaTime), entities foreach(entity, if(system canProcess(entity), system process(entity, deltaTime) ) ) ) ) // Remove inactive entities entities = entities select(e, e active) ) GameEngine render := method( if(currentState, currentState render ) renderSystem render(entities) ) GameEngine run := method( lastTime := Date now while(running, currentTime := Date now deltaTime := currentTime - lastTime if(deltaTime \u0026gt;= frameTime, update(deltaTime) render lastTime = currentTime ) // Small delay to prevent CPU spinning wait(0.001) ) ) GameEngine stop := method( running = false ) // Initialize and run game game := GameEngine clone init(800, 600) // Add systems game addSystem(MovementSystem clone) game addSystem(CollisionSystem clone init) game renderSystem := RenderSystem clone init // Set initial state game setState(MenuState) // Simulate some gameplay \u0026quot;=== Game Engine Demo ===\u0026quot; println MenuState handleSelection // Start game // Run a few frames 5 repeat(i, (\u0026quot;Frame \u0026quot; .. i) println game update(game frameTime) game render wait(0.1) ) Case Study 4: Build System # A build system similar to Make or Rake:\n// Build System BuildSystem := Object clone BuildSystem init := method( self tasks := Map clone self dependencies := Map clone self executed := list() self config := Map clone self ) Task := Object clone Task init := method(name, deps, action, self name := name self dependencies := if(deps, deps, list()) self action := action self outputs := list() self inputs := list() self ) Task execute := method(context, (\u0026quot;Executing task: \u0026quot; .. name) println if(action, action call(context) ) ) Task upToDate := method( if(outputs size == 0 or inputs size == 0, return false ) outputTime := outputs map(f, File with(f) lastModified) min inputTime := inputs map(f, File with(f) lastModified) max outputTime \u0026gt; inputTime ) // DSL for defining tasks BuildSystem task := method(name, t := Task clone init(name, list(), nil) tasks atPut(name, t) self currentTask := t call evalArgAt(0) t ) BuildSystem desc := method(description, if(currentTask, currentTask description := description ) ) BuildSystem depends := method( deps := call message arguments map(arg, call sender doMessage(arg) asString ) if(currentTask, currentTask dependencies = deps ) ) BuildSystem action := method( if(currentTask, currentTask action = call argAt(0) ) ) BuildSystem file := method(output, inputs, name := output t := Task clone init(name, list(), nil) t outputs = list(output) t inputs = if(inputs type == \u0026quot;List\u0026quot;, inputs, list(inputs)) tasks atPut(name, t) self currentTask := t call evalArgAt(2) t ) // Running tasks BuildSystem run := method(taskName, executed = list() executeTask(taskName) ) BuildSystem executeTask := method(taskName, if(executed contains(taskName), return ) task := tasks at(taskName) if(task isNil, Exception raise(\u0026quot;Task not found: \u0026quot; .. taskName) ) // Check if up to date if(task upToDate, (\u0026quot;Task \u0026quot; .. taskName .. \u0026quot; is up to date\u0026quot;) println return ) // Execute dependencies first task dependencies foreach(dep, executeTask(dep) ) // Execute the task task execute(self) executed append(taskName) ) // Utilities BuildSystem sh := method(command, (\u0026quot;$ \u0026quot; .. command) println System system(command) ) BuildSystem glob := method(pattern, Directory with(\u0026quot;.\u0026quot;) files select(f, f name matchesRegex(pattern) ) map(name) ) BuildSystem mkdir := method(path, Directory with(path) create ) BuildSystem cp := method(src, dest, File with(src) copyTo(dest) ) BuildSystem rm := method(path, File with(path) remove ) // Configuration BuildSystem configure := method( call message arguments foreach(arg, key := arg name value := call sender doMessage(arg arguments at(0)) config atPut(key, value) ) self ) // Example Buildfile build := BuildSystem clone init build configure( compiler: \u0026quot;gcc\u0026quot;, flags: \u0026quot;-Wall -O2\u0026quot;, srcDir: \u0026quot;src\u0026quot;, buildDir: \u0026quot;build\u0026quot; ) build task(\u0026quot;clean\u0026quot;, desc(\u0026quot;Remove all build artifacts\u0026quot;) action( rm(config at(\u0026quot;buildDir\u0026quot;)) \u0026quot;Cleaned\u0026quot; println ) ) build task(\u0026quot;init\u0026quot;, desc(\u0026quot;Initialize build directory\u0026quot;) action( mkdir(config at(\u0026quot;buildDir\u0026quot;)) ) ) build task(\u0026quot;compile\u0026quot;, desc(\u0026quot;Compile C sources\u0026quot;) depends(\u0026quot;init\u0026quot;) action( sources := glob(\u0026quot;src/*.c\u0026quot;) sources foreach(src, obj := src replaceSeq(\u0026quot;.c\u0026quot;, \u0026quot;.o\u0026quot;) replaceSeq(\u0026quot;src/\u0026quot;, \u0026quot;build/\u0026quot;) sh(config at(\u0026quot;compiler\u0026quot;) .. \u0026quot; \u0026quot; .. config at(\u0026quot;flags\u0026quot;) .. \u0026quot; -c \u0026quot; .. src .. \u0026quot; -o \u0026quot; .. obj) ) ) ) build task(\u0026quot;link\u0026quot;, desc(\u0026quot;Link object files\u0026quot;) depends(\u0026quot;compile\u0026quot;) action( objects := glob(\u0026quot;build/*.o\u0026quot;) join(\u0026quot; \u0026quot;) sh(config at(\u0026quot;compiler\u0026quot;) .. \u0026quot; \u0026quot; .. objects .. \u0026quot; -o build/app\u0026quot;) ) ) build task(\u0026quot;test\u0026quot;, desc(\u0026quot;Run tests\u0026quot;) depends(\u0026quot;link\u0026quot;) action( sh(\u0026quot;./build/app --test\u0026quot;) ) ) build task(\u0026quot;default\u0026quot;, depends(\u0026quot;link\u0026quot;) ) // File tasks for individual files build file(\u0026quot;build/main.o\u0026quot;, list(\u0026quot;src/main.c\u0026quot;), action( sh(config at(\u0026quot;compiler\u0026quot;) .. \u0026quot; \u0026quot; .. config at(\u0026quot;flags\u0026quot;) .. \u0026quot; -c src/main.c -o build/main.o\u0026quot;) ) ) // Run build build run(\u0026quot;default\u0026quot;) Lessons Learned # These case studies demonstrate several key insights about building real applications in Io:\nStrengths # Rapid Prototyping: Io\u0026rsquo;s minimal syntax and dynamic nature make it excellent for quickly building working prototypes.\nDSL Creation: The HTTP server\u0026rsquo;s routing, ORM\u0026rsquo;s query builder, and build system all show how naturally DSLs emerge in Io.\nFlexibility: The ability to modify anything at runtime made it easy to add features like middleware, validations, and hooks.\nConcurrency: The @ operator and coroutines made async request handling in the web server trivial.\nChallenges # Performance: For the game engine, Io\u0026rsquo;s interpreted nature and message passing overhead would limit frame rates in a real game.\nType Safety: The ORM would benefit from type checking that Io doesn\u0026rsquo;t provide, leading to potential runtime errors.\nTooling: Lack of IDE support makes maintaining larger codebases challenging.\nLibraries: Many features had to be built from scratch due to limited ecosystem.\nBest Practices # Use Prototypes Effectively: Define clear prototype hierarchies (Model -\u0026gt; User, Component -\u0026gt; PositionComponent).\nLeverage Message Passing: The game engine\u0026rsquo;s entity-component system naturally maps to message passing.\nBuild Abstractions: Each case study built higher-level abstractions (Repository, Task, System) on Io\u0026rsquo;s primitives.\nEmbrace DSLs: Don\u0026rsquo;t fight the language—use its strengths to create domain-appropriate interfaces.\nConclusion # These case studies show that Io is capable of building real applications, though with trade-offs. Its strengths in metaprogramming, DSL creation, and rapid prototyping make it excellent for certain domains, while performance-critical or large-scale applications might be better served by other languages. The key is understanding these trade-offs and using Io where its unique capabilities provide the most value.\nNext: Chapter 17 - Ecosystem and Libraries\n"},{"id":19,"href":"/docs/17-ecosystem-and-libraries/","title":"Ecosystem and Libraries","section":"Chapters","content":" Chapter 17: Ecosystem and Libraries # While Io has a smaller ecosystem compared to mainstream languages, it offers a thoughtfully curated set of libraries and tools. This chapter explores the available resources, how to use them effectively, and how to contribute to the Io ecosystem.\nCore Libraries # Io comes with several built-in libraries that extend its capabilities:\nFile I/O and System # // File operations file := File with(\u0026quot;data.txt\u0026quot;) // Reading if(file exists, contents := file contents lines := file readLines // Read with encoding file setEncoding(\u0026quot;UTF-8\u0026quot;) text := file contents ) // Writing file openForWriting file write(\u0026quot;Hello, World!\\n\u0026quot;) file write(\u0026quot;Line 2\\n\u0026quot;) file close // Appending file openForAppending file write(\u0026quot;Additional line\\n\u0026quot;) file close // File information file size println file lastModified println file isDirectory println // Directory operations dir := Directory with(\u0026quot;./src\u0026quot;) dir files foreach(file, file name println ) dir directories foreach(subdir, subdir path println ) // Recursive directory walking dir recursiveFilesOfType(\u0026quot;io\u0026quot;) foreach(ioFile, ioFile path println ) // System operations System system(\u0026quot;ls -la\u0026quot;) // Execute shell command System getEnvironmentVariable(\u0026quot;HOME\u0026quot;) println System setEnvironmentVariable(\u0026quot;MY_VAR\u0026quot;, \u0026quot;value\u0026quot;) System exit(0) Networking # // HTTP Client url := URL with(\u0026quot;https://api.example.com/data\u0026quot;) url fetch println // Simple GET request // With headers url setHeader(\u0026quot;Authorization\u0026quot;, \u0026quot;Bearer token\u0026quot;) url setHeader(\u0026quot;Content-Type\u0026quot;, \u0026quot;application/json\u0026quot;) response := url fetch // POST request url setMethod(\u0026quot;POST\u0026quot;) url setBody(\u0026quot;{\\\u0026quot;key\\\u0026quot;: \\\u0026quot;value\\\u0026quot;}\u0026quot;) response := url fetch // Socket programming // Server server := Socket clone server setHost(\u0026quot;127.0.0.1\u0026quot;) server setPort(8080) server bind server listen loop( client := server accept @( data := client readUntilSeq(\u0026quot;\\n\u0026quot;) client write(\u0026quot;Echo: \u0026quot; .. data) client close ) ) // Client client := Socket clone client setHost(\u0026quot;127.0.0.1\u0026quot;) client setPort(8080) client connect client write(\u0026quot;Hello, server!\\n\u0026quot;) response := client readUntilSeq(\u0026quot;\\n\u0026quot;) response println client close Date and Time # // Current date/time now := Date now now println // Date components now year println now month println now day println now hour println now minute println now second println // Date arithmetic tomorrow := now + Duration days(1) nextWeek := now + Duration weeks(1) hourAgo := now - Duration hours(1) // Formatting now asString(\u0026quot;%Y-%m-%d %H:%M:%S\u0026quot;) println now asString(\u0026quot;%B %d, %Y\u0026quot;) println // Parsing date := Date fromString(\u0026quot;2024-01-15\u0026quot;, \u0026quot;%Y-%m-%d\u0026quot;) // Duration duration := Duration clone duration setDays(2) setHours(3) setMinutes(30) duration asSeconds println // Timing code start := Date now // ... code to time ... elapsed := Date now - start (\u0026quot;Elapsed: \u0026quot; .. elapsed) println Regular Expressions # // Basic matching text := \u0026quot;The year 2024 has 365 days\u0026quot; text matchesRegex(\u0026quot;\\\\d+\u0026quot;) println // true // Finding matches match := text findRegex(\u0026quot;\\\\d+\u0026quot;) match start println // Starting position match end println // Ending position match string println // Matched string // All matches matches := text allMatchesOfRegex(\u0026quot;\\\\d+\u0026quot;) matches foreach(m, m string println // 2024, 365 ) // Replacement result := text replaceFirstRegex(\u0026quot;\\\\d+\u0026quot;, \u0026quot;N\u0026quot;) result println // The year N has 365 days result := text replaceAllRegex(\u0026quot;\\\\d+\u0026quot;, \u0026quot;N\u0026quot;) result println // The year N has N days // Capture groups email := \u0026quot;user@example.com\u0026quot; pattern := \u0026quot;(\\\\w+)@([\\\\w.]+)\u0026quot; if(match := email matchesOfRegex(pattern), match at(1) println // user match at(2) println // example.com ) // Compiling regex for reuse regex := Regex with(\u0026quot;\\\\b\\\\w{5}\\\\b\u0026quot;) // 5-letter words regex matches(\u0026quot;hello\u0026quot;) println // true regex matches(\u0026quot;hi\u0026quot;) println // false JSON # // Parsing JSON jsonString := \u0026quot;\u0026quot;\u0026quot; { \u0026quot;name\u0026quot;: \u0026quot;Alice\u0026quot;, \u0026quot;age\u0026quot;: 30, \u0026quot;interests\u0026quot;: [\u0026quot;coding\u0026quot;, \u0026quot;music\u0026quot;], \u0026quot;address\u0026quot;: { \u0026quot;city\u0026quot;: \u0026quot;New York\u0026quot;, \u0026quot;zip\u0026quot;: \u0026quot;10001\u0026quot; } } \u0026quot;\u0026quot;\u0026quot; data := jsonString parseJson data at(\u0026quot;name\u0026quot;) println // Alice data at(\u0026quot;interests\u0026quot;) at(0) println // coding data at(\u0026quot;address\u0026quot;) at(\u0026quot;city\u0026quot;) println // New York // Creating JSON person := Map with( \u0026quot;name\u0026quot;, \u0026quot;Bob\u0026quot;, \u0026quot;age\u0026quot;, 25, \u0026quot;active\u0026quot;, true, \u0026quot;tags\u0026quot;, list(\u0026quot;developer\u0026quot;, \u0026quot;gamer\u0026quot;) ) json := person asJson json println // {\u0026quot;name\u0026quot;:\u0026quot;Bob\u0026quot;,\u0026quot;age\u0026quot;:25,\u0026quot;active\u0026quot;:true,\u0026quot;tags\u0026quot;:[\u0026quot;developer\u0026quot;,\u0026quot;gamer\u0026quot;]} // Pretty printing json := person asJson(true) // Pretty format XML # // Parsing XML xmlString := \u0026quot;\u0026quot;\u0026quot; \u0026lt;root\u0026gt; \u0026lt;person id=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;name\u0026gt;Alice\u0026lt;/name\u0026gt; \u0026lt;age\u0026gt;30\u0026lt;/age\u0026gt; \u0026lt;/person\u0026gt; \u0026lt;person id=\u0026quot;2\u0026quot;\u0026gt; \u0026lt;name\u0026gt;Bob\u0026lt;/name\u0026gt; \u0026lt;age\u0026gt;25\u0026lt;/age\u0026gt; \u0026lt;/person\u0026gt; \u0026lt;/root\u0026gt; \u0026quot;\u0026quot;\u0026quot; doc := SGML parseString(xmlString) root := doc root // Navigate XML people := root elementsWithName(\u0026quot;person\u0026quot;) people foreach(person, id := person attributeAt(\u0026quot;id\u0026quot;) name := person elementWithName(\u0026quot;name\u0026quot;) text age := person elementWithName(\u0026quot;age\u0026quot;) text (id .. \u0026quot;: \u0026quot; .. name .. \u0026quot; (\u0026quot; .. age .. \u0026quot;)\u0026quot;) println ) // Build XML doc := SGML clone root := doc addElement(\u0026quot;catalog\u0026quot;) book := root addElement(\u0026quot;book\u0026quot;) book setAttribute(\u0026quot;isbn\u0026quot;, \u0026quot;123456\u0026quot;) book addElement(\u0026quot;title\u0026quot;) setText(\u0026quot;Io Programming\u0026quot;) book addElement(\u0026quot;author\u0026quot;) setText(\u0026quot;Jane Doe\u0026quot;) book addElement(\u0026quot;price\u0026quot;) setText(\u0026quot;29.99\u0026quot;) doc asString println Addon System # Io\u0026rsquo;s addon system allows loading C-based extensions:\n// Loading addons Addon load(\u0026quot;Socket\u0026quot;) // Network programming Addon load(\u0026quot;Random\u0026quot;) // Random number generation Addon load(\u0026quot;Regex\u0026quot;) // Regular expressions Addon load(\u0026quot;SQLite\u0026quot;) // Database access // Check available addons Addon availableAddons foreach(name, name println ) // Addon information addon := Addon named(\u0026quot;Socket\u0026quot;) addon path println addon dependencies println Database Libraries # SQLite # // SQLite integration db := SQLite clone db open(\u0026quot;app.db\u0026quot;) // Create table db exec(\u0026quot;\u0026quot;\u0026quot; CREATE TABLE IF NOT EXISTS users ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, email TEXT UNIQUE, created_at DATETIME DEFAULT CURRENT_TIMESTAMP ) \u0026quot;\u0026quot;\u0026quot;) // Insert data stmt := db prepare(\u0026quot;INSERT INTO users (name, email) VALUES (?, ?)\u0026quot;) stmt bind(1, \u0026quot;Alice\u0026quot;) stmt bind(2, \u0026quot;alice@example.com\u0026quot;) stmt step stmt reset // Query data results := db exec(\u0026quot;SELECT * FROM users WHERE name LIKE 'A%'\u0026quot;) results foreach(row, (\u0026quot;ID: \u0026quot; .. row at(\u0026quot;id\u0026quot;) .. \u0026quot;, Name: \u0026quot; .. row at(\u0026quot;name\u0026quot;)) println ) // Prepared statements with results stmt := db prepare(\u0026quot;SELECT * FROM users WHERE id = ?\u0026quot;) stmt bind(1, 1) while(stmt step == SQLite ROW, name := stmt columnText(1) email := stmt columnText(2) (name .. \u0026quot; - \u0026quot; .. email) println ) stmt finalize db close // Transactions db begin try( db exec(\u0026quot;INSERT INTO users ...\u0026quot;) db exec(\u0026quot;UPDATE users ...\u0026quot;) db commit ) catch(Exception, e, db rollback e raise ) Graphics and GUI # OpenGL # // OpenGL addon (if available) Addon load(\u0026quot;OpenGL\u0026quot;) // Basic window setup window := GLApp clone window width := 800 window height := 600 window title := \u0026quot;Io OpenGL\u0026quot; window draw := method( glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) glBegin(GL_TRIANGLES) glColor3f(1, 0, 0) glVertex2f(-0.5, -0.5) glColor3f(0, 1, 0) glVertex2f(0.5, -0.5) glColor3f(0, 0, 1) glVertex2f(0, 0.5) glEnd swapBuffers ) window run Image Processing # // Image addon Addon load(\u0026quot;Image\u0026quot;) // Load and manipulate images img := Image clone img open(\u0026quot;photo.jpg\u0026quot;) // Get information img width println img height println img componentCount println // Color channels // Basic operations img resize(800, 600) img crop(100, 100, 400, 300) img flip(\u0026quot;horizontal\u0026quot;) img rotate(90) // Filters img blur(5) img sharpen img adjustBrightness(1.2) img adjustContrast(1.5) img grayscale // Save img save(\u0026quot;modified.png\u0026quot;) // Create new image canvas := Image clone canvas allocate(500, 500, 3) // RGB canvas fill(Color with(0.5, 0.5, 1.0)) // Light blue // Draw on image canvas drawLine(0, 0, 500, 500, Color red) canvas drawCircle(250, 250, 100, Color green) canvas drawRectangle(100, 100, 300, 200, Color blue) canvas save(\u0026quot;drawing.png\u0026quot;) Cryptography # // Crypto addon Addon load(\u0026quot;MD5\u0026quot;) Addon load(\u0026quot;SHA1\u0026quot;) // Hashing text := \u0026quot;Hello, World!\u0026quot; md5 := MD5 clone md5 appendSeq(text) md5 hexDigest println // MD5 hash sha := SHA1 clone sha appendSeq(text) sha hexDigest println // SHA1 hash // File hashing file := File with(\u0026quot;document.pdf\u0026quot;) hash := MD5 hashFile(file path) hash println // HMAC (if available) key := \u0026quot;secret-key\u0026quot; message := \u0026quot;Important message\u0026quot; hmac := HMAC sha256(key, message) hmac println Third-Party Libraries # Package Management # While Io doesn\u0026rsquo;t have a centralized package manager like npm or pip, libraries can be managed through:\n// Simple package loader PackageLoader := Object clone PackageLoader paths := list( \u0026quot;~/.io/packages\u0026quot;, \u0026quot;/usr/local/io/packages\u0026quot;, \u0026quot;./packages\u0026quot; ) PackageLoader load := method(name, paths foreach(path, packageFile := Path with(path, name, \u0026quot;init.io\u0026quot;) if(File with(packageFile) exists, doFile(packageFile) return true ) ) Exception raise(\u0026quot;Package not found: \u0026quot; .. name) ) // Usage PackageLoader load(\u0026quot;web-framework\u0026quot;) PackageLoader load(\u0026quot;test-framework\u0026quot;) Creating Libraries # Structure for an Io library:\n// mylib/init.io - Entry point MyLib := Object clone MyLib version := \u0026quot;1.0.0\u0026quot; // Load components doRelativeFile(\u0026quot;core.io\u0026quot;) doRelativeFile(\u0026quot;utils.io\u0026quot;) doRelativeFile(\u0026quot;extensions.io\u0026quot;) // Export public API MyLib // mylib/core.io MyLib Core := Object clone MyLib Core process := method(data, // Core functionality ) // mylib/utils.io MyLib Utils := Object clone MyLib Utils helper := method( // Utility functions ) // mylib/extensions.io // Extend built-in types List customMethod := method( // Extended functionality ) Testing Frameworks # Simple testing framework example:\n// SimpleTest framework Test := Object clone Test suites := list() Test describe := method(name, block, suite := TestSuite clone suite name := name suite tests := list() suite it := method(desc, testBlock, tests append(list(desc, testBlock)) ) block call(suite) suites append(suite) ) Test run := method( totalTests := 0 passedTests := 0 suites foreach(suite, (\u0026quot;\\n\u0026quot; .. suite name) println (\u0026quot;=\u0026quot; repeated(suite name size)) println suite tests foreach(test, desc := test at(0) block := test at(1) totalTests = totalTests + 1 e := try( block call (\u0026quot; ✓ \u0026quot; .. desc) println passedTests = passedTests + 1 ) catch(Exception, e, (\u0026quot; ✗ \u0026quot; .. desc) println (\u0026quot; \u0026quot; .. e message) println ) ) ) (\u0026quot;\\n\u0026quot; .. passedTests .. \u0026quot;/\u0026quot; .. totalTests .. \u0026quot; tests passed\u0026quot;) println ) // Usage Test describe(\u0026quot;Array operations\u0026quot;, suite, suite it(\u0026quot;should append elements\u0026quot;, arr := list(1, 2) arr append(3) assert(arr size == 3) ) suite it(\u0026quot;should remove elements\u0026quot;, arr := list(1, 2, 3) arr remove(2) assert(arr contains(2) not) ) ) Test run Documentation Tools # Generating Documentation # // Simple documentation generator DocGen := Object clone DocGen init := method( self docs := Map clone self ) DocGen document := method(obj, name, info := Map clone info atPut(\u0026quot;name\u0026quot;, name) info atPut(\u0026quot;type\u0026quot;, obj type) info atPut(\u0026quot;slots\u0026quot;, obj slotNames sort) // Extract method signatures methods := Map clone obj slotNames foreach(slotName, slot := obj getSlot(slotName) if(slot type == \u0026quot;Block\u0026quot;, methods atPut(slotName, slot argumentNames) ) ) info atPut(\u0026quot;methods\u0026quot;, methods) docs atPut(name, info) self ) DocGen generateMarkdown := method( md := \u0026quot;# API Documentation\\n\\n\u0026quot; docs foreach(name, info, md = md .. \u0026quot;## \u0026quot; .. name .. \u0026quot;\\n\\n\u0026quot; md = md .. \u0026quot;**Type**: \u0026quot; .. info at(\u0026quot;type\u0026quot;) .. \u0026quot;\\n\\n\u0026quot; methods := info at(\u0026quot;methods\u0026quot;) if(methods size \u0026gt; 0, md = md .. \u0026quot;### Methods\\n\\n\u0026quot; methods foreach(method, args, md = md .. \u0026quot;- `\u0026quot; .. method .. \u0026quot;(\u0026quot; .. args join(\u0026quot;, \u0026quot;) .. \u0026quot;)`\\n\u0026quot; ) md = md .. \u0026quot;\\n\u0026quot; ) ) md ) // Usage docGen := DocGen clone init docGen document(MyClass, \u0026quot;MyClass\u0026quot;) docGen document(MyUtils, \u0026quot;MyUtils\u0026quot;) File with(\u0026quot;API.md\u0026quot;) openForWriting write(docGen generateMarkdown) close Development Tools # REPL Enhancements # // Enhanced REPL REPL := Object clone REPL history := list() REPL commands := Map clone REPL registerCommand := method(name, block, commands atPut(name, block) ) REPL run := method( loop( \u0026quot;io\u0026gt; \u0026quot; print input := File standardInput readLine if(input beginsWithSeq(\u0026quot;:\u0026quot;), // Handle commands cmd := input afterSeq(\u0026quot;:\u0026quot;) if(commands hasKey(cmd), commands at(cmd) call, (\u0026quot;Unknown command: \u0026quot; .. cmd) println ), // Evaluate Io code history append(input) e := try( result := doString(input) (\u0026quot;==\u0026gt; \u0026quot; .. result) println ) catch(Exception, e, (\u0026quot;Error: \u0026quot; .. e message) println ) ) ) ) // Register commands REPL registerCommand(\u0026quot;help\u0026quot;, block( \u0026quot;Available commands:\u0026quot; println commands keys foreach(cmd, (\u0026quot; :\u0026quot; .. cmd) println ) )) REPL registerCommand(\u0026quot;history\u0026quot;, block( history foreach(i, line, (i .. \u0026quot;: \u0026quot; .. line) println ) )) REPL registerCommand(\u0026quot;clear\u0026quot;, block( System system(\u0026quot;clear\u0026quot;) )) REPL registerCommand(\u0026quot;quit\u0026quot;, block( System exit )) // Run enhanced REPL REPL run Debugging Tools # // Simple debugger Debugger := Object clone Debugger breakpoints := list() Debugger stepping := false Object debug := method( Debugger enter(self, call) ) Debugger enter := method(context, callObj, \u0026quot;=== Debugger ===\u0026quot; println (\u0026quot;Context: \u0026quot; .. context type) println (\u0026quot;Location: \u0026quot; .. callObj message) println loop( \u0026quot;\u0026gt; \u0026quot; print cmd := File standardInput readLine split(\u0026quot; \u0026quot;) if(cmd at(0) == \u0026quot;inspect\u0026quot;, target := cmd at(1) if(target, obj := context doString(target) obj slotNames foreach(slot, (\u0026quot; \u0026quot; .. slot .. \u0026quot;: \u0026quot; .. obj getSlot(slot) type) println ) ) ) if(cmd at(0) == \u0026quot;eval\u0026quot;, code := cmd slice(1) join(\u0026quot; \u0026quot;) result := context doString(code) result println ) if(cmd at(0) == \u0026quot;continue\u0026quot;, break ) if(cmd at(0) == \u0026quot;help\u0026quot;, \u0026quot;Commands: inspect \u0026lt;obj\u0026gt;, eval \u0026lt;code\u0026gt;, continue, help\u0026quot; println ) ) ) Community Resources # Finding Libraries # Common sources for Io libraries:\nGitHub: Search for \u0026ldquo;io-language\u0026rdquo; or \u0026ldquo;iolanguage\u0026rdquo; topics Official Repository: https://github.com/IoLanguage/io Community Addons: Various developers maintain addon collections Contributing # Creating an addon for the community:\n// addon.io - Addon metadata Addon := Object clone Addon name := \u0026quot;MyAddon\u0026quot; Addon version := \u0026quot;1.0.0\u0026quot; Addon author := \u0026quot;Your Name\u0026quot; Addon description := \u0026quot;Description of what your addon does\u0026quot; Addon license := \u0026quot;MIT\u0026quot; Addon dependencies := list(\u0026quot;OtherAddon\u0026quot;) Addon install := method( // Installation logic \u0026quot;Installing \u0026quot; .. name .. \u0026quot; v\u0026quot; .. version println // Copy files // Compile C extensions if needed // Register with Io ) Addon uninstall := method( // Cleanup logic ) // Make addon discoverable Addon register Performance Libraries # Profiling # // Simple profiler Profiler := Object clone Profiler data := Map clone Object profile := method(name, start := Date now result := call evalArgAt(0) elapsed := Date now - start if(Profiler data hasKey(name) not, Profiler data atPut(name, list(0, 0)) ) stats := Profiler data at(name) stats atPut(0, stats at(0) + 1) // Count stats atPut(1, stats at(1) + elapsed) // Total time result ) Profiler report := method( \u0026quot;=== Profile Report ===\u0026quot; println data foreach(name, stats, count := stats at(0) total := stats at(1) avg := total / count (name .. \u0026quot;: \u0026quot; .. count .. \u0026quot; calls, \u0026quot; .. total .. \u0026quot;s total, \u0026quot; .. avg .. \u0026quot;s average\u0026quot;) println ) ) // Usage profile(\u0026quot;database\u0026quot;, // Expensive operation wait(0.1) ) Profiler report Future of Io Libraries # The Io ecosystem continues to evolve with:\nWebAssembly Support: Potential for running Io in browsers Modern Addons: Integration with contemporary libraries Cloud Services: AWS, Azure, GCP client libraries Machine Learning: Bindings to TensorFlow, PyTorch Improved Tooling: Better IDE support, linters, formatters Conclusion # While Io\u0026rsquo;s ecosystem is smaller than mainstream languages, it provides essential functionality and excellent extensibility through its addon system. The simplicity of creating libraries, combined with seamless C integration, means that missing functionality can often be added quickly. The community, though small, is knowledgeable and helpful, making it easy to find or create the tools you need.\nThe key to working effectively with Io\u0026rsquo;s ecosystem is understanding that it favors simplicity and extensibility over having every possible library pre-built. This philosophy encourages developers to understand their tools deeply and create exactly what they need.\nNext: Chapter 18 - Conclusion\n"},{"id":20,"href":"/docs/18-conclusion/","title":"Conclusion","section":"Chapters","content":" Chapter 18: Conclusion - The Io Way # We\u0026rsquo;ve reached the end of our journey through the Io programming language. From its minimal syntax to its powerful metaprogramming capabilities, from prototype-based objects to concurrent actors, we\u0026rsquo;ve explored a language that challenges conventional programming wisdom. This final chapter reflects on what we\u0026rsquo;ve learned, when to use Io, and what it teaches us about programming itself.\nWhat Makes Io Special # After eighteen chapters, we can distill Io\u0026rsquo;s essence to a few key principles:\nRadical Simplicity # Io achieves remarkable expressiveness with minimal concepts:\nEverything is an object All computation is message passing Objects clone objects (no classes) Code is data (messages are objects) Compare Io\u0026rsquo;s ~10,000 lines of C to Python\u0026rsquo;s ~500,000 or Java\u0026rsquo;s millions. This isn\u0026rsquo;t just about code size—it\u0026rsquo;s about conceptual simplicity. You can understand all of Io, not just use it.\nUniformity # Where other languages have special cases, Io has objects:\n// Numbers? Objects. 5 squared := method(self * self) // Booleans? Objects. true celebrate := method(\u0026quot;Yes!\u0026quot; println) // Control structures? Objects receiving messages. if := method(condition, trueBlock, falseBlock, ...) // Operators? Messages. Number + := method(n, ...) // Even nil? An object. nil comfort := method(\u0026quot;It's okay to be nothing\u0026quot; println) This uniformity isn\u0026rsquo;t just elegant—it\u0026rsquo;s powerful. When everything follows the same rules, there\u0026rsquo;s less to remember and more you can do.\nOpenness # Most languages protect you from yourself. Io trusts you completely:\n// Modify fundamental types String shout := method(self upper .. \u0026quot;!!!\u0026quot;) // Change how the language works Object if := method(...) // Redefine conditionals // Inspect everything anyObject slotNames // See all slots anyMethod code // See implementation This openness enables profound metaprogramming but requires responsibility.\nWhen to Use Io # Io excels in specific contexts:\nRapid Prototyping # When you need to explore ideas quickly:\n// From idea to working code in minutes Api := Object clone Api route := method(path, handler, ...) Api get(\u0026quot;/users\u0026quot;, block(...)) Api start(8080) Domain-Specific Languages # When you need expressive, domain-appropriate interfaces:\nrecipe \u0026quot;Pasta\u0026quot; serves(4) { boil water in(\u0026quot;large pot\u0026quot;) add pasta after(\u0026quot;water boils\u0026quot;) cook for(8) minutes drain serve with(\u0026quot;marinara sauce\u0026quot;) } Learning and Teaching # When you want to understand programming concepts deeply:\nHow objects really work What message passing means How languages are implemented Why certain design choices matter Embedded Scripting # When you need a lightweight, embeddable language:\nGame scripting Application automation Configuration languages Plugin systems When Not to Use Io # Io has limitations to consider:\nPerformance-Critical Systems # // Io: Elegant but slower numbers map(x, x * x) select(x, x \u0026gt; 100) // C: Verbose but fast for(int i = 0; i \u0026lt; n; i++) { squared[i] = numbers[i] * numbers[i]; if(squared[i] \u0026gt; 100) ... } Message passing has overhead. For number crunching, system programming, or real-time systems, choose C, Rust, or C++.\nLarge Team Projects # Io lacks:\nStatic type checking Comprehensive IDE support Large ecosystem of libraries Extensive documentation Big community for support For enterprise applications with many developers, Java, C#, or TypeScript offer better tooling and guardrails.\nProduction Web Services # While you can build web services in Io, you probably shouldn\u0026rsquo;t for production:\nLimited web frameworks No battle-tested libraries Small community for security issues Few deployment options Use Python, Ruby, JavaScript, or Go instead.\nLessons for Other Languages # Even if you never use Io professionally, it teaches valuable lessons:\nQuestion Everything # Why do we need classes? Io shows prototypes work fine. Why special syntax for control flow? Io uses methods. Why distinguish data and code? Io treats both as messages.\nThese aren\u0026rsquo;t necessarily better—but questioning assumptions makes you a better programmer.\nSimplicity Has Power # Io shows how much you can achieve with few concepts. This influences how you design:\nAPIs with consistent interfaces Systems with uniform principles Code that does one thing well Metaprogramming Isn\u0026rsquo;t Magic # In Io, metaprogramming is just programming:\n// Not magic, just objects method := block(x, x * 2) method code println // x *(2) method setCode(\u0026quot;x + 2\u0026quot;) // Changed! This demystifies metaprogramming in any language.\nEverything Has Trade-offs # Io\u0026rsquo;s choices have consequences:\nSimplicity vs Performance Flexibility vs Safety Power vs Complexity Expressiveness vs Familiarity Understanding these trade-offs helps you choose the right tool for each job.\nIo\u0026rsquo;s Influence # Despite its small community, Io has influenced programming:\nJavaScript\u0026rsquo;s Prototype Pattern # // JavaScript embracing prototypes (pre-ES6) var animal = { speak: function() { console.log(\u0026quot;...\u0026quot;); } }; var dog = Object.create(animal); dog.bark = function() { console.log(\u0026quot;Woof!\u0026quot;); }; Ruby\u0026rsquo;s Method Missing # class DynamicObject def method_missing(name, *args) if name.to_s.start_with?(\u0026quot;get_\u0026quot;) # Handle dynamically end end end Minimalist Language Design # Languages like Lua and Factor share Io\u0026rsquo;s minimalist philosophy, proving that small can be powerful.\nThe Future of Io # Io may never become mainstream, and that\u0026rsquo;s okay. Its value isn\u0026rsquo;t in market share but in:\nEducational Impact # Io remains excellent for teaching:\nPrototype-based OOP Message passing Language implementation Metaprogramming concepts Research Platform # Io\u0026rsquo;s simplicity makes it ideal for experimenting with:\nNew concurrency models Novel object systems DSL techniques Language features Inspiration # Future language designers study Io to understand:\nHow simple a language can be Alternative object models The power of uniformity Trade-offs in language design Personal Reflection # Learning Io changes how you think about programming. You realize that many \u0026ldquo;fundamental\u0026rdquo; concepts are just choices. Classes aren\u0026rsquo;t necessary. Syntax isn\u0026rsquo;t sacred. Types aren\u0026rsquo;t mandatory. These aren\u0026rsquo;t revelations that everything should be like Io—rather, they free you to think more broadly about problems and solutions.\nWhen you return to your daily programming language—be it Python, JavaScript, Java, or something else—you bring new perspectives:\nYou see the prototype pattern hiding in JavaScript\u0026rsquo;s classes You recognize message passing in Ruby\u0026rsquo;s method calls You understand metaprogramming isn\u0026rsquo;t mysterious You appreciate both the safety of types and the freedom of their absence A Final Example # Let\u0026rsquo;s end with a small program that captures Io\u0026rsquo;s spirit:\n// The Io Philosophy in Code Philosophy := Object clone Philosophy simplicity := \u0026quot;Everything is an object\u0026quot; Philosophy uniformity := \u0026quot;Everything is a message\u0026quot; Philosophy openness := \u0026quot;Everything is modifiable\u0026quot; Philosophy embrace := method(concept, (\u0026quot;Embracing \u0026quot; .. concept .. \u0026quot;...\u0026quot;) println self setSlot(concept, true) self ) Philosophy question := method(assumption, (\u0026quot;Why must \u0026quot; .. assumption .. \u0026quot;?\u0026quot;) println (\u0026quot;Perhaps there's another way...\u0026quot;) println ) Philosophy learn := method( lessons := list( \u0026quot;Simplicity enables understanding\u0026quot;, \u0026quot;Uniformity reduces cognitive load\u0026quot;, \u0026quot;Openness enables exploration\u0026quot;, \u0026quot;Constraints inspire creativity\u0026quot;, \u0026quot;Every choice has consequences\u0026quot; ) lessons foreach(lesson, (\u0026quot; • \u0026quot; .. lesson) println wait(0.5) // Pause to reflect ) ) // The journey journey := Philosophy clone journey embrace(\u0026quot;simplicity\u0026quot;) \\ embrace(\u0026quot;uniformity\u0026quot;) \\ embrace(\u0026quot;openness\u0026quot;) journey question(\u0026quot;languages be complex\u0026quot;) journey question(\u0026quot;we have classes\u0026quot;) journey question(\u0026quot;syntax be fixed\u0026quot;) \u0026quot;Lessons learned:\u0026quot; println journey learn \u0026quot;Thank you for exploring Io.\u0026quot; println \u0026quot;May it inspire your programming journey.\u0026quot; println Parting Thoughts # Io isn\u0026rsquo;t trying to replace your favorite language. It\u0026rsquo;s not competing for market dominance. It\u0026rsquo;s not the solution to all programming problems.\nWhat Io offers is perspective—a radically different view of what programming can be. It shows that our familiar concepts aren\u0026rsquo;t immutable laws but design choices. It demonstrates that simplicity and power aren\u0026rsquo;t opposites. It proves that small languages can have big ideas.\nWhether you use Io for a weekend experiment, a personal project, or just intellectual exploration, it will change how you think about programming. You\u0026rsquo;ll question more, assume less, and see possibilities where you once saw constraints.\nThat\u0026rsquo;s the real gift of Io: not the language itself, but the mindset it instills. A mindset that questions, explores, and imagines. A mindset that sees programming not as applying fixed rules but as creatively solving problems with the tools at hand—or creating new tools when needed.\nThank You # Thank you for joining me on this exploration of Io. I hope you\u0026rsquo;ve found it as enlightening to read as I found it to write. The language may be small, but the ideas are vast.\nNow go forth and experiment. Clone some objects. Send some messages. Build something unusual. Question something fundamental. And remember: in Io, as in programming, as in life—everything is possible when you embrace simplicity, seek uniformity, and remain open to new ideas.\nHappy coding, and may your messages always find their slots.\nEnd of Book\nAppendices # For continued learning:\nAppendix A: Io Language Reference Appendix B: Standard Library Documentation Appendix C: Building Io from Source Appendix D: Creating C Addons Appendix E: Io Resources and Community Visit https://iolanguage.org for more information.\n\u0026ldquo;Simplicity is the ultimate sophistication.\u0026rdquo; — Leonardo da Vinci\n"}]