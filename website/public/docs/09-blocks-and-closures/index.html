<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  Chapter 9: Blocks and Closures
  
  #
  

Blocks in Io are first-class objects representing unevaluated code. They capture their creation context, making them closures. This chapter explores blocks, methods, closures, and how they enable functional programming patterns in Io.

  Understanding Blocks and Methods
  
  #
  

In Io, block and method are similar but have a crucial difference:
// Block - creates its own scope
blk := block(x, x * 2)
blk call(5) println  // 10

// Method - shares scope with receiver
obj := Object clone
obj value := 10
obj meth := method(x, x * value)  // Can access &#39;value&#39;
obj blk := block(x, x * value)    // Error when called - no &#39;value&#39; in block scope

obj meth(5) println  // 50
// obj blk call(5)  // Exception: value not found

The key difference:">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://example.org/docs/09-blocks-and-closures/">
  <meta property="og:site_name" content="The Io Programming Language">
  <meta property="og:title" content="Blocks and Closures">
  <meta property="og:description" content="Chapter 9: Blocks and Closures # Blocks in Io are first-class objects representing unevaluated code. They capture their creation context, making them closures. This chapter explores blocks, methods, closures, and how they enable functional programming patterns in Io.
Understanding Blocks and Methods # In Io, block and method are similar but have a crucial difference:
// Block - creates its own scope blk := block(x, x * 2) blk call(5) println // 10 // Method - shares scope with receiver obj := Object clone obj value := 10 obj meth := method(x, x * value) // Can access &#39;value&#39; obj blk := block(x, x * value) // Error when called - no &#39;value&#39; in block scope obj meth(5) println // 50 // obj blk call(5) // Exception: value not found The key difference:">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
<title>Blocks and Closures | The Io Programming Language</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://example.org/docs/09-blocks-and-closures/">
<link rel="stylesheet" href="/book.min.4cb515616f615b2a0bff9bc1586e8704536e3d9ada38b7ed57973b3f954b35de.css" integrity="sha256-TLUVYW9hWyoL/5vBWG6HBFNuPZraOLftV5c7P5VLNd4=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.20734475dc55187083547d768bab4ab01cefdbd4f93d7659611364d02969e74c.js" integrity="sha256-IHNEddxVGHCDVH12i6tKsBzv29T5PXZZYRNk0Clp50w=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <link rel="stylesheet" href="/custom.css">
</head>
<body dir="ltr" class="book-kind-page book-type-docs book-layout-">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  
  
  <header class="top-header">
    <div class="header-container">
      <div class="header-brand">
        <a href="/" class="header-title">The Io Programming Language</a>
      </div>
      <div class="header-search">
        
<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>


      </div>
    </div>
  </header>
  
  <main class="container flex with-header">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>













  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/00-preface/" class="">Why Io?</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/01-introduction/" class="">Introduction</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/02-getting-started/" class="">Getting Started</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/03-everything-is-an-object/" class="">Everything is an Object</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/04-prototypes-not-classes/" class="">Prototypes, Not Classes</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/05-messages-and-slots/" class="">Messages and Slots</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/06-cloning-and-inheritance/" class="">Cloning and Inheritance</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/07-control-flow/" class="">Control Flow</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/08-collections/" class="">Collections</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/09-blocks-and-closures/" class="active">Blocks and Closures</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/10-exceptions/" class="">Exceptions</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/11-metaprogramming/" class="">Metaprogramming</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/12-concurrency/" class="">Concurrency</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/13-domain-specific-languages/" class="">Domain-Specific Languages</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/14-c-integration/" class="">C Integration</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/15-real-world-patterns/" class="">Real-World Patterns</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/16-case-studies/" class="">Case Studies</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/17-ecosystem-and-libraries/" class="">Ecosystem and Libraries</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/18-conclusion/" class="">Conclusion</a>
  

        </li>
      
    
  </ul>










  
<ul>
  
  <li>
    
    <a href="https://github.com/IoLanguage/io"  target="_blank" rel="noopener">
        GitHub
      </a>
  </li>
  
  <li>
    
    <a href="https://iolanguage.org"  target="_blank" rel="noopener">
        Io Language
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Blocks and Closures</h3>

  <label for="toc-control">
    
  </label>
</div>


  
 
      </header>

      
      
<article class="markdown book-article">
  
  
  
  
  
  
  
    
  
  
  <div class="chapter-header">
    <h1 class="chapter-title">Blocks and Closures</h1>
    
    <div class="chapter-number">Chapter 9</div>
    
  </div>
  
  
  
  
  
<p>Blocks in Io are first-class objects representing unevaluated code. They capture their creation context, making them closures. This chapter explores blocks, methods, closures, and how they enable functional programming patterns in Io.</p>
<h2 id="understanding-blocks-and-methods">
  Understanding Blocks and Methods
  
  <a class="anchor" href="#understanding-blocks-and-methods">#</a>
  
</h2>
<p>In Io, <code>block</code> and <code>method</code> are similar but have a crucial difference:</p>
<pre><code class="language-io">// Block - creates its own scope
blk := block(x, x * 2)
blk call(5) println  // 10

// Method - shares scope with receiver
obj := Object clone
obj value := 10
obj meth := method(x, x * value)  // Can access 'value'
obj blk := block(x, x * value)    // Error when called - no 'value' in block scope

obj meth(5) println  // 50
// obj blk call(5)  // Exception: value not found
</code></pre>
<p>The key difference:</p>
<ul>
<li><strong>Methods</strong> have access to <code>self</code> and the receiver&rsquo;s slots</li>
<li><strong>Blocks</strong> create their own scope and don&rsquo;t have automatic access to <code>self</code></li>
</ul>
<h2 id="creating-and-calling-blocks">
  Creating and Calling Blocks
  
  <a class="anchor" href="#creating-and-calling-blocks">#</a>
  
</h2>
<pre><code class="language-io">// Simple block
double := block(x, x * 2)
double call(5) println  // 10

// Multi-argument block
add := block(a, b, a + b)
add call(3, 4) println  // 7

// No-argument block
greet := block(&quot;Hello!&quot; println)
greet call  // Hello!

// Blocks are objects
double type println  // Block
double proto println  // Block_0x...
</code></pre>
<h2 id="blocks-as-closures">
  Blocks as Closures
  
  <a class="anchor" href="#blocks-as-closures">#</a>
  
</h2>
<p>Blocks capture variables from their creation context:</p>
<pre><code class="language-io">makeCounter := method(
    count := 0
    block(
        count = count + 1
        count
    )
)

counter1 := makeCounter()
counter2 := makeCounter()

counter1 call println  // 1
counter1 call println  // 2
counter2 call println  // 1 (independent)
counter1 call println  // 3
</code></pre>
<p>This is different from many languages where you need special syntax for closures:</p>
<pre><code class="language-javascript">// JavaScript
function makeCounter() {
    let count = 0;
    return function() {
        count++;
        return count;
    };
}
</code></pre>
<p>In Io, all blocks are closures automatically.</p>
<h2 id="the-scope-chain">
  The Scope Chain
  
  <a class="anchor" href="#the-scope-chain">#</a>
  
</h2>
<p>Understanding scope is crucial for blocks:</p>
<pre><code class="language-io">x := &quot;global&quot;

outer := method(
    x := &quot;outer&quot;
    
    inner := block(
        x println  // What prints?
    )
    
    inner
)

myBlock := outer()
myBlock call  // &quot;outer&quot; - captured from creation context

x = &quot;changed global&quot;
myBlock call  // Still &quot;outer&quot; - closure captures variables, not global
</code></pre>
<h2 id="methods-and-self">
  Methods and self
  
  <a class="anchor" href="#methods-and-self">#</a>
  
</h2>
<p>Methods have access to <code>self</code> (the receiver):</p>
<pre><code class="language-io">Calculator := Object clone
Calculator value := 0

Calculator add := method(n,
    self value = self value + n  // Explicit self
    value  // Implicit self
)

Calculator addBlock := block(n,
    // No automatic self here!
    // Would need to pass it explicitly
)

calc := Calculator clone
calc add(5) println  // 5
calc add(3) println  // 8
</code></pre>
<h2 id="block-arguments-and-defaults">
  Block Arguments and Defaults
  
  <a class="anchor" href="#block-arguments-and-defaults">#</a>
  
</h2>
<pre><code class="language-io">// Variable arguments
sumAll := block(
    args := call message arguments
    total := 0
    args foreach(arg,
        total = total + call sender doMessage(arg)
    )
    total
)

sumAll call(1, 2, 3, 4, 5) println  // 15

// Default arguments (manual)
greetWithDefault := block(name,
    if(name isNil, name = &quot;World&quot;)
    (&quot;Hello, &quot; .. name .. &quot;!&quot;) println
)

greetWithDefault call(&quot;Alice&quot;)  // Hello, Alice!
greetWithDefault call()        // Hello, World!
</code></pre>
<h2 id="higher-order-functions">
  Higher-Order Functions
  
  <a class="anchor" href="#higher-order-functions">#</a>
  
</h2>
<p>Blocks enable functional programming patterns:</p>
<pre><code class="language-io">// Functions returning functions
makeMultiplier := method(factor,
    block(x, x * factor)
)

double := makeMultiplier(2)
triple := makeMultiplier(3)

double call(5) println  // 10
triple call(5) println  // 15

// Functions taking functions
twice := method(f, x,
    f call(f call(x))
)

twice(block(n, n + 1), 5) println  // 7

// Composition
compose := method(f, g,
    block(x, f call(g call(x)))
)

addOne := block(x, x + 1)
double := block(x, x * 2)
doubleThenAddOne := compose(addOne, double)

doubleThenAddOne call(5) println  // 11
</code></pre>
<h2 id="partial-application-and-currying">
  Partial Application and Currying
  
  <a class="anchor" href="#partial-application-and-currying">#</a>
  
</h2>
<pre><code class="language-io">// Partial application
add := block(a, b, a + b)

addFive := block(x, add call(5, x))
addFive call(3) println  // 8

// Currying
curry := method(f,
    block(a,
        block(b,
            f call(a, b)
        )
    )
)

curriedAdd := curry(add)
add5 := curriedAdd call(5)
add5 call(3) println  // 8

// More practical example
formatString := block(template, value,
    template interpolate(value)
)

curriedFormat := curry(formatString)
errorFormatter := curriedFormat call(&quot;Error: #{value}&quot;)
successFormatter := curriedFormat call(&quot;Success: #{value}&quot;)

errorFormatter call(&quot;File not found&quot;) println  // Error: File not found
successFormatter call(&quot;Operation complete&quot;) println  // Success: Operation complete
</code></pre>
<h2 id="lazy-evaluation-with-blocks">
  Lazy Evaluation with Blocks
  
  <a class="anchor" href="#lazy-evaluation-with-blocks">#</a>
  
</h2>
<p>Blocks don&rsquo;t evaluate until called, enabling lazy patterns:</p>
<pre><code class="language-io">// Lazy if (already built-in, but here's how it works)
lazyIf := method(condition, trueBlock, falseBlock,
    if(condition,
        trueBlock call,
        falseBlock call
    )
)

x := 5
lazyIf(x &gt; 3,
    block(&quot;Greater&quot; println),
    block(&quot;Lesser&quot; println)
)

// Lazy infinite sequences
naturals := method(start,
    block(
        n := start
        block(
            current := n
            n = n + 1
            current
        )
    ) call
)

seq := naturals(1)
5 repeat(seq call println)  // 1, 2, 3, 4, 5
</code></pre>
<h2 id="memoization">
  Memoization
  
  <a class="anchor" href="#memoization">#</a>
  
</h2>
<p>Use closures to cache expensive computations:</p>
<pre><code class="language-io">memoize := method(f,
    cache := Map clone
    
    block(
        args := call message arguments
        key := args asString
        
        if(cache hasKey(key),
            cache at(key),
            result := f call(args)
            cache atPut(key, result)
            result
        )
    )
)

// Expensive fibonacci
fib := block(n,
    if(n &lt; 2, n, fib call(n - 1) + fib call(n - 2))
)

// Memoized version
fastFib := memoize(fib)

// Much faster on repeated calls
time(fib call(30)) println
time(fastFib call(30)) println
</code></pre>
<h2 id="block-introspection">
  Block Introspection
  
  <a class="anchor" href="#block-introspection">#</a>
  
</h2>
<p>Blocks are objects you can inspect:</p>
<pre><code class="language-io">myBlock := block(x, y, x + y * 2)

// Inspect structure
myBlock argumentNames println  // list(x, y)
myBlock code println           // x +(y *(2))

// Modify blocks
myBlock setArgumentNames(list(&quot;a&quot;, &quot;b&quot;))
myBlock argumentNames println  // list(a, b)

// Create blocks programmatically
code := &quot;a + b&quot;
args := list(&quot;a&quot;, &quot;b&quot;)
dynamicBlock := Block clone setArgumentNames(args) setCode(code)
dynamicBlock call(3, 4) println  // 7
</code></pre>
<h2 id="blocks-in-data-structures">
  Blocks in Data Structures
  
  <a class="anchor" href="#blocks-in-data-structures">#</a>
  
</h2>
<pre><code class="language-io">// Table of operations
operations := Map with(
    &quot;+&quot;, block(a, b, a + b),
    &quot;-&quot;, block(a, b, a - b),
    &quot;*&quot;, block(a, b, a * b),
    &quot;/&quot;, block(a, b, a / b)
)

calculate := method(op, a, b,
    operations at(op) call(a, b)
)

calculate(&quot;+&quot;, 5, 3) println  // 8
calculate(&quot;*&quot;, 4, 7) println  // 28

// Event handlers
EventEmitter := Object clone
EventEmitter init := method(
    self events := Map clone
    self
)

EventEmitter on := method(event, handler,
    if(events hasKey(event) not,
        events atPut(event, list())
    )
    events at(event) append(handler)
    self
)

EventEmitter emit := method(event, data,
    if(events hasKey(event),
        events at(event) foreach(handler,
            handler call(data)
        )
    )
    self
)

// Usage
emitter := EventEmitter clone init
emitter on(&quot;click&quot;, block(data,
    (&quot;Clicked at: &quot; .. data) println
))
emitter on(&quot;click&quot;, block(data,
    (&quot;Another handler: &quot; .. data) println
))

emitter emit(&quot;click&quot;, &quot;x=10, y=20&quot;)
// Clicked at: x=10, y=20
// Another handler: x=10, y=20
</code></pre>
<h2 id="control-flow-with-blocks">
  Control Flow with Blocks
  
  <a class="anchor" href="#control-flow-with-blocks">#</a>
  
</h2>
<p>Create custom control structures:</p>
<pre><code class="language-io">// Retry logic
retry := method(times, block,
    attempts := 0
    loop(
        attempts = attempts + 1
        e := try(result := block call)
        
        if(e isNil, return result)
        if(attempts &gt;= times, Exception raise(e))
        
        (&quot;Attempt &quot; .. attempts .. &quot; failed, retrying...&quot;) println
    )
)

// Usage
result := retry(3, block(
    if(Random value &lt; 0.7,
        Exception raise(&quot;Random failure&quot;),
        &quot;Success!&quot;
    )
))

// While with condition block
whileTrue := method(conditionBlock, bodyBlock,
    while(conditionBlock call, bodyBlock call)
)

i := 0
whileTrue(
    block(i &lt; 5),
    block(
        i println
        i = i + 1
    )
)
</code></pre>
<h2 id="performance-considerations">
  Performance Considerations
  
  <a class="anchor" href="#performance-considerations">#</a>
  
</h2>
<pre><code class="language-io">// Method vs Block performance
obj := Object clone
obj value := 10

obj method1 := method(x, x + value)
obj block1 := block(x, x + 10)

// Methods are slightly faster for object operations
time(100000 repeat(obj method1(5)))
time(100000 repeat(obj block1 call(5)))

// But blocks are better for functional patterns
numbers := list(1, 2, 3, 4, 5)
time(numbers map(x, x * 2))  // Using block syntax
</code></pre>
<h2 id="advanced-patterns">
  Advanced Patterns
  
  <a class="anchor" href="#advanced-patterns">#</a>
  
</h2>
<h3 id="continuation-style-programming">
  Continuation-Style Programming
  
  <a class="anchor" href="#continuation-style-programming">#</a>
  
</h3>
<pre><code class="language-io">// Continuation passing style
factorial := method(n, continuation,
    if(n &lt;= 1,
        continuation call(1),
        factorial(n - 1, block(result,
            continuation call(n * result)
        ))
    )
)

factorial(5, block(result, result println))  // 120
</code></pre>
<h3 id="monadic-patterns">
  Monadic Patterns
  
  <a class="anchor" href="#monadic-patterns">#</a>
  
</h3>
<pre><code class="language-io">// Maybe monad
Maybe := Object clone
Maybe Nothing := Maybe clone
Maybe Just := method(value,
    m := Maybe clone
    m value := value
    m isNothing := false
    m
)
Maybe Nothing isNothing := true

Maybe bind := method(f,
    if(isNothing, Maybe Nothing, f call(value))
)

Maybe map := method(f,
    if(isNothing, 
        Maybe Nothing,
        Maybe Just(f call(value))
    )
)

// Usage
result := Maybe Just(5) \
    map(block(x, x * 2)) \
    bind(block(x, 
        if(x &gt; 5, 
            Maybe Just(x), 
            Maybe Nothing)
    )) \
    map(block(x, x + 1))

if(result isNothing not,
    result value println  // 11
)
</code></pre>
<h3 id="transducers">
  Transducers
  
  <a class="anchor" href="#transducers">#</a>
  
</h3>
<pre><code class="language-io">// Composable transformations
mapping := method(f,
    method(reducer,
        block(acc, item,
            reducer call(acc, f call(item))
        )
    )
)

filtering := method(pred,
    method(reducer,
        block(acc, item,
            if(pred call(item),
                reducer call(acc, item),
                acc
            )
        )
    )
)

// Compose transducers
transduce := method(xform, reducer, init, coll,
    xreducer := xform call(reducer)
    coll foreach(item,
        init = xreducer call(init, item)
    )
    init
)

// Usage
xform := filtering(block(x, x % 2 == 0)) call(
    mapping(block(x, x * 2))
)

result := transduce(xform, 
    block(acc, x, acc + x),
    0,
    list(1, 2, 3, 4, 5, 6)
)
result println  // 24 (2*2 + 4*2 + 6*2)
</code></pre>
<h2 id="common-pitfalls">
  Common Pitfalls
  
  <a class="anchor" href="#common-pitfalls">#</a>
  
</h2>
<h3 id="variable-capture">
  Variable Capture
  
  <a class="anchor" href="#variable-capture">#</a>
  
</h3>
<pre><code class="language-io">// PROBLEM: Loop variable capture
handlers := list()
for(i, 1, 3,
    handlers append(block(i println))
)

handlers foreach(h, h call)  // All print 3!

// SOLUTION: Create new scope
handlers := list()
for(i, 1, 3,
    handlers append(
        method(n, block(n println)) call(i)
    )
)

handlers foreach(h, h call)  // 1, 2, 3
</code></pre>
<h3 id="memory-leaks-with-closures">
  Memory Leaks with Closures
  
  <a class="anchor" href="#memory-leaks-with-closures">#</a>
  
</h3>
<pre><code class="language-io">// PROBLEM: Closure keeps large object alive
makeClosure := method(
    hugeData := List clone
    10000 repeat(hugeData append(Random value))
    
    block(x, x * 2)  // Doesn't use hugeData but keeps it alive!
)

// SOLUTION: Be explicit about captured variables
makeClosure := method(
    hugeData := List clone
    10000 repeat(hugeData append(Random value))
    processedValue := hugeData size  // Extract what you need
    hugeData = nil  // Release reference
    
    block(x, x * processedValue)
)
</code></pre>
<h2 id="exercises">
  Exercises
  
  <a class="anchor" href="#exercises">#</a>
  
</h2>
<ol>
<li>
<p><strong>Promise Implementation</strong>: Create a Promise/Future system using blocks for async operations.</p>
</li>
<li>
<p><strong>Stream Processing</strong>: Build a lazy stream processor with map, filter, and reduce.</p>
</li>
<li>
<p><strong>Function Decorator</strong>: Implement decorators for logging, timing, and caching.</p>
</li>
<li>
<p><strong>Parser Combinators</strong>: Create a simple parser combinator library using blocks.</p>
</li>
<li>
<p><strong>Reactive System</strong>: Build a simple FRP (Functional Reactive Programming) system.</p>
</li>
</ol>
<h2 id="real-world-example-pipeline-builder">
  Real-World Example: Pipeline Builder
  
  <a class="anchor" href="#real-world-example-pipeline-builder">#</a>
  
</h2>
<pre><code class="language-io">Pipeline := Object clone
Pipeline init := method(
    self steps := list()
    self
)

Pipeline add := method(step,
    steps append(step)
    self
)

Pipeline map := method(f,
    self add(block(data,
        data map(f)
    ))
)

Pipeline filter := method(pred,
    self add(block(data,
        data select(pred)
    ))
)

Pipeline tap := method(f,
    self add(block(data,
        f call(data)
        data
    ))
)

Pipeline run := method(input,
    result := input
    steps foreach(step,
        result = step call(result)
    )
    result
)

// Usage
pipeline := Pipeline clone init \
    filter(block(x, x % 2 == 0)) \
    map(block(x, x * x)) \
    tap(block(data, (&quot;After squaring: &quot; .. data) println)) \
    filter(block(x, x &gt; 10)) \
    map(block(x, x asString))

result := pipeline run(list(1, 2, 3, 4, 5, 6))
// After squaring: list(4, 16, 36)
result println  // list(&quot;16&quot;, &quot;36&quot;)
</code></pre>
<h2 id="conclusion">
  Conclusion
  
  <a class="anchor" href="#conclusion">#</a>
  
</h2>
<p>Blocks and closures are fundamental to Io&rsquo;s expressiveness. They&rsquo;re not just anonymous functions—they&rsquo;re first-class objects that capture context, enable functional programming, and allow you to extend the language with new control structures.</p>
<p>The distinction between blocks (isolated scope) and methods (shared scope with receiver) provides flexibility in how you structure code. Closures emerge naturally from Io&rsquo;s scope rules, making complex patterns like memoization, continuations, and higher-order functions straightforward to implement.</p>
<p>Understanding blocks deeply unlocks Io&rsquo;s full potential, enabling you to write code that&rsquo;s both powerful and elegant.</p>
<hr>

  
  <footer class="book-footer">
    
  </footer>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>





  
  
  
  <div class="flex flex-wrap justify-between">
    <span>
    
      <a href="/docs/08-collections/" class="flex align-center book-icon">
        <img src="/svg/backward.svg" class="book-icon" alt="Previous" title="Collections" />
        <span>Collections</span>
      </a>
    
    </span>
    <span>
    
      <a href="/docs/10-exceptions/" class="flex align-center book-icon">
        <span>Exceptions</span>
        <img src="/svg/forward.svg" class="book-icon" alt="Next" title="Exceptions" />
      </a>
    
    </span>
  </div>
  




  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 
      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    

 
  </main>

  
</body>
</html>















